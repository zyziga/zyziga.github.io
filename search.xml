<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nacos集群搭建</title>
      <link href="/archives/16.html"/>
      <url>/archives/16.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建</h1><h1 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a>1.集群结构图</h1><p>官方给出的Nacos集群图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131010963.png" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131010450.png" alt="image-20210409211355037"></p><p>三个nacos节点的地址：</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table><h1 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a>2.搭建集群</h1><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a>2.1.初始化数据库</h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">64</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`enabled` <span class="type">boolean</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `roles` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="keyword">ASC</span>, `role` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permissions` (</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password, enabled) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> roles (username, role) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131010593.png" alt="image-20230711101326136"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131010064.png" alt="image-20230711101454528"></p><h2 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a>2.2.下载nacos</h2><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.1版本：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131010682.png" alt="image-20210409212119411"></p><h2 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a>2.3.配置Nacos</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131010799.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131011840.png" alt="image-20210409212459292"></p><p>然后添加内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:8845</span><br><span class="line">127.0.0.1.8846</span><br><span class="line">127.0.0.1.8847</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131011112.png" alt="image-20230711102131364"></p><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131011056.png" alt="image-20230711102517435"></p><h2 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a>2.4.启动</h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131011442.png" alt="image-20210409213335538"> </p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8845</span></span><br></pre></td></tr></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8846</span></span><br></pre></td></tr></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8847</span></span><br></pre></td></tr></table></figure><p>然后分别启动三个nacos节点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd</span><br></pre></td></tr></table></figure><h2 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a>2.5.nginx反向代理</h2><p>找到课前资料提供的nginx安装包： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131011571.png" alt="image-20210410103253355"> </p><p>解压到任意非中文目录下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131011320.png" alt="image-20210410103322874"> </p><p>修改conf&#x2F;nginx.conf文件，配置如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> nacos-cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8845</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8846</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8847</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /nacos &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://nacos-cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131012009.png" alt="image-20230711103500365"></p><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure><p>账号和密码：nacos</p><p>代码中application.yml文件配置如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:80</span> <span class="comment"># Nacos地址</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/NacosClusterSetup/202307131012897.png" alt="image-20230711103918649"></p><h2 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a>2.6.优化</h2><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nacos安装指南</title>
      <link href="/archives/15.html"/>
      <url>/archives/15.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121635373.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121639637.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121641874.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121642147.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121642755.png" alt="image-20210402162251093"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121642234.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121642506.png" alt="image-20210402162526774"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121642202.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121643557.png" alt="image-20210402162709515"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121643362.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121643586.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121643058.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121643282.png" alt="image-20210402163715580"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121644899.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/InstallationGuide/202307121644666.png" alt="image-20210402164414827"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos&#x2F;bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud02</title>
      <link href="/archives/14.html"/>
      <url>/archives/14.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud02"><a href="#SpringCloud02" class="headerlink" title="SpringCloud02"></a>SpringCloud02</h1><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101717596.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><p>启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>访问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在浏览器输入地址：http://127.0.0.1:8848/nacos即可：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认的账号和密码都是nacos</span><br></pre></td></tr></table></figure><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718894.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userservice-dev.yaml</span><br><span class="line">userservice的开发环境配置文件</span><br><span class="line">pattern:</span><br><span class="line">    dateformat: yyyy-MM-dd HH:mm:ss</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718982.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526907.png" alt="image-20230710175718763"></p><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718662.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526540.png" alt="image-20230710180221652"></p><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718078.png" alt="image-20210714170845901"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526721.png" alt="image-20230710180612734"></p><p>注释掉</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526513.png" alt="image-20230711081809638"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718765.png" alt="image-20210714170337448"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526922.png" alt="image-20230711082137856"></p><p>在页面访问，可以看到效果：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718581.png" alt="image-20210714170449612"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526993.png" alt="image-20230711082503070"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526593.png" alt="image-20230711082609491"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526442.png" alt="image-20230711082828882"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121526985.png" alt="image-20230711082914858"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527467.png" alt="image-20230711082946022"></p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718437.png" alt="image-20210714171036335"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527328.png" alt="image-20230711083222308"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527872.png" alt="image-20230711083339165"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527232.png" alt="image-20230711083506948"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527372.png" alt="image-20230711083617894"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527392.png" alt="image-20230711083706290"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527640.png" alt="image-20230711084141925"></p><p>serController中使用这个类代替@Value：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718245.png" alt="image-20210714171316124"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.config.PatternProperties;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527921.png" alt="image-20230711084432466"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121527648.png" alt="image-20230711084612752"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528161.png" alt="image-20230711084710873"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528412.png" alt="image-20230711084754491"></p><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101718133.png" alt="image-20210714173233650"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528913.png" alt="image-20230711085036885"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userservice.yaml</span><br><span class="line">userservice的多环境共享配置</span><br><span class="line">pattern:</span><br><span class="line">    envSharedValue: 环境共享属性值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528257.png" alt="image-20230711085422795"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719509.png" alt="image-20210714173324231"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528561.png" alt="image-20230711085722139"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719973.png" alt="image-20210714173721309"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528841.png" alt="image-20230711092812099"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">  private PatternProperties properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @GetMapping(&quot;prop&quot;)</span><br><span class="line">  public PatternProperties properties()&#123;</span><br><span class="line">      return properties;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719429.png" alt="image-20210714173538538"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719813.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719629.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719518.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528057.png" alt="image-20230711095324470"></p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719869.png" alt="image-20210714174623557"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528401.png" alt="image-20230711095520827"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528698.png" alt="image-20230711095616210"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528793.png" alt="image-20230711095756987"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121601727.png" alt="image-20230711100144120"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121528785.png" alt="image-20230711100422926"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719597.png" alt="image-20210714174728042"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529009.png" alt="image-20230711105009484"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121602565.png" alt="image-20230711105035284"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529680.png" alt="image-20230711105232066"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529792.png" alt="image-20230711105437014"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529779.png" alt="image-20230711105501949"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529577.png" alt="image-20230711105549477"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529296.png" alt="image-20230711105611896"></p><h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101731320.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719101.png" alt="image-20210714174918088"></p><h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719285.png" alt="image-20210714175102524"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529129.png" alt="image-20230711110501946"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529480.png" alt="image-20230711110832686"></p><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：&#x2F;user&#x2F;{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private UserClient userClient;</span><br><span class="line"></span><br><span class="line">public Order queryOrderById(Long orderId) &#123;</span><br><span class="line">    // 1.查询订单</span><br><span class="line">    Order order = orderMapper.findById(orderId);</span><br><span class="line">    //2.利用Feign发起http请求，查询用户  用Feign进行远程调用</span><br><span class="line">    User user = userClient.findById((order.getUserId()));</span><br><span class="line">    //3.存入order    封装user到时Order</span><br><span class="line">    order.setUser(user);</span><br><span class="line">    // 4.返回</span><br><span class="line">    return order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529856.png" alt="image-20230711111505386"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719949.png" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><p>测试</p><p>启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nacos:</span><br><span class="line">startup.cmd</span><br><span class="line">nginx:</span><br><span class="line">D:\develop\Java software installation location\nginx_cluster\nginx-1.18.0&gt;start nginx.exe</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121529192.png" alt="image-20230711152530304"></p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121530825.png" alt="image-20230711153409785"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121530211.png" alt="image-20230711153456110"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121530929.png" alt="image-20230711153540440"></p><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.itcast.order.config;</span><br><span class="line">import feign.Logger;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">public class DefaultFeignConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Logger.Level feignLogLevel()&#123;</span><br><span class="line">        return Logger.Level.BASIC; // 日志级别为BASIC</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121530936.png" alt="image-20230711154116226"></p><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121530585.png" alt="image-20230711154249148"></p><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121530617.png" alt="image-20230711154506953"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121531977.png" alt="image-20230711154522414"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121531081.png" alt="image-20230711154609397"></p><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121531947.png" alt="image-20230711155240952"></p><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  httpclient:</span><br><span class="line">    enabled: true # 开启feign对HttpClient的支持</span><br><span class="line">    max-connections: 200 # 最大的连接数</span><br><span class="line">    max-connections-per-route: 50 # 每个路径的最大连接数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121531567.png" alt="image-20230711155547294"></p><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719614.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719894.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719061.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101719317.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720645.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720590.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720470.png" alt="image-20210714204557771"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121531648.png" alt="image-20230711160311088"></p><p>项目结构：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720037.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\zyz\AppData\Roaming\Typora\typora-user-images\image-20230711160458745.png" alt="image-20230711160458745"></p><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720693.png" alt="image-20210714205221970"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121531633.png" alt="image-20230711160948201"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121531625.png" alt="image-20230711161200217"></p><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720301.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><p>方式二：</p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(clients = UserClient.class,defaultConfiguration = DefaultFeignConfiguration.class)</span><br></pre></td></tr></table></figure><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720188.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720757.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10010 # 网关端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:80 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes: # 网关路由配置</span><br><span class="line">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class="line">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">        - id: order-service # 路由id，自定义，只要唯一即可</span><br><span class="line">            # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">            uri: lb://orderservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">            predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">              - Path=/order/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720004.png" alt="image-20210714211908341"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:10010/order/101</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534096.png" alt="image-20230712111536870"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720157.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><p>我们只需要掌握Path这种路由工程就可以了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10010 # 网关端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:80 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes: # 网关路由配置</span><br><span class="line">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class="line">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">        - id: order-service # 路由id，自定义，只要唯一即可</span><br><span class="line">            # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://orderservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/order/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">            -  After=2037-01-20T17:42:47.789-07:00[America/Denver]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534177.png" alt="image-20230712112211712"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534887.png" alt="image-20230712112253843"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10010 # 网关端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:80 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes: # 网关路由配置</span><br><span class="line">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class="line">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">        - id: order-service # 路由id，自定义，只要唯一即可</span><br><span class="line">            # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://orderservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/order/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">#            -  After=2037-01-20T17:42:47.789-07:00[America/Denver]</span><br><span class="line">            -  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534544.png" alt="image-20230712112533176"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534490.png" alt="image-20230712112500641"></p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720349.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10010 # 网关端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:80 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes: # 网关路由配置</span><br><span class="line">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class="line">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">          filters: # 过滤器</span><br><span class="line">            - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头</span><br><span class="line">        - id: order-service # 路由id，自定义，只要唯一即可</span><br><span class="line">            # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://orderservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/order/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">#            -  After=2037-01-20T17:42:47.789-07:00[America/Denver]</span><br><span class="line">            -  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 路径： /user/110</span><br><span class="line">   *</span><br><span class="line">   * @param id 用户id</span><br><span class="line">   * @return 用户</span><br><span class="line">   */</span><br><span class="line">  @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">  public User queryById(@PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">                        @RequestHeader(value = &quot;Truth&quot;,required = false) String truth) &#123;</span><br><span class="line">      System.out.println(&quot;truth:&quot; + truth);</span><br><span class="line">      return userService.queryById(id);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534056.png" alt="image-20230712143409666"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534728.png" alt="image-20230712143659691"></p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10010 # 网关端口</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:80 # nacos地址</span><br><span class="line">    gateway:</span><br><span class="line">      routes: # 网关路由配置</span><br><span class="line">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class="line">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">#          filters: # 过滤器</span><br><span class="line">#            - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头</span><br><span class="line">        - id: order-service # 路由id，自定义，只要唯一即可</span><br><span class="line">            # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class="line">          uri: lb://orderservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class="line">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class="line">            - Path=/order/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br><span class="line">#            -  After=2037-01-20T17:42:47.789-07:00[America/Denver]</span><br><span class="line">#            -  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span><br><span class="line">      default-filters: # 默认过滤项</span><br><span class="line">        - AddRequestHeader=Truth, Itcast is freaking awesome!</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534160.png" alt="image-20230712144512766"></p><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line">import org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.util.MultiValueMap;</span><br><span class="line">import org.springframework.web.server.ServerWebExchange;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//@Order(-1)</span><br><span class="line">@Component</span><br><span class="line">public class AuthorizeFilter   implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        // 1.获取请求参数</span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        // 2.获取authorization参数</span><br><span class="line">        String auth = params.getFirst(&quot;authorization&quot;);</span><br><span class="line">        // 3.校验</span><br><span class="line">        if (&quot;admin&quot;.equals(auth)) &#123;</span><br><span class="line">            // 放行</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        // 4.拦截</span><br><span class="line">        // 4.1.禁止访问，设置状态码</span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        // 4.2.结束处理</span><br><span class="line">        return exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum HttpStatus &#123;</span><br><span class="line">    CONTINUE(100, &quot;Continue&quot;),</span><br><span class="line">    SWITCHING_PROTOCOLS(101, &quot;Switching Protocols&quot;),</span><br><span class="line">    PROCESSING(102, &quot;Processing&quot;),</span><br><span class="line">    CHECKPOINT(103, &quot;Checkpoint&quot;),</span><br><span class="line">    OK(200, &quot;OK&quot;),</span><br><span class="line">    CREATED(201, &quot;Created&quot;),</span><br><span class="line">    ACCEPTED(202, &quot;Accepted&quot;),</span><br><span class="line">    NON_AUTHORITATIVE_INFORMATION(203, &quot;Non-Authoritative Information&quot;),</span><br><span class="line">    NO_CONTENT(204, &quot;No Content&quot;),</span><br><span class="line">    RESET_CONTENT(205, &quot;Reset Content&quot;),</span><br><span class="line">    PARTIAL_CONTENT(206, &quot;Partial Content&quot;),</span><br><span class="line">    MULTI_STATUS(207, &quot;Multi-Status&quot;),</span><br><span class="line">    ALREADY_REPORTED(208, &quot;Already Reported&quot;),</span><br><span class="line">    IM_USED(226, &quot;IM Used&quot;),</span><br><span class="line">    MULTIPLE_CHOICES(300, &quot;Multiple Choices&quot;),</span><br><span class="line">    MOVED_PERMANENTLY(301, &quot;Moved Permanently&quot;),</span><br><span class="line">    FOUND(302, &quot;Found&quot;),</span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    MOVED_TEMPORARILY(302, &quot;Moved Temporarily&quot;),</span><br><span class="line">    SEE_OTHER(303, &quot;See Other&quot;),</span><br><span class="line">    NOT_MODIFIED(304, &quot;Not Modified&quot;),</span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    USE_PROXY(305, &quot;Use Proxy&quot;),</span><br><span class="line">    TEMPORARY_REDIRECT(307, &quot;Temporary Redirect&quot;),</span><br><span class="line">    PERMANENT_REDIRECT(308, &quot;Permanent Redirect&quot;),</span><br><span class="line">    BAD_REQUEST(400, &quot;Bad Request&quot;),</span><br><span class="line">    UNAUTHORIZED(401, &quot;Unauthorized&quot;),</span><br><span class="line">    PAYMENT_REQUIRED(402, &quot;Payment Required&quot;),</span><br><span class="line">    FORBIDDEN(403, &quot;Forbidden&quot;),</span><br><span class="line">    NOT_FOUND(404, &quot;Not Found&quot;),</span><br><span class="line">    METHOD_NOT_ALLOWED(405, &quot;Method Not Allowed&quot;),</span><br><span class="line">    NOT_ACCEPTABLE(406, &quot;Not Acceptable&quot;),</span><br><span class="line">    PROXY_AUTHENTICATION_REQUIRED(407, &quot;Proxy Authentication Required&quot;),</span><br><span class="line">    REQUEST_TIMEOUT(408, &quot;Request Timeout&quot;),</span><br><span class="line">    CONFLICT(409, &quot;Conflict&quot;),</span><br><span class="line">    GONE(410, &quot;Gone&quot;),</span><br><span class="line">    LENGTH_REQUIRED(411, &quot;Length Required&quot;),</span><br><span class="line">    PRECONDITION_FAILED(412, &quot;Precondition Failed&quot;),</span><br><span class="line">    PAYLOAD_TOO_LARGE(413, &quot;Payload Too Large&quot;),</span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    REQUEST_ENTITY_TOO_LARGE(413, &quot;Request Entity Too Large&quot;),</span><br><span class="line">    URI_TOO_LONG(414, &quot;URI Too Long&quot;),</span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    REQUEST_URI_TOO_LONG(414, &quot;Request-URI Too Long&quot;),</span><br><span class="line">    UNSUPPORTED_MEDIA_TYPE(415, &quot;Unsupported Media Type&quot;),</span><br><span class="line">    REQUESTED_RANGE_NOT_SATISFIABLE(416, &quot;Requested range not satisfiable&quot;),</span><br><span class="line">    EXPECTATION_FAILED(417, &quot;Expectation Failed&quot;),</span><br><span class="line">    I_AM_A_TEAPOT(418, &quot;I&#x27;m a teapot&quot;),</span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    INSUFFICIENT_SPACE_ON_RESOURCE(419, &quot;Insufficient Space On Resource&quot;),</span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    METHOD_FAILURE(420, &quot;Method Failure&quot;),</span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    DESTINATION_LOCKED(421, &quot;Destination Locked&quot;),</span><br><span class="line">    UNPROCESSABLE_ENTITY(422, &quot;Unprocessable Entity&quot;),</span><br><span class="line">    LOCKED(423, &quot;Locked&quot;),</span><br><span class="line">    FAILED_DEPENDENCY(424, &quot;Failed Dependency&quot;),</span><br><span class="line">    TOO_EARLY(425, &quot;Too Early&quot;),</span><br><span class="line">    UPGRADE_REQUIRED(426, &quot;Upgrade Required&quot;),</span><br><span class="line">    PRECONDITION_REQUIRED(428, &quot;Precondition Required&quot;),</span><br><span class="line">    TOO_MANY_REQUESTS(429, &quot;Too Many Requests&quot;),</span><br><span class="line">    REQUEST_HEADER_FIELDS_TOO_LARGE(431, &quot;Request Header Fields Too Large&quot;),</span><br><span class="line">    UNAVAILABLE_FOR_LEGAL_REASONS(451, &quot;Unavailable For Legal Reasons&quot;),</span><br><span class="line">    INTERNAL_SERVER_ERROR(500, &quot;Internal Server Error&quot;),</span><br><span class="line">    NOT_IMPLEMENTED(501, &quot;Not Implemented&quot;),</span><br><span class="line">    BAD_GATEWAY(502, &quot;Bad Gateway&quot;),</span><br><span class="line">    SERVICE_UNAVAILABLE(503, &quot;Service Unavailable&quot;),</span><br><span class="line">    GATEWAY_TIMEOUT(504, &quot;Gateway Timeout&quot;),</span><br><span class="line">    HTTP_VERSION_NOT_SUPPORTED(505, &quot;HTTP Version not supported&quot;),</span><br><span class="line">    VARIANT_ALSO_NEGOTIATES(506, &quot;Variant Also Negotiates&quot;),</span><br><span class="line">    INSUFFICIENT_STORAGE(507, &quot;Insufficient Storage&quot;),</span><br><span class="line">    LOOP_DETECTED(508, &quot;Loop Detected&quot;),</span><br><span class="line">    BANDWIDTH_LIMIT_EXCEEDED(509, &quot;Bandwidth Limit Exceeded&quot;),</span><br><span class="line">    NOT_EXTENDED(510, &quot;Not Extended&quot;),</span><br><span class="line">    NETWORK_AUTHENTICATION_REQUIRED(511, &quot;Network Authentication Required&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534233.png" alt="image-20230712145828929"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:10010/user/1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534456.png" alt="image-20230712150405332"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:10010/user/1?authorization=admin</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121534151.png" alt="image-20230712150420705"></p><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720950.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720789.png" alt="image-20210714215713563"></p><p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p><p>可以在浏览器控制台看到下面的错误：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307101720237.png" alt="image-20210714215832675"></p><p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud02/202307121535017.png" alt="image-20230712152533004"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud01</title>
      <link href="/archives/13.html"/>
      <url>/archives/13.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud01"><a href="#SpringCloud01" class="headerlink" title="SpringCloud01"></a>SpringCloud01</h1><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="1-0-学习目标"><a href="#1-0-学习目标" class="headerlink" title="1.0.学习目标"></a>1.0.学习目标</h2><p>了解微服务架构的优缺点</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031109221.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110284.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110365.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110247.png" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110973.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110387.png" alt="image-20210713210800950"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110179.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110787.png" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110221.png" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031110758.png" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031111013.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031111607.png" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031111838.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031111924.png" alt="image-20210713212336185"></p><p>如果没有跳转到这个 则</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062300354.png" alt="image-20230703163944090"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062300160.png" alt="image-20230703164006372"></p><p>在这里面找到springboot</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062300389.png" alt="image-20230703164111350"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062300031.png" alt="image-20230703164144709"></p><p>会出现这样的菜单：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031113828.png" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114996.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114525.png" alt="image-20210713212749575"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/order/101</span><br></pre></td></tr></table></figure><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114380.png" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114540.png" alt="image-20210713213146089"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8081/user/1</span><br></pre></td></tr></table></figure><p>查询的结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114333.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031118716.png" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062300598.png" alt="image-20230704103712021"></p><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package cn.itcast.order.service;</span><br><span class="line"></span><br><span class="line">import cn.itcast.order.mapper.OrderMapper;</span><br><span class="line">import cn.itcast.order.pojo.Order;</span><br><span class="line">import cn.itcast.order.pojo.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public Order queryOrderById(Long orderId) &#123;</span><br><span class="line">        // 1.查询订单</span><br><span class="line">        Order order = orderMapper.findById(orderId);</span><br><span class="line">        //2.远程查询user   利用RestTemplate发起http请求，查询用户</span><br><span class="line">        //2.1 url地址</span><br><span class="line">        String url = &quot;http://localhost:8081/user/&quot; + order.getUserId();</span><br><span class="line">        //2.2 发起调用      发送http请求，实现远程调用</span><br><span class="line">        User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">        //3.存入order    封装user到时Order</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        // 4.返回</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114444.png" alt="image-20210713213959569"></p><p>注意： 这里面order user二个服务都得启动</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062300142.png" alt="image-20230704174158403"></p><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114317.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114437.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031118804.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114357.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114979.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031114980.png" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115139.png" alt="image-20210713221339022"></p><h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span>    <span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span>    <span class="comment">#eureka的服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> </span><br><span class="line">    <span class="attr">service-url:</span>             <span class="comment"># eureka的地址信息</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062300662.png" alt="image-20230705222650612"></p><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115643.png" alt="image-20210713222157190"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307101639723.png" alt="image-20230705222721212"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062301038.png" alt="image-20230705223014963"></p><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062301023.png" alt="image-20230705223411191"></p><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115347.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115115.png" alt="image-20210713222757702"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8082</span><br></pre></td></tr></table></figure><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031127067.png" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031127402.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031128499.png" alt="image-20230703112826939"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115460.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115369.png" alt="image-20210713224245731"></p><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115019.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031128106.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115444.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115860.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115661.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115780.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115660.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031115770.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116787.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116797.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116692.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307061812668.png" alt="image-20230706181138745"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062301199.png" alt="image-20230706181253293"></p><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/order/101-----http://localhost:8080/order/105</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062303574.png" alt="image-20230706181428544"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062301465.png" alt="image-20230706181609883"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062303469.png" alt="image-20230706181637816"></p><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062302893.png" alt="image-20230706182142139"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062302390.png" alt="image-20230706182408644"></p><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116371.png" alt="image-20210713230444308"></p><p>安装方式可以参考课前资料《Nacos安装指南.md》</p><h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062303925.png" alt="image-20230706184228856"></p><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062303605.png" alt="image-20230706184529710"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062303741.png" alt="image-20230706184558930"></p><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062303846.png" alt="image-20230706185007801"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307062303054.png" alt="image-20230706185138638"></p><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116875.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116661.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116333.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116077.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p>配置如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116165.png" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031129115.png" alt="image-20210713233727923"></p><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116507.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116268.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116716.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031129828.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116699.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031116891.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031117275.png" alt="image-20210714000522913"></p><h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031117563.png" alt="image-20210714000830703"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031117459.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031117076.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/Microservices/2021Edition/SpringCloud01/202307031117403.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖项目优化-Day03</title>
      <link href="/archives/12.html"/>
      <url>/archives/12.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖项目优化-Day03"><a href="#瑞吉外卖项目优化-Day03" class="headerlink" title="瑞吉外卖项目优化-Day03"></a>瑞吉外卖项目优化-Day03</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li><p>前后端分离开发</p></li><li><p>Yapi</p></li><li><p>Swagger</p></li><li><p>项目部署</p></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>当前项目中，前端代码和后端代码混合在一起，是存在问题的，存在什么问题呢？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011728982.png" alt="image-20210831232554721"> </p><p>主要存在以下几点问题： </p><p>1). 开发人员同时负责前端和后端代码开发，分工不明确</p><p>2). 开发效率低</p><p>3). 前后端代码混合在一个工程中，不便于管理</p><p>4). 对开发人员要求高(既会前端，又会后端)，人员招聘困难</p><p>为了解决上述提到的问题，现在比较主流的开发方式，就是<strong>前后端分离开发</strong>，前端人员开发前端的代码，后端开发人员开发服务端的业务功能，分工明确，各司其职。我们本章节，就是需要将之前的项目进行优化改造，变成前后端分离开发的项目。</p><h2 id="1-前后端分离开发"><a href="#1-前后端分离开发" class="headerlink" title="1. 前后端分离开发"></a>1. 前后端分离开发</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p><strong>前后端分离开发</strong>，就是在项目开发过程中，对于前端代码的开发由专门的前端开发人员负责，后端代码则由后端开发人员负责，这样可以做到分工明确、各司其职，提高开发效率，前后端代码并行开发，可以加快项目开发进度。</p><p>目前，前后端分离开发方式已经被越来越多的公司所采用，成为当前项目开发的主流开发方式。</p><p>前后端分离开发后，从工程结构上也会发生变化，即前后端代码不再混合在同一个maven工程中，而是分为 <strong>前端工程</strong> 和 <strong>后端工程</strong> 。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011728100.png" alt="image-20210901082121874"> </p><p>前后端分离之后，不仅工程结构变化，后期项目上线部署时，与之前也不同:</p><p>1). 之前: 前后端代码都混合在一起，我们只需要将前端和后端的代码统一打成jar包，直接运行就可以了。 </p><p>2). 现在: 拆分为前后端分离的项目后，最终部署时，后端工程会打成一个jar包，运行在Tomcat中(springboot内嵌的tomcat)。前端工程的静态资源，会直接部署在Nginx中进行访问。</p><h3 id="1-2-开发流程"><a href="#1-2-开发流程" class="headerlink" title="1.2 开发流程"></a>1.2 开发流程</h3><p>前后端分离开发后，面临一个问题，就是前端开发人员和后端开发人员如何进行配合来共同开发一个项目？可以按照如下流程进行：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011728516.png" alt="image-20210901084945348">            <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011734770.png" alt="image-20210901085057990"> </p><p>1). 定制接口: 这里所说的接口不是我们之前在service， mapper层定义的interface； 这里的接口(API接口)就是一个http的请求地址，主要就是去定义：请求路径、请求方式、请求参数、响应数据等内容。(具体接口文档描述的信息, 如上图)</p><p>2). 前后端并行开发: 依据定义好的接口信息，前端人员开发前端的代码，服务端人员开发服务端的接口； 在开发中前后端都需要进行测试，后端需要通过对应的工具来进行接口的测试，前端需要根据接口定义的参数进行Mock数据模拟测试。</p><p>3). 联调: 当前后端都开发完毕并且自测通过之后，就可以进行前后端的联调测试了，在这一阶段主要就是校验接口的参数格式。</p><p>4). 提测: 前后端联调测试通过之后，就可以将项目部署到测试服务器，进行自动化测试了。</p><h3 id="1-3-前端技术栈"><a href="#1-3-前端技术栈" class="headerlink" title="1.3 前端技术栈"></a>1.3 前端技术栈</h3><p><strong>1). 开发工具</strong></p><p>Visual Studio Code (简称VsCode)</p><p>Hbuilder</p><p><strong>2). 技术框架</strong></p><p>A. Node.js:  Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。(类似于java语言中的JDK)。</p><p>B. Vue : 目前最火的的一个前端javaScript框架。</p><p>C. ElementUI: 一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库，通过ElementUI组件可以快速构建项目页面。</p><p>D. Mock: 生成随机数据，拦截 Ajax 请求，前端可以借助于Mock生成测试数据进行功能测试。</p><p>E. Webpack: webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p><h2 id="2-Yapi"><a href="#2-Yapi" class="headerlink" title="2. Yapi"></a>2. Yapi</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011734342.png" alt="image-20210901110936381"> </p><p>YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。</p><p>YApi让接口开发更简单高效，让接口的管理更具可读性、可维护性，让团队协作更合理。</p><p>源码地址: <a href="https://github.com/YMFE/yapi">https://github.com/YMFE/yapi</a></p><p>官方文档: <a href="https://hellosean1025.github.io/yapi/">https://hellosean1025.github.io/yapi/</a></p><p>要使用YApi，项目组需要自己进行部署，在本项目中我们可以使用课程提供的平台进行测试，域名： <a href="https://mock-java.itheima.net/">https://mock-java.itheima.net/</a></p><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><h4 id="2-2-1-准备"><a href="#2-2-1-准备" class="headerlink" title="2.2.1 准备"></a>2.2.1 准备</h4><p>注册账号，登录平台</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011734572.png" alt="image-20210901115408908"> </p><h4 id="2-2-2-定义接口"><a href="#2-2-2-定义接口" class="headerlink" title="2.2.2 定义接口"></a>2.2.2 定义接口</h4><p>登录到Yapi平台之后，我们可以创建项目，在项目下创建接口分类，在对应的分类中添加接口。</p><p> 1). 创建项目</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011734190.png" alt="image-20210901123709298"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011734668.png" alt="image-20210901124623325"> </p><p>2). 添加分类</p><p>在当前项目中,有针对于员工、菜品、套餐、订单的操作，我们在进行接口维护时，可以针对接口进行分类，如果没有对应的分类，我们自己添加分类。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011734964.png" alt="image-20210901125311166"> </p><p>3). 添加接口</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011738957.png" alt="image-20210901125517274"> </p><p>接口基本信息录入之后，添加提交，就可以看到该接口的基本信息：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011735539.png" alt="image-20210901125617777">  </p><p>但是目前，接口中我们并未指定请求参数，响应数据等信息，我们可以进一步点击编辑，对该接口 详情进行编辑处理。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011735589.png" alt="image-20210901140052897"> </p><p>4). 运行接口</p><p>Yapi也提供了接口测试功能，当我们接口编辑完毕后，后端服务的代码开发完毕，启动服务，就可以使用Yapi进行接口测试了。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736524.png" alt="image-20210901140924816"> </p><p><font color='red'>注意： 由于菜品分页查询接口，是需要登录后才可以访问的，所以在测试该接口时，需要先请求员工管理接口中的登录接口，登录完成后，再访问该接口。</font></p><p>在Yapi平台中，将接口文档定义好了之后，前后端开发人员就需要根据接口文档中关于接口的描述进行前端和后端功能的开发。</p><h4 id="2-2-3-导出接口文档"><a href="#2-2-3-导出接口文档" class="headerlink" title="2.2.3 导出接口文档"></a>2.2.3 导出接口文档</h4><p>在Yapi平台中我们不仅可以在线阅读文档，还可以将Yapi中维护的文档直接导出来，可以导出md，json，html格式，在导出时自行选择即可 。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736807.png" alt="image-20210901150153468"> </p><p>而在导出的html文件或md文件中，主要描述的就是接口的基本信息， 包括： 请求路径、请求方式、接口描述、请求参数、返回数据等信息。展示形式如下： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736484.png" alt="image-20210901150401976" style="zoom: 80%;" /> <h4 id="2-2-4-导入接口文档"><a href="#2-2-4-导入接口文档" class="headerlink" title="2.2.4 导入接口文档"></a>2.2.4 导入接口文档</h4><p>上述我们讲解了接口文档的导出，我们也可以将外部的接口文档导入到Yapi的平台中，这样我们就不用一个接口一个接口的添加了。我们可以将课程资料中提供的json格式的接口文档直接导入Yapi平台中来。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736723.png" alt="image-20210901151127926" style="zoom:80%;" /> <p>导入过程中出现的确认弹窗，选择”确认”。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011739276.png" alt="image-20210901151508478" style="zoom:80%;" /> <p>导入成功之后，我们就可以在Yapi平台查看到已导入的接口。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736363.png" alt="image-20210901151721356"> </p><h2 id="3-Swagger"><a href="#3-Swagger" class="headerlink" title="3. Swagger"></a>3. Swagger</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>官网：<a href="https://swagger.io/">https://swagger.io/</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736757.png" alt="image-20210901160434736"> </p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。功能主要包含以下几点:</p><p>A. 使得前后端分离开发更加方便，有利于团队协作</p><p>B. 接口文档在线自动生成，降低后端开发人员编写接口文档的负担</p><p>C. 接口功能测试</p><p>使用Swagger只需要按照它的规范去定义接口及接口相关的信息，再通过Swagger衍生出来的一系列项目和工具，就可以做到生成各种格式的接口文档，以及在线接口调试页面等等。</p><p>直接使用Swagger, 需要按照Swagger的规范定义接口, 实际上就是编写Json文件，编写起来比较繁琐、并不方便, 。而在项目中使用，我们一般会选择一些现成的框架来简化文档的编写，而这些框架是基于Swagger的，如knife4j。knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案。而我们要使用kinfe4j，需要在pom.xml中引入如下依赖即可： </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建新的分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022223091.png" alt="image-20230702095658136"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225220.png" alt="image-20230702095736550"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225690.png" alt="image-20230702095803017"></p><h3 id="3-2-使用方式"><a href="#3-2-使用方式" class="headerlink" title="3.2 使用方式"></a>3.2 使用方式</h3><p>接下来，我们就将我们的项目集成Knife4j，来自动生成接口文档。这里我们还是需要再创建一个新的分支v1.2，在该分支中进行knife4j的集成，集成测试完毕之后，没有问题，我们再将v1.2分支合并到master。</p><p>使用knife4j，主要需要操作以下几步:</p><p><strong>1). 导入knife4j的maven坐标</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022223407.png" alt="image-20230702095927606"></p><p><strong>2). 导入knife4j相关配置类</strong></p><p>这里我们就不需要再创建一个新的配置类了，我们直接在WebMvcConfig配置类中声明即可。</p><p>A. 在该配置类中加上两个注解 @EnableSwagger2 @EnableKnife4j ,开启Swagger和Knife4j的功能。</p><p>B. 在配置类中声明一个Docket类型的bean, 通过该bean来指定生成文档的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置静态资源映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始进行静态资源映射...&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/backend/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/front/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/front/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展mvc框架的消息转换器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;扩展消息转换器...&quot;</span>);</span><br><span class="line">        <span class="comment">//创建消息转换器对象</span></span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">messageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        <span class="comment">//设置对象转换器，底层使用Jackson将Java对象转为json</span></span><br><span class="line">        messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">        <span class="comment">//将上面的消息转换器对象追加到mvc框架的转换器集合中</span></span><br><span class="line">        converters.add(<span class="number">0</span>,messageConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 文档类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.itheima.reggie.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;瑞吉外卖&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;瑞吉外卖接口文档&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意： Docket声明时，指定的有一个包扫描的路径，该路径指定的是Controller所在包的路径。因为Swagger在生成接口文档时，就是根据这里指定的包路径，自动的扫描该包下的@Controller， @RestController， @RequestMapping等SpringMVC的注解，依据这些注解来生成对应的接口文档。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225162.png" alt="image-20230702100430703"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225555.png" alt="image-20230702100451505"></p><p><strong>3). 设置静态资源映射</strong></p><p>由于Swagger生成的在线文档中，涉及到很多静态资源，这些静态资源需要添加静态资源映射，否则接口文档页面无法访问。因此需要在 WebMvcConfig类中的addResourceHandlers方法中增加如下配置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225356.png" alt="image-20230702100645457"></p><p><strong>4). 在LoginCheckFilter中设置不需要处理的请求路径</strong></p><p>需要将Swagger及Knife4j相关的静态资源直接放行，无需登录即可访问，否则我们就需要登录之后，才可以访问接口文档的页面。</p><p>在原有的不需要处理的请求路径中，再增加如下链接： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;/doc.html&quot;</span>,</span><br><span class="line"><span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line"><span class="string">&quot;/swagger-resources&quot;</span>,</span><br><span class="line"><span class="string">&quot;/v2/api-docs&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736916.png" alt="image-20210901171132242"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225666.png" alt="image-20230702100834686"></p><h3 id="3-3-查看接口文档"><a href="#3-3-查看接口文档" class="headerlink" title="3.3 查看接口文档"></a>3.3 查看接口文档</h3><p>经过上面的集成配置之后，我们的项目集成Swagger及Knife4j就已经完成了，接下来我们可以重新启动项目，访问接口文档，访问链接为： <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><p>注意：我这边用到主从复制  并且mysql安装在linux上  所以一定要去linux上开启mysql</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225884.png" alt="image-20230702101557831"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736716.png" alt="image-20210901200739975"> </p><p>我们可以看到，在所有的Controller中提供的所有的业务增删改查的接口，全部都已经自动生成了，我们通过接口文档可以看到请求的url、请求方式、请求参数、请求实例、响应的参数，响应的示例。 并且呢，我们也可以通过这份在线的接口文档，对接口进行测试。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011739774.png" alt="image-20210901201229838"> </p><p>注意： 由于我们服务端的Controller中的业务增删改查的方法，都是必须登录之后才可以访问的，所以，我们在测试时候，也是需要先访问登录接口。登录完成之后，我们可以再访问其他接口进行测试。</p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022225314.png" alt="image-20230702102240516"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226802.png" alt="image-20230702102345621"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226868.png" alt="image-20230702102313516"></p><p>登录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226890.png" alt="image-20230702102447059"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226725.png" alt="image-20230702111312178"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226146.png" alt="image-20230702102514527"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022229194.png" alt="image-20230702111248929"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226202.png" alt="image-20230702111409713"></p><p>我们不仅可以在浏览器浏览生成的接口文档，Knife4j还支持离线文档，对接口文档进行下载，支持下载的格式有：markdown、html、word、openApi。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736588.png" alt="image-20210901214706928"> </p><h3 id="3-4-常用注解"><a href="#3-4-常用注解" class="headerlink" title="3.4 常用注解"></a>3.4 常用注解</h3><h4 id="3-4-1-问题说明"><a href="#3-4-1-问题说明" class="headerlink" title="3.4.1 问题说明"></a>3.4.1 问题说明</h4><p>在上面我们直接访问Knife4j的接口文档页面，可以查看到所有的接口文档信息，但是我们发现，这些接口文档分类及接口描述都是Controller的类名(驼峰命名转换而来)及方法名，而且在接口文档中，所有的请求参数，响应数据，都没有中文的描述，并不知道里面参数的含义，接口文档的可读性很差。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011736058.png" alt="image-20210901215244539"> </p><h4 id="3-4-2-注解介绍"><a href="#3-4-2-注解介绍" class="headerlink" title="3.4.2 注解介绍"></a>3.4.2 注解介绍</h4><p>为了解决上述的问题，Swagger提供了很多的注解，通过这些注解，我们可以更好更清晰的描述我们的接口，包含接口的请求参数、响应数据、数据模型等。核心的注解，主要包含以下几个： </p><table><thead><tr><th>注解</th><th>位置</th><th>说明</th></tr></thead><tbody><tr><td>@Api</td><td>类</td><td>加载Controller类上,表示对类的说明</td></tr><tr><td>@ApiModel</td><td>类(通常是实体类)</td><td>描述实体类的作用</td></tr><tr><td>@ApiModelProperty</td><td>属性</td><td>描述实体类的属性</td></tr><tr><td>@ApiOperation</td><td>方法</td><td>说明方法的用途、作用</td></tr><tr><td>@ApiImplicitParams</td><td>方法</td><td>表示一组参数说明</td></tr><tr><td>@ApiImplicitParam</td><td>方法</td><td>用在@ApiImplicitParams注解中，指定一个请求参数的各个方面的属性</td></tr></tbody></table><h4 id="3-4-3-注解测试"><a href="#3-4-3-注解测试" class="headerlink" title="3.4.3 注解测试"></a>3.4.3 注解测试</h4><p><strong>1). 实体类</strong></p><blockquote><p>可以通过 @ApiModel , @ApiModelProperty 来描述实体类及属性</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(&quot;套餐&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Setmeal</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;主键&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分类id</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;分类id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long categoryId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//套餐名称</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;套餐名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//套餐价格</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;套餐价格&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态 0:停用 1:启用</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;状态&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;套餐编号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//描述信息</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;描述信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;图片&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226603.png" alt="image-20230702114335587"></p><p><strong>2). 响应实体R</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(&quot;返回结果&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;编码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码：1成功，0和其它数字为失败</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;错误信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;动态数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//动态数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略静态方法 ....</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022226666.png" alt="image-20230702114509946"></p><p><strong>3). Controller类及其中的方法</strong></p><blockquote><p>描述Controller、方法及其方法参数，可以通过注解： @Api， @APIOperation， @ApiImplicitParams, @ApiImplicitParam</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/setmeal&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;套餐相关接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetmealController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SetmealService setmealService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryService categoryService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SetmealDishService setmealDishService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增套餐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> setmealDto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;新增套餐接口&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> SetmealDto setmealDto)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;套餐信息：&#123;&#125;&quot;</span>,setmealDto);</span><br><span class="line"></span><br><span class="line">        setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(<span class="string">&quot;新增套餐成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 套餐分页查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;套餐分页查询接口&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;page&quot;,value = &quot;页码&quot;,required = true),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;pageSize&quot;,value = &quot;每页记录数&quot;,required = true),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;name&quot;,value = &quot;套餐名称&quot;,required = false)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span>&#123;</span><br><span class="line">        <span class="comment">//分页构造器对象</span></span><br><span class="line">        Page&lt;Setmeal&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">        Page&lt;SetmealDto&gt; dtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加查询条件，根据name进行like模糊查询</span></span><br><span class="line">        queryWrapper.like(name != <span class="literal">null</span>,Setmeal::getName,name);</span><br><span class="line">        <span class="comment">//添加排序条件，根据更新时间降序排列</span></span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        setmealService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象拷贝</span></span><br><span class="line">        BeanUtils.copyProperties(pageInfo,dtoPage,<span class="string">&quot;records&quot;</span>);</span><br><span class="line">        List&lt;Setmeal&gt; records = pageInfo.getRecords();</span><br><span class="line"></span><br><span class="line">        List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">            <span class="type">SetmealDto</span> <span class="variable">setmealDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetmealDto</span>();</span><br><span class="line">            <span class="comment">//对象拷贝</span></span><br><span class="line">            BeanUtils.copyProperties(item,setmealDto);</span><br><span class="line">            <span class="comment">//分类id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();</span><br><span class="line">            <span class="comment">//根据分类id查询分类对象</span></span><br><span class="line">            <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line">            <span class="keyword">if</span>(category != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//分类名称</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">                setmealDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> setmealDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        dtoPage.setRecords(list);</span><br><span class="line">        <span class="keyword">return</span> R.success(dtoPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除套餐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping</span></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;套餐删除接口&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;ids:&#123;&#125;&quot;</span>,ids);</span><br><span class="line"></span><br><span class="line">        setmealService.removeWithDish(ids);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(<span class="string">&quot;套餐数据删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据条件查询套餐数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> setmeal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;setmealCache&quot;,key = &quot;#setmeal.categoryId + &#x27;_&#x27; + #setmeal.status&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;套餐条件查询接口&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;List&lt;Setmeal&gt;&gt; <span class="title function_">list</span><span class="params">(Setmeal setmeal)</span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(setmeal.getCategoryId() != <span class="literal">null</span>,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">        queryWrapper.eq(setmeal.getStatus() != <span class="literal">null</span>,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">        queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227484.png" alt="image-20230702115133026"></p><p><strong>4). 重启服务测试</strong></p><p>我们上述通过Swagger的注解，对实体类及实体类中的属性，以及Controller和Controller的方法进行描述，接下来，我们重新启动服务，然后看一下自动生成的接口文档有何变化。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737659.png" alt="image-20210901221213897"> </p><p>在接口文档的页面中，我们可以看到接口的中文描述，清晰的看到每一个接口是做什么的，接口方法参数什么含义，参数是否是必填的，响应结果的参数是什么含义等，都可以清楚的描述出来。</p><p>总之，我们要想清晰的描述一个接口，就需要借助于Swagger给我们提供的注解。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227114.png" alt="image-20230702115424608"></p><h2 id="4-项目部署"><a href="#4-项目部署" class="headerlink" title="4. 项目部署"></a>4. 项目部署</h2><p>在本章节，我们要做的是项目的部署，包含前端项目的部署，及后端项目的部署。</p><h3 id="4-1-部署架构"><a href="#4-1-部署架构" class="headerlink" title="4.1 部署架构"></a>4.1 部署架构</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737843.png" alt="image-20210901221425159"> </p><p>PC端： 主要是为餐厅的员工及管理员使用的后台管理系统，对分类、菜品、套餐信息进行维护。</p><p>移动端： 可以基于微信公众号或小程序实现，我们课上并未实现，这部分的工作是前端开发人员需要开发的。</p><p>前端部署服务器： Nginx</p><p>后端部署服务器： Tomcat(内嵌)</p><h3 id="4-2-环境说明"><a href="#4-2-环境说明" class="headerlink" title="4.2 环境说明"></a>4.2 环境说明</h3><p>由于我们的服务器数量有限，就使用这三台服务器，具体的软件规划如下: </p><table><thead><tr><th>服务器</th><th>软件</th><th>名称</th></tr></thead><tbody><tr><td>192.168.138.100</td><td>Nginx(部署前端项目、配置反向代理)，MySQL(主从复制的主库)</td><td>服务器A</td></tr><tr><td>192.168.138.101</td><td>JDK1.8、Git、Maven、jar(项目jar包基于内嵌Tomcat运行)、MySQL(主从复制的从库)</td><td>服务器B</td></tr><tr><td>172.17.2.94</td><td>Redis(缓存中间件)</td><td>服务器C</td></tr></tbody></table><p>由于我们前面的课程中Nginx、MySQL的主从复制、Redis、JDK、Git、Maven都已经演示过安装及配置了，这里我们就不再演示软件的安装了。</p><h3 id="4-3-前端部署"><a href="#4-3-前端部署" class="headerlink" title="4.3 前端部署"></a>4.3 前端部署</h3><p><strong>1). 在服务器A(192.168.138.100)中安装Nginx，将课程资料中的dist目录上传到Nginx的html目录下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737307.png" alt="image-20210901231943256"> </p><p>将整个dist目录上传至&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/html</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737635.png" alt="image-20210901231924028"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227100.png" alt="image-20230702120513944"></p><p><strong>2). 修改Nginx配置文件nginx.conf</strong></p><p>将nginx.conf配置文件中，将原有的监听80, 82, 8080端口号 的虚拟主机注释掉，引入如下的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227987.png" alt="image-20230702142517571"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227722.png" alt="image-20230702142615224"></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line">  <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">listen</span>       <span class="string">80;</span></span><br><span class="line">      <span class="attr">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">          <span class="attr">root</span>   <span class="string">html/dist;</span></span><br><span class="line">          <span class="attr">index</span>  <span class="string">index.html;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">location</span> <span class="string">^~ /api/ &#123;</span></span><br><span class="line"><span class="attr">rewrite</span> <span class="string">^/api/(.*)$ /$1 break;</span></span><br><span class="line"><span class="attr">proxy_pass</span> <span class="string">http://192.168.138.101:8080;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">location</span> = <span class="string">/50x.html &#123;</span></span><br><span class="line">          <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737655.png" alt="image-20210901232931577"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227396.png" alt="image-20230702143244201"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227955.png" alt="image-20230702143603559"></p><p><strong>3). 通过nginx访问前端工程</strong></p><p>注意：如果启动不成功  请关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p><a href="http://192.168.138.100/">http://192.168.138.100</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011740757.png" alt="image-20210901233135468"> </p><p><a href="http://192.168.145.100/">http://192.168.145.100</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227899.png" alt="image-20230702144019624"></p><h3 id="4-4-反向代理配置"><a href="#4-4-反向代理配置" class="headerlink" title="4.4 反向代理配置"></a>4.4 反向代理配置</h3><p>前端工程部署完成之后，我们可以正常的访问到系统的登录页面，点击登录按钮，可以看到服务端发起的请求，请求信息如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737061.png" alt="image-20210901234142706"> </p><p>而大家知道，在我们之前开发的工程中，是没有&#x2F;api这个前缀的,那这个时候,在不修改服务端代码的情况下，如何处理该请求呢? </p><p>实际上，通过nginx的就可以轻松解决这个问题。</p><p>在上述我们配置的nginx.conf中，除了配置了静态资源的加载目录以外，我们还配置了一段反向代理的配置，配置信息如下： </p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">location</span> <span class="string">^~ /api/ &#123;</span></span><br><span class="line">    <span class="attr">rewrite</span> <span class="string">^/api/(.*)$ /$1 break;</span></span><br><span class="line">    <span class="attr">proxy_pass</span> <span class="string">http://192.168.138.101:8080;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>这一段配置代表，如果请求当前nginx，并且请求的路径如果是 &#x2F;api&#x2F; 开头，将会被该location处理。而在该location中，主要配置了两块儿信息： rewrite(url重写) 和 proxy_pass(反向代理)。 接下来我们就来解析一下这两项的配置。</p><p><strong>1). 路径重写rewrite</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rewrite ^/api/(.*)$ /$1 break;</span><br></pre></td></tr></table></figure><p>这里写的是一个正则表达式，代表如果请求路径是以 <code>/api/</code> 开头，后面的请求路径任意，此时将原始的url路径重写为 <code>/$1</code>，这里的<code>$1</code>指代的就是通配符 .* 这一块的内容。比如： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/api/employee/login ------&gt; ^/api/(.*)$ --------&gt; 此时 (.*) 匹配的就是 employee/login ------&gt; 最终重写为/$1 : /employee/login</span><br></pre></td></tr></table></figure><p><strong>2). 反向代理</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_pass http://192.168.138.101:8080;</span><br></pre></td></tr></table></figure><p>路径重写后的请求，将会转发到后端的 <a href="http://192.168.138.101:8080/">http://192.168.138.101:8080</a> 服务器中。 而这台服务器中，就部署的是我们的后端服务。</p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227967.png" alt="image-20230702144438335"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227787.png" alt="image-20230702144514282"></p><h3 id="4-5-服务端部署"><a href="#4-5-服务端部署" class="headerlink" title="4.5 服务端部署"></a>4.5 服务端部署</h3><p><strong>1). 在服务器B(192.168.138.101)中安装jdk、git、maven、MySQL，使用git clone命令将git远程仓库的代码克隆下来</strong></p><p>A. 确认JDK环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737924.png" alt="image-20210902002307537"> </p><p>B. 确认Git环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  --version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737164.png" alt="image-20210902002328883"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><p>C. 确认Maven环境</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737588.png" alt="image-20210902002357900"> </p><p>D. 将我们开发完成的代码推送至远程仓库,并在服务器B中克隆下来</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建java代码存放目录</span></span><br><span class="line">mkdir -p /usr/local/javaapp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换目录</span></span><br><span class="line">cd /usr/local/javaapp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">克隆代码 , 需要使用自己的远程仓库</span></span><br><span class="line">git clone https://gitee.com/ChuanZhiBoKe/reggie_take_out.git </span><br><span class="line">git clone https://gitee.com/zhang-yongzai/reggie_take_out.git</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737084.png" alt="image-20210902004033417">  </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227938.png" alt="image-20230702150847634"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227563.png" alt="image-20230702150946911"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022227867.png" alt="image-20230702151334855"></p><p><strong>2). 将资料中提供的reggieStart.sh文件上传到服务器B，通过chmod命令设置执行权限</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022228020.png" alt="image-20230702152025263"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 reggieStart.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737324.png" alt="image-20210902004308106"> </p><p><strong>3). 执行reggieStart.sh脚本文件，自动部署项目</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./reggieStart.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011737981.png" alt="image-20210902005320980"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022228962.png" alt="image-20230702152453878"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022228556.png" alt="image-20230702154010810"></p><p>执行完shell脚本之后，我们可以通过 ps -ef|grep java 指令，查看服务是否启动。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011738012.png" alt="image-20210902005450399"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307022228418.png" alt="image-20230702154122600"></p><p><strong>4). 访问系统测试</strong></p><p><a href="http://192.168.138.101/">http://192.168.138.101/</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011738860.png" alt="image-20210902005640875"> </p><h3 id="4-6-图片展示问题处理"><a href="#4-6-图片展示问题处理" class="headerlink" title="4.6 图片展示问题处理"></a>4.6 图片展示问题处理</h3><p>在上述的测试中，我们发现菜品的图片无法正常展示。原因是因为，在我们的配置文件中，图片信息依然是从 D:&#x2F;img 中加载的，但是在Linux服务器中，是不存在D盘的。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011740500.png" alt="image-20210902005957772"> </p><p><strong>1). 修改文件存储目录</strong></p><p>将文件存储目录修改为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reggie:</span><br><span class="line">  path: /usr/local/img/</span><br></pre></td></tr></table></figure><p> 修改完成之后，需要将变动的代码提交到本地仓库，并推送至远程仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011738636.png" alt="image-20210902010223733"> </p><p><strong>2). 执行shell脚本,进行自动化部署</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011738845.png" alt="image-20210902010440908"> </p><p><strong>3). 将本地的测试图片文件夹img(整个文件夹)上传到服务器B的&#x2F;usr&#x2F;local目录下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011738197.png" alt="image-20210902010704691"> </p><p><strong>4).访问测试</strong></p><p><a href="http://192.168.138.101/">http://192.168.138.101/</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day03/202307011738579.png" alt="image-20210902010952388"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖项目优化-Day02</title>
      <link href="/archives/11.html"/>
      <url>/archives/11.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖项目优化-Day02"><a href="#瑞吉外卖项目优化-Day02" class="headerlink" title="瑞吉外卖项目优化-Day02"></a>瑞吉外卖项目优化-Day02</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>MySQL主从复制</li><li>读写分离案例</li><li>项目实现读写分离</li><li>Nginx-概述</li><li>Nginx-命令</li><li>Nginx-应用</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>1). 存在的问题</p></blockquote><p>在前面基础功能实现的过程中，我们后台管理系统及移动端的用户，在进行数据访问时，都是直接操作数据库MySQL的。结构如下图： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290901697.png" alt="image-20210825100741985" style="zoom:80%;" /> <p>而在当前，MySQL服务器只有一台，那么就可能会存在如下问题： </p><p>1). 读和写所有压力都由一台数据库承担，压力大</p><p>2). 数据库服务器磁盘损坏则数据丢失，单点故障</p><blockquote><p>2). 解决方案</p></blockquote><p>为了解决上述提到的两个问题，我们可以准备两台MySQL，一台主(Master)服务器，一台从(Slave)服务器，主库的数据变更，需要同步到从库中(主从复制)。而用户在访问我们项目时，如果是写操作(insert、update、delete)，则直接操作主库；如果是读(select)操作，则直接操作从库(在这种读写分离的结构中，从库是可以有多个的)，这种结构我们称为 读写分离 。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290901978.png" alt="image-20210825101438683" style="zoom:80%;" /> <p>今天我们就需要实现上述的架构，来解决业务开发中所存在的问题。</p><h2 id="1-MySQL主从复制"><a href="#1-MySQL主从复制" class="headerlink" title="1. MySQL主从复制"></a>1. MySQL主从复制</h2><p>MySQL数据库默认是支持主从复制的，不需要借助于其他的技术，我们只需要在数据库中简单的配置即可。接下来，我们就从以下的几个方面，来介绍一下主从复制：</p><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的 <strong>二进制日志</strong> 功能。就是一台或多台MySQL数据库（slave，即<strong>从库</strong>）从另一台MySQL数据库（master，即<strong>主库</strong>）进行日志的复制，然后再解析日志并应用到自身，最终实现 <strong>从库</strong> 的数据和 <strong>主库</strong> 的数据保持一致。MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具。</p><blockquote><p><strong>二进制日志：</strong> </p><p>​二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。默认MySQL是未开启该日志的。</p></blockquote><p><strong>MySQL的主从复制原理如下：</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902941.png" alt="image-20210825110417975"> </p><p><strong>MySQL复制过程分成三步：</strong></p><p>1). MySQL master 将数据变更写入二进制日志( binary log)</p><p>2). slave将master的binary log拷贝到它的中继日志（relay log）</p><p>3). slave重做中继日志中的事件，将数据变更反映它自己的数据</p><h3 id="1-2-搭建"><a href="#1-2-搭建" class="headerlink" title="1.2 搭建"></a>1.2 搭建</h3><h4 id="1-2-1-准备工作"><a href="#1-2-1-准备工作" class="headerlink" title="1.2.1 准备工作"></a>1.2.1 准备工作</h4><p>提前准备两台服务器，并且在服务器中安装MySQL，服务器的信息如下：</p><table><thead><tr><th>数据库</th><th>IP</th><th>数据库版本</th></tr></thead><tbody><tr><td>Master</td><td>192.168.200.200</td><td>5.7.25</td></tr><tr><td>Slave</td><td>192.168.200.201</td><td>5.7.25</td></tr></tbody></table><p>怎么去准备二台服务器  可以查看<a href="https://blog.csdn.net/m0_59281987/article/details/129036296">https://blog.csdn.net/m0_59281987/article/details/129036296</a></p><p><strong>并在两台服务器上做如下准备工作:</strong> </p><p>1). 防火墙开放3306端口号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902370.png" alt="image-20210825124800430"> </p><p>2). 并将两台数据库服务器启动起来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659525.png" alt="image-20230629111958900"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011658334.png" alt="image-20230629112024498"></p><p>登录MySQL，验证是否正常启动</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902497.png" alt="image-20210825111414157"> </p><h4 id="1-2-2-主库配置"><a href="#1-2-2-主库配置" class="headerlink" title="1.2.2 主库配置"></a>1.2.2 主库配置</h4><blockquote><p>服务器： 192.168.200.200</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306291518696.png" alt="image-20230629151801342"></p><p><strong>1). 修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong></p><p>在最下面增加配置: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-bin=mysql-bin   #[必须]启用二进制日志</span><br><span class="line">server-id=200       #[必须]服务器唯一ID(唯一即可)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902847.png" alt="image-20210825115719668"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-bin=mysql-bin   #[必须]启用二进制日志</span><br><span class="line">server-id=100       #[必须]服务器唯一ID(唯一即可)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659801.png" alt="image-20230629154353559"></p><p>esc   :wq</p><p><strong>2). 重启Mysql服务</strong></p><p>执行指令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902633.png" alt="image-20210825115853116"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659727.png" alt="image-20230629152256576"></p><p><strong>3). 创建数据同步的用户并授权</strong></p><p>登录mysql，并执行如下指令，创建用户并授权：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;xiaoming&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注：上面SQL的作用是创建一个用户 xiaoming ，密码为 Root@123456 ，并且给xiaoming用户授予REPLICATION SLAVE权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。&#x3D;&#x3D;</p><blockquote><p>MySQL密码复杂程度说明: </p><p>​<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902799.png" alt="image-20210825144818269"> </p><p>​目前mysql5.7默认密码校验策略等级为 MEDIUM , 该等级要求密码组成为: 数字、小写字母、大写字母 、特殊字符、长度至少8位</p></blockquote><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659162.png" alt="image-20230629153411457"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659447.png" alt="image-20230629153529407"></p><p><strong>4). 登录Mysql数据库，查看master同步状态</strong></p><p>执行下面SQL，记录下结果中<strong>File</strong>和<strong>Position</strong>的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902721.png" alt="image-20210825120355600"> </p><p>&#x3D;&#x3D;注：上面SQL的作用是查看Master的状态，执行完此SQL后不要再执行任何操作&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659728.png" alt="image-20230629154628364"></p><h4 id="1-2-3-从库配置"><a href="#1-2-3-从库配置" class="headerlink" title="1.2.3 从库配置"></a>1.2.3 从库配置</h4><blockquote><p>服务器： 192.168.200.201</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659341.png" alt="image-20230629154115916"></p><p><strong>1). 修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server-id=201 #[必须]服务器唯一ID</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02202306290830325.png" alt="image-20210825125156597"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server-id=101 #[必须]服务器唯一ID</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659389.png" alt="image-20230629154757804"></p><p><strong>2). 重启Mysql服务</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659456.png" alt="image-20230629154914837"></p><p><strong>3). 登录Mysql数据库，设置主库地址及同步位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.200.200&#x27;,master_user=&#x27;xiaoming&#x27;,master_password=&#x27;Root@123456&#x27;,master_log_file=&#x27;mysql-bin.000001&#x27;,master_log_pos=154;</span><br><span class="line"></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><blockquote><p>参数说明： </p><p>​A. master_host : 主库的IP地址</p><p>​B. master_user : 访问主库进行主从复制的用户名(上面在主库创建的)</p><p>​C. master_password : 访问主库进行主从复制的用户名对应的密码</p><p>​D. master_log_file : 从哪个日志文件开始同步(上述查询master状态中展示的有)</p><p>​E. master_log_pos : 从指定日志文件的哪个位置开始同步(上述查询master状态中展示的有)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.145.100&#x27;,master_user=&#x27;xiaoming&#x27;,master_password=&#x27;Root@123456&#x27;,master_log_file=&#x27;mysql-bin.000003&#x27;,master_log_pos=441;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659313.png" alt="image-20230629160131097"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659912.png" alt="image-20230629160433303"></p><p>注意：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659571.png" alt="image-20230629160339940"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011659783.png" alt="image-20230629160634437"></p><p><strong>4). 查看从数据库的状态</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure><p>然后通过状态信息中的 Slave_IO_running 和 Slave_SQL_running 可以看出主从同步是否就绪，如果这两个参数全为Yes，表示主从同步已经配置完成。</p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902889.png" alt="image-20210825142313382"></p><blockquote><p>MySQL命令行技巧： </p><p>​\G : 在MySQL的sql语句后加上\G，表示将查询结果进行按列打印，可以使每个字段打印到单独的行。即将查到的结构旋转90度变成纵向；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011700078.png" alt="image-20230629160851352"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------+-----------------+-------------+-------------+---------------+------------------+---------------------+----------------------------+---------------+-----------------------+------------------+-------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------+-----------------------------+------------------+-------------+----------------------------+-----------+---------------------+--------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+</span><br><span class="line">| Slave_IO_State | Master_Host     | Master_User | Master_Port | Connect_Retry | Master_Log_File  | Read_Master_Log_Pos | Relay_Log_File             | Relay_Log_Pos | Relay_Master_Log_File | Slave_IO_Running | Slave_SQL_Running | Replicate_Do_DB | Replicate_Ignore_DB | Replicate_Do_Table | Replicate_Ignore_Table | Replicate_Wild_Do_Table | Replicate_Wild_Ignore_Table | Last_Errno | Last_Error | Skip_Counter | Exec_Master_Log_Pos | Relay_Log_Space | Until_Condition | Until_Log_File | Until_Log_Pos | Master_SSL_Allowed | Master_SSL_CA_File | Master_SSL_CA_Path | Master_SSL_Cert | Master_SSL_Cipher | Master_SSL_Key | Seconds_Behind_Master | Master_SSL_Verify_Server_Cert | Last_IO_Errno | Last_IO_Error                                                                                                                                          | Last_SQL_Errno | Last_SQL_Error | Replicate_Ignore_Server_Ids | Master_Server_Id | Master_UUID | Master_Info_File           | SQL_Delay | SQL_Remaining_Delay | Slave_SQL_Running_State                                | Master_Retry_Count | Master_Bind | Last_IO_Error_Timestamp | Last_SQL_Error_Timestamp | Master_SSL_Crl | Master_SSL_Crlpath | Retrieved_Gtid_Set | Executed_Gtid_Set | Auto_Position | Replicate_Rewrite_DB | Channel_Name | Master_TLS_Version |</span><br><span class="line">+----------------+-----------------+-------------+-------------+---------------+------------------+---------------------+----------------------------+---------------+-----------------------+------------------+-------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------+-----------------------------+------------------+-------------+----------------------------+-----------+---------------------+--------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+</span><br><span class="line">|                | 192.168.145.100 | xiaoming    |        3306 |            60 | mysql-bin.000002 |                 441 | localhost-relay-bin.000001 |             4 | mysql-bin.000002      | No               | Yes               |                 |                     |                    |                        |                         |                             |          0 |            |            0 |                 441 |             154 | None            |                |             0 | No                 |                    |                    |                 |                   |                |                  NULL | No                            |          1593 | Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work. |              0 |                |                             |              100 |             | /var/lib/mysql/master.info |         0 |                NULL | Slave has read all relay log; waiting for more updates |              86400 |             | 230629 16:06:11         |                          |                |                    |                    |                   |             0 |                      |              |                    |</span><br><span class="line">+----------------+-----------------+-------------+-------------+---------------+------------------+---------------------+----------------------------+---------------+-----------------------+------------------+-------------------+-----------------+---------------------+--------------------+------------------------+-------------------------+-----------------------------+------------+------------+--------------+---------------------+-----------------+-----------------+----------------+---------------+--------------------+--------------------+--------------------+-----------------+-------------------+----------------+-----------------------+-------------------------------+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------+-----------------------------+------------------+-------------+----------------------------+-----------+---------------------+--------------------------------------------------------+--------------------+-------------+-------------------------+--------------------------+----------------+--------------------+--------------------+-------------------+---------------+----------------------+--------------+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011700264.png" alt="image-20230629161126583"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011700431.png" alt="image-20230629161047963"></p><p>通过上面配置我们发现了一个问题 就是没有双YES</p><p>原因是虚机机克隆出来的</p><p>解决办法</p><p>原因：两台主从数据库的uuid相同了（没猜错的话，各位应该是直接克隆了<a href="https://so.csdn.net/so/search?q=linux%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">linux服务器</a>，然后配置主从数据库，一通操作，到最后启动从数据库，发现的这个问题吧）。</p><p>解决办法：</p><p>1：使用 find &#x2F; -iname “auto.cnf” 命令查找你数据库的auto.cnf 配置文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -iname &quot;auto.cnf&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011700692.png" alt="image-20230629164226355"></p><p>我的在这个目录下，同学们的也可能在其他目录，取决于你mysql放的位置哈。</p><p>2：对这个配置文件的uuid进行更改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /var/lib/mysql/auto.cnf    （文件路径不一样记得改）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011701390.png" alt="image-20230629164401309"></p><p>我是把最后的204修改成205  跟主数据库不一样就行。</p><p> 3：重新启动mysql</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>4： 登录mysql]，重启slave，再次验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot   登录mysql</span><br><span class="line"></span><br><span class="line">stop slave;    停止链路</span><br><span class="line"></span><br><span class="line">start slave;    启动链路</span><br><span class="line"></span><br><span class="line">show slave status \G;   查看链路  </span><br></pre></td></tr></table></figure><p>成功解决</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011701604.png" alt="image-20230629164659808"></p><p>解决问题参考文章：<a href="https://blog.csdn.net/qq_54217349/article/details/126501053">https://blog.csdn.net/qq_54217349/article/details/126501053</a></p><h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><p>主从复制的环境,已经搭建好了,接下来,我们可以通过Navicat连接上两台MySQL服务器,进行测试。测试时，我们只需要在主库Master执行操作，查看从库Slave中是否将数据同步过去即可。</p><p>1). 在master中创建数据库itcast, 刷新slave查看是否可以同步过去</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902000.png" alt="image-20210825143518383"> </p><p>2). 在master的itcast数据下创建user表, 刷新slave查看是否可以同步过去</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902396.png" alt="image-20210825143549689"> </p><p>3). 在master的user表中插入一条数据, 刷新slave查看是否可以同步过去</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902291.png" alt="image-20210825143658516"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011701379.png" alt="image-20230629165649020"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011713933.png" alt="image-20230629165745378"></p><p>在主库  里面创建数据库 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011701459.png" alt="image-20230629170055068"></p><p>刷新  在从库里面也有主库创建的数据库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011701052.png" alt="image-20230629170152209"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011714965.png" alt="image-20230629170529207"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011702932.png" alt="image-20230629170559524"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011702336.png" alt="image-20230629170653738"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011702100.png" alt="image-20230629170823717"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011702980.png" alt="image-20230629170903780"></p><h2 id="2-读写分离案例"><a href="#2-读写分离案例" class="headerlink" title="2. 读写分离案例"></a>2. 读写分离案例</h2><h3 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1 背景介绍"></a>2.1 背景介绍</h3><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为<strong>主库</strong>和<strong>从库</strong>，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902734.png" alt="image-20210825145647274"> </p><p>通过读写分离,就可以降低单台数据库的访问压力, 提高访问效率，也可以避免单机故障。</p><p>主从复制的结构，我们在第一节已经完成了，那么我们在项目中，如何通过java代码来完成读写分离呢，如何在执行select的时候查询从库，而在执行insert、update、delete的时候，操作主库呢？这个时候，我们就需要介绍一个新的技术 ShardingJDBC。</p><h3 id="2-2-ShardingJDBC介绍"><a href="#2-2-ShardingJDBC介绍" class="headerlink" title="2.2 ShardingJDBC介绍"></a>2.2 ShardingJDBC介绍</h3><p>Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><p>使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。</p><p>Sharding-JDBC具有以下几个特点： </p><p>1). 适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</p><p>2). 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</p><p>3). 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</p><p>依赖: </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-数据库环境"><a href="#2-3-数据库环境" class="headerlink" title="2.3 数据库环境"></a>2.3 数据库环境</h3><p>在主库中创建一个数据库rw, 并且创建一张表， 该数据库及表结构创建完毕后会自动同步至从数据库，SQL语句如下： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database rw <span class="keyword">default</span> charset utf8mb4;</span><br><span class="line"></span><br><span class="line">use rw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011702236.png" alt="image-20230629212520491"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011702837.png" alt="image-20230629213021036"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902846.png" alt="image-20210825160658477"> </p><h3 id="2-4-初始工程导入"><a href="#2-4-初始工程导入" class="headerlink" title="2.4 初始工程导入"></a>2.4 初始工程导入</h3><p>我们本案例主要是演示一下读写分离操作，对于基本的增删改查的业务操作，我们就不再去编写了，我们可以直接导入资料中提供的demo工程（rw_demo），在demo工程中，我们已经完成了user的增删改查操作，具体的工程结构如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902527.png" alt="image-20210825161155163"> </p><h3 id="2-5-读写分离配置"><a href="#2-5-读写分离配置" class="headerlink" title="2.5 读写分离配置"></a>2.5 读写分离配置</h3><p>1). 在pom.xml中增加shardingJdbc的maven坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011702965.png" alt="image-20230629210903683"></p><p>2). 在application.yml中增加数据源的配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span></span><br><span class="line">        <span class="string">master,slave</span></span><br><span class="line">      <span class="comment"># 主数据源</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.200.200:3306/rw?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment"># 从数据源</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.200.201:3306/rw?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="comment"># 读写分离配置</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment">#轮询</span></span><br><span class="line">      <span class="comment"># 最终的数据源名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">      <span class="comment"># 主库数据源名称</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 从库数据源名称列表，多个逗号分隔</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure><p>配置解析: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902409.png" alt="image-20210825162910711"> </p><p>3). 在application.yml中增加配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>该配置项的目的,就是如果当前项目中存在同名的bean,后定义的bean会覆盖先定义的。</p><p>&#x3D;&#x3D;如果不配置该项，项目启动之后将会报错：&#x3D;&#x3D; </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290902304.png" alt="image-20210825163737687"> </p><p>报错信息表明，在声明 org.apache.shardingsphere.shardingjdbc.spring.boot 包下的SpringBootConfiguration中的dataSource这个bean时出错, 原因是有一个同名的 dataSource 的bean在com.alibaba.druid.spring.boot.autoconfigure包下的DruidDataSourceAutoConfigure类加载时已经声明了。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903682.png" alt="image-20210825164147056"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290910299.png" alt="image-20210825164227927"> </p><p>而我们需要用到的是 shardingjdbc包下的dataSource，所以我们需要配置上述属性，让后加载的覆盖先加载的。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011703790.png" alt="image-20230630180915705"></p><h3 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6 测试"></a>2.6 测试</h3><p>我们使用shardingjdbc来实现读写分离，直接通过上述简单的配置就可以了。配置完毕之后，我们就可以重启服务，通过postman来访问controller的方法，来完成用户信息的增删改查，我们可以通过debug及日志的方式来查看每一次执行增删改查操作，使用的是哪个数据源，连接的是哪个数据库。</p><p><strong>1). 保存数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903601.png" alt="image-20210825170601641"> </p><p>控制台输出日志，可以看到操作master主库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290910937.png" alt="image-20210825172748209">  </p><p><strong>2). 修改数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903185.png" alt="image-20210825171507059"> </p><p>控制台输出日志，可以看到操作master主库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290910179.png" alt="image-20210825172534790">  </p><p><strong>3). 查询数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903505.png" alt="image-20210825171609997"> </p><p>控制台输出日志，可以看到操作slave主库： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290910298.png" alt="image-20210825171623011"> </p><p><strong>4). 删除数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903426.png" alt="image-20210825172329600"> </p><p>控制台输出日志，可以看到操作master主库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290910537.png" alt="image-20210825172353414"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011703125.png" alt="image-20230630181431093"></p><h2 id="3-项目实现读写分离"><a href="#3-项目实现读写分离" class="headerlink" title="3. 项目实现读写分离"></a>3. 项目实现读写分离</h2><h3 id="3-1-数据库环境准备"><a href="#3-1-数据库环境准备" class="headerlink" title="3.1 数据库环境准备"></a>3.1 数据库环境准备</h3><p>直接使用我们前面在虚拟机中搭建的主从复制的数据库环境即可。在主库中创建瑞吉外卖项目的业务数据库reggie, 并导入相关表结构和数据(我们可以将自己之前在本地开发时使用的数据库数据导出, 然后导入到服务器中的主库即可)。</p><p><strong>1). 将自己本地的reggie数据库的数据导出SQL文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903442.png" alt="image-20210825175039571"> </p><p>这样做的话，我们之前自己开发时，添加的测试数据都还在的，便于测试。</p><p><strong>2). 在主数据库master中，创建数据库reggie，并导入该SQL文件</strong></p><p>master中创建数据库，会自动同步至slave从库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903226.png" alt="image-20210825175416295"> </p><p>在master的reggie中导入sql文件</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903865.png" alt="image-20210825175747138"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011703286.png" alt="image-20230630182445561"></p><h3 id="3-2-创建Git分支"><a href="#3-2-创建Git分支" class="headerlink" title="3.2 创建Git分支"></a>3.2 创建Git分支</h3><p>目前默认git中有两个分支master 和 v1.0 ，我们接下来进行读写分离的优化，就不在master和v1.0分支来操作了，我们需要在git上创建一个单独的分支v1.1，读写分离的优化，我们就在该分支上进行操作。具体创建分支的操作，和前面演示的一致。</p><p>当前创建的v1.1分支，是基于master分支创建出来的，所以目前master分支的代码， 和v1.1分支的代码是完全一样的，接下来把v1.1的代码也推送至远程仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704117.png" alt="image-20230630183246536"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704421.png" alt="image-20230630183404093"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704719.png" alt="image-20230630183500888"></p><h3 id="3-3-读写分离配置"><a href="#3-3-读写分离配置" class="headerlink" title="3.3 读写分离配置"></a>3.3 读写分离配置</h3><p><strong>1). 在项目的pom.xml增加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704917.png" alt="image-20230630183630346"></p><p><strong>2). 在项目的application.yml中配置数据源相关信息</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span></span><br><span class="line">        <span class="string">master,slave</span></span><br><span class="line">      <span class="comment"># 主数据源</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.200.200:3306/reggie?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment"># 从数据源</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.200.201:3306/reggie?characterEncoding=utf-8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="comment"># 读写分离配置</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment">#轮询</span></span><br><span class="line">      <span class="comment"># 最终的数据源名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">      <span class="comment"># 主库数据源名称</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 从库数据源名称列表，多个逗号分隔</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704429.png" alt="image-20230630183826749"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704789.png" alt="image-20230630184713923"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704533.png" alt="image-20230630184901517"></p><h3 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h3><p>配置完毕之后，我们启动项目进行测试，直接访问系统管理后台的页面，然后执行相关业务操作，看控制台输出的日志信息即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704340.png" alt="image-20230630185056568"></p><p>查询操作： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903553.png" alt="image-20210825181207319"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011704228.png" alt="image-20230630185138745"></p><p>更新操作：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903186.png" alt="image-20210825181524065" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011705654.png" alt="image-20230630185219988"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011705660.png" alt="image-20230630185254082"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011705932.png" alt="image-20230630185602971"></p><p>插入操作：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903009.png" alt="image-20210825181915511" style="zoom:80%;" /> <p>删除操作：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903354.png" alt="image-20210825182259837" style="zoom:80%;" /> <h3 id="3-5-Git合并代码"><a href="#3-5-Git合并代码" class="headerlink" title="3.5 Git合并代码"></a>3.5 Git合并代码</h3><p>读写分离的功能我们已经实现完毕了，那么接下来，我们就可以将当前分支v1.1代码提交并推送到远程仓库。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903313.png" alt="image-20210825183830252" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903546.png" alt="image-20210825183900307"> </p><p>然后，再将v1.1的代码，合并到master分支，然后推送至远程仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903466.png" alt="image-20210825184018801"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011705845.png" alt="image-20230630185706807"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011706315.png" alt="image-20230630185841491"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011706812.png" alt="image-20230630185930213"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011706212.png" alt="image-20230630190026776"></p><p>回去主分支进行合并</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011706964.png" alt="image-20230630190059991"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011706796.png" alt="image-20230630190223433"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011706260.png" alt="image-20230630190311441"></p><h2 id="4-Nginx-概述"><a href="#4-Nginx-概述" class="headerlink" title="4. Nginx-概述"></a>4. Nginx-概述</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290903588.png" alt="image-20210829234142590"> </p><p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx的网站有：百度、京东、新浪、网易、腾讯、淘宝等。</p><p>Nginx是由<strong>伊戈尔·赛索耶夫</strong>为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>官网：<a href="https://nginx.org/">https://nginx.org/</a></p><h3 id="4-2-下载和安装"><a href="#4-2-下载和安装" class="headerlink" title="4.2 下载和安装"></a>4.2 下载和安装</h3><h4 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1 下载"></a>4.2.1 下载</h4><p>在Nginx的官网的下载页面中(<a href="http://nginx.org/en/download.html)%EF%BC%8C%E5%B0%B1%E5%B1%95%E7%A4%BA%E4%BA%86%E5%BD%93%E5%89%8DNginx%E7%89%88%E6%9C%AC%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%8B%E8%BD%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E3%80%82">http://nginx.org/en/download.html)，就展示了当前Nginx版本，并提供了下载的连接。</a> 如下： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904265.png" alt="image-20210829234623737" style="zoom:80%;" /> <p>在本项目中，我们所学习的Nginx选择的是稳定版本的1.16这个版本，我们可以直接从官网下载，当然在我们的课程资料中也已经提供了该版本的安装包。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011715733.png" alt="image-20210829235301014"> </p><h4 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2 安装"></a>4.2.2 安装</h4><p><strong>1). 安装依赖包</strong></p><p>由于nginx是基于c语言开发的，所以需要安装c语言的编译环境，及正则表达式库等第三方依赖库。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707125.png" alt="image-20230701103015237"></p><p><strong>2). 下载Nginx安装包</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br><span class="line">wget https://nginx.org/download/nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>wget : </p><p>​wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。</p></blockquote><p>执行完wget指令后，就会在当前所在目录看到下载下来的文件。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707064.png" alt="image-20230701103236975"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707456.png" alt="image-20230701103417103"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707882.png" alt="image-20230701103459117"></p><p><strong>3). 解压nginx压缩包</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707829.png" alt="image-20230701103544801"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707695.png" alt="image-20230701103616243"></p><p><strong>4). 配置Nginx编译环境</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd nginx-1.16.1</span><br><span class="line">mkdir -p /usr/local/nginx</span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure><p>说明: </p><p>​–prefix 指定的目录，就是我们安装Nginx的目录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd nginx-1.16.1</span><br><span class="line">[root@localhost nginx-1.16.1]# mkdir -p /usr/local/nginx</span><br><span class="line">[root@localhost nginx-1.16.1]# ./conf</span><br><span class="line">-bash: ./conf: 是一个目录</span><br><span class="line">[root@localhost nginx-1.16.1]# ./configure --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707637.png" alt="image-20230701104208471"></p><p><strong>5). 编译&amp;安装</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707557.png" alt="image-20230701104333477"></p><h3 id="4-3-目录结构"><a href="#4-3-目录结构" class="headerlink" title="4.3 目录结构"></a>4.3 目录结构</h3><p>安装完Nginx后，我们可以切换到Nginx的安装目录(&#x2F;usr&#x2F;local&#x2F;nginx)，先来熟悉一下Nginx的目录结构，如下图：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904746.png" alt="image-20210830000933352" style="zoom:90%;" /> <blockquote><p>备注： </p><p>​上述我们用到的一个指令 tree，该指令可以将我们指定的目录以树状结构展示出来。如果没有这个指令，可以通过以下指令进行安装。</p><p>​yum install tree</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd nginx-1.16.1</span><br><span class="line">[root@localhost nginx-1.16.1]# cd  /usr/local/nginx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local/nginx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011707888.png" alt="image-20230701105149040"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708240.png" alt="image-20230701105517382"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708893.png" alt="image-20230701105622976"></p><p>重点目录和文件如下: </p><table><thead><tr><th>目录&#x2F;文件</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>conf</td><td>配置文件的存放目录</td><td></td></tr><tr><td>conf&#x2F;nginx.conf</td><td>Nginx的核心配置文件</td><td>conf下有很多nginx的配置文件，我们主要操作这个核心配置文件</td></tr><tr><td>html</td><td>存放静态资源(html, css, )</td><td>部署到Nginx的静态资源都可以放在html目录中</td></tr><tr><td>logs</td><td>存放nginx日志(访问日志、错误日志等)</td><td></td></tr><tr><td>sbin&#x2F;nginx</td><td>二进制文件，用于启动、停止Nginx服务</td><td></td></tr></tbody></table><h2 id="5-Nginx-命令"><a href="#5-Nginx-命令" class="headerlink" title="5. Nginx-命令"></a>5. Nginx-命令</h2><h3 id="5-1-常用命令"><a href="#5-1-常用命令" class="headerlink" title="5.1 常用命令"></a>5.1 常用命令</h3><p>Nginx中，我们的二进制可执行文件(nginx)存放在sbin目录下，虽然只有一个可执行文件，但是我们可以通过该指令配合不同的参数达到更加强大的功能。接下来，我们就演示一下Nginx常见指令, 在执行下面的指令时,都需要在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;目录下执行。</p><p><strong>1). 查看版本</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd sbin</span><br><span class="line">./nginx -v</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904212.png" alt="image-20210830223435585"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708444.png" alt="image-20230701112725743"></p><p><strong>2). 检查配置文件</strong></p><p>修改了nginx.conf核心配置文件之后，在启动Nginx服务之前，可以先检查一下conf&#x2F;nginx.conf文件配置的是否有错误，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290911106.png" alt="image-20210830223511878"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708396.png" alt="image-20230701112931513"></p><p><strong>3). 启动</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>启动之后，我们可以通过ps -ef指令来查看nginx的进程是否存在。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904474.png" alt="image-20210830224019661"> </p><p>注意： nginx服务启动后，默认就会有两个进程。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708621.png" alt="image-20230701113138170"></p><p>启动之后，我们可以直接访问Nginx的80端口， <a href="http://192.168.200.200/">http://192.168.200.200</a></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904716.png" alt="image-20210830224605952" style="zoom:80%;" /> <blockquote><p>注意：</p><p>​要想正常访问Nginx，需要关闭防火墙或开放指定端口号，执行的指令如下： </p><p>​A. 关闭防火墙</p><p>​systemctl stop firewalld</p><p>​B. 开放80端口</p><p>​firewall-cmd –zone&#x3D;public –add-port&#x3D;80&#x2F;tcp –permanent</p><p>​firewall-cmd –reload</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708093.png" alt="image-20230701113349238"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708968.png" alt="image-20230701113513369"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708854.png" alt="image-20230701113553036"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708629.png" alt="image-20230701113713589"></p><p><strong>4). 停止</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure><p>停止之后，我们可以查看nginx的进程： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904410.png" alt="image-20210830224121489"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708539.png" alt="image-20230701113923577"></p><p>查看日志</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708925.png" alt="image-20230701114911921"></p><p>重新启动</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708616.png" alt="image-20230701115041522"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708950.png" alt="image-20230701115505562"></p><p><strong>5). 重新加载</strong></p><p>当修改了Nginx配置文件后，需要重新加载才能生效，可以使用下面命令重新加载配置文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011716661.png" alt="image-20230701115648682"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011708079.png" alt="image-20230701115739788"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011709245.png" alt="image-20230701115825236"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011709685.png" alt="image-20230701120105144"></p><h3 id="5-2-环境变量配置"><a href="#5-2-环境变量配置" class="headerlink" title="5.2 环境变量配置"></a>5.2 环境变量配置</h3><p>在上述我们在使用nginx命令在进行服务的启动、停止、重新加载时，都需要用到一个指令nginx，而这个指令是在nginx&#x2F;sbin目录下的，我们每一次使用这个指令都需要切换到sbin目录才可以，使用相对繁琐。那么我们能不能在任意目录下都可以执行该指令来操作nginx呢？答案是可以的，配置nginx的环境变量即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011709220.png" alt="image-20230701120248495"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011709148.png" alt="image-20230701154128875"></p><p>通过vim编辑器，打开&#x2F;etc&#x2F;profile文件, 在PATH环境变量中增加nginx的sbin目录，如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904673.png" alt="image-20210830225544343"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_171</span><br><span class="line">PATH=/usr/local/nginx/sbin:$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.5.4</span><br><span class="line">export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011711852.png" alt="image-20230701154400910"></p><p>修改完配置文件之后，需要执行 source &#x2F;etc&#x2F;profile 使文件生效。 接下来，我们就可以在任意目录下执行nginx的指令了，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904057.png" alt="image-20210830225702899"> </p><h2 id="6-Nginx-应用"><a href="#6-Nginx-应用" class="headerlink" title="6. Nginx-应用"></a>6. Nginx-应用</h2><p>介绍了并安装了Nginx之后，本章节将要讲解的是Nginx的使用，我们主要从以下四个方面进行讲解。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011711581.png" alt="image-20230701162922800"></p><h3 id="6-1-配置文件结构"><a href="#6-1-配置文件结构" class="headerlink" title="6.1 配置文件结构"></a>6.1 配置文件结构</h3><p>nginx的配置文件(conf&#x2F;nginx.conf)整体上分为三部分: 全局块、events块、http块。这三块的分别配置什么样的信息呢，看下表： </p><table><thead><tr><th>区域</th><th>职责</th></tr></thead><tbody><tr><td>全局块</td><td>配置和nginx运行相关的全局配置</td></tr><tr><td>events块</td><td>配置和网络连接相关的配置</td></tr><tr><td>http块</td><td>配置代理、缓存、日志记录、虚拟主机等配置</td></tr></tbody></table><p>具体结构图如下: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904186.png" alt="image-20210830230827686" style="zoom:80%;" /> <blockquote><p>在全局块、events块以及http块中，我们经常配置的是http块。</p><p>在http块中可以包含多个server块,每个server块可以配置多个location块。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes   2;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-2-部署静态资源"><a href="#6-2-部署静态资源" class="headerlink" title="6.2 部署静态资源"></a>6.2 部署静态资源</h3><h4 id="6-2-1-介绍"><a href="#6-2-1-介绍" class="headerlink" title="6.2.1 介绍"></a>6.2.1 介绍</h4><p>Nginx可以作为静态web服务器来部署静态资源。这里所说的静态资源是指在服务端真实存在，并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</p><p>相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011711396.png" alt="image-20230701163830396"></p><p>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;#监听端口</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">localhost;#服务器名称</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;#匹配客户端请求url</span></span><br><span class="line">        <span class="attr">root</span> <span class="string">html;#指定静态资源根目录</span></span><br><span class="line">        <span class="attr">index</span> <span class="string">index.html;#指定默认首页</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="6-2-2-测试"><a href="#6-2-2-测试" class="headerlink" title="6.2.2 测试"></a>6.2.2 测试</h4><p>在资料中，我们提供了一个静态的html文件，我们需要将这个文件部署到nginx中，然后通过nginx访问html静态资源。</p><p><strong>1). 将静态资源上传到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html 目录</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011711903.png" alt="image-20210830232238402"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202307011711183.png" alt="image-20230701164142676"></p><p><strong>2). 启动nginx</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904283.png" alt="image-20210830232419462"> </p><p><strong>3). 访问</strong></p><p><a href="http://192.168.200.200/hello.html">http://192.168.200.200/hello.html</a></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904316.png" alt="image-20210830232529524" style="zoom:80%;" /> <p><a href="http://192.168.200.200/">http://192.168.200.200</a> ， 访问该地址，访问的是nginx的默认首页</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904554.png" alt="image-20210830232857289" style="zoom:81%;" /> <p><strong>4). 配置首页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904211.png" alt="image-20210830232720821"> </p><p>如果我们需要将hello.html作为nginx的首页，可以修改location的index指令，配置为hello.html，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904386.png" alt="image-20210830233019489"> </p><p>配置完毕后，我们可以通过指令，来检查配置文件是否配置正确： nginx -t</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290904985.png" alt="image-20210830233122708"> </p><p>配置文件修改了，我们需要重新加载一下，才可以生效： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p><strong>5). 访问</strong></p><p><a href="http://192.168.200.200/">http://192.168.200.200</a></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905699.png" alt="image-20210830233336916" style="zoom:80%;" /> <h3 id="6-3-反向代理"><a href="#6-3-反向代理" class="headerlink" title="6.3 反向代理"></a>6.3 反向代理</h3><h4 id="6-3-1-概念介绍"><a href="#6-3-1-概念介绍" class="headerlink" title="6.3.1 概念介绍"></a>6.3.1 概念介绍</h4><p>1). 正向代理</p><p>正向代理服务器是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。</p><p>正向代理一般是<strong>在客户端设置代理服务器</strong>，通过代理服务器转发请求，最终访问到目标服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905913.png" alt="image-20210830233450415"> </p><p>2). 反向代理</p><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。用户不需要知道目标服务器的地址，也无须在用户端作任何设定，对于用户来说，访问反向代理服务器是完全无感知的。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905513.png" alt="image-20210830233634695"> </p><p>那么在本小节，我们就是要使用nginx来作为反向代理服务器使用。 在nginx中，我们可以在nginx.conf中配置反向代理: </p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">82;</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">localhost;</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://192.168.200.201:8080; #反向代理配置，将请求转发到指定服务</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>上述配置的含义为: 当我们访问nginx的82端口时，根据反向代理配置，会将请求转发到 <a href="http://192.168.200.201:8080/">http://192.168.200.201:8080</a> 对应的服务上。</p><h4 id="6-3-2-测试"><a href="#6-3-2-测试" class="headerlink" title="6.3.2 测试"></a>6.3.2 测试</h4><p>需求: 在192.168.200.201这台服务器中部署了java应用，运行端口为8080，并提供了一个可访问的链接 &#x2F;hello。现在我们需要在访问nginx的82端口时，通过nginx将请求转发到192.168.200.201:8080的服务。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905209.png" alt="image-20210830235803013" style="zoom:67%;" /> <p><strong>1). 在192.168.200.201部署服务并启动</strong></p><p>将资料中提供的 helloworld-1.0-SNAPSHOT.jar 上传到服务器端，并通过指令 java -jar helloworld-1.0-SNAPSHOT.jar 运行服务。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905524.png" alt="image-20210831000152199"> </p><p><strong>2). 在192.168.200.200中的nginx.conf中配置反向代理</strong></p><p>进入nginx的安装目录，并编辑配置文件nginx.conf:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf/</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>在http块中,再添加一个server块虚拟主机的配置,监听82端口,并配置反向代理proxy_pass: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 82;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://192.168.200.201:8080; #反向代理配置，将请求转发到指定服务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905796.png" alt="image-20210831000747805" style="zoom:80%;" /> <p><strong>3). 检查配置文件，并重新加载</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905248.png" alt="image-20210831001021252"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p><strong>4). 访问</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905779.png" alt="image-20210831001347257"> </p><p>&#x3D;&#x3D;注意: 在访问82端口时，有可能访问不通，原因是以为防火墙中没有开放端口号。我们可以通过两种方式来解决该问题：&#x3D;&#x3D; </p><p>&#x3D;&#x3D;A. 关闭防火墙&#x3D;&#x3D; </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;B. 开发指定端口&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=82/tcp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="6-4-负载均衡"><a href="#6-4-负载均衡" class="headerlink" title="6.4 负载均衡"></a>6.4 负载均衡</h3><h4 id="6-4-1-概念介绍"><a href="#6-4-1-概念介绍" class="headerlink" title="6.4.1 概念介绍"></a>6.4.1 概念介绍</h4><p>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</p><p><strong>应用集群：</strong>将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</p><p><strong>负载均衡器：</strong>将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905442.png" alt="image-20210831080743617" style="zoom:80%;" />  <p>此处的负载均衡器，我们将会使用Nginx来实现，而Nginx的负载均衡是基于反向代理的，只不过此时所代理的服务器不是一台，而是多台。</p><h4 id="6-4-2-测试"><a href="#6-4-2-测试" class="headerlink" title="6.4.2 测试"></a>6.4.2 测试</h4><p><strong>1). 将资料中提供的两个jar包，上传到192.168.200.201服务器上</strong></p><table><thead><tr><th>jar</th><th>运行端口</th><th>请求链接</th><th>响应数据</th></tr></thead><tbody><tr><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290915027.png" alt="image-20210831081023098"></td><td>8080</td><td>&#x2F;hello</td><td>8080</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290915050.png" alt="image-20210831081038807"></td><td>8081</td><td>&#x2F;hello</td><td>8081</td></tr></tbody></table><blockquote><p>我们在测试时，并没有那么多服务器，我们可以在一台服务器中启动多个服务，运行在不同的端口号上进行测试。</p></blockquote><p><strong>2). 运行上传上来的两个jar包，运行端口分别是 8080 ， 8081</strong></p><p>由于我们执行 java -jar 指令会占用前台窗口，所以我们可以开启两个窗口进行测试。</p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905698.png" alt="image-20210831081513575"></p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905262.png" alt="image-20210831081544582"></p><p><strong>3). 在nginx中配置负载均衡</strong></p><p>打开nginx的配置文件nginx.conf并增加如下配置: </p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#upstream指令可以定义一组服务器</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">targetserver&#123;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.200.201:8080;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.200.201:8081;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span>       <span class="string">8080;</span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">localhost;</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">proxy_pass</span> <span class="string">http://targetserver;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>具体的配置位置如下: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905726.png" alt="image-20210831081939508"> </p><p><strong>4). 重新加载nginx配置文件,访问</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>测试时,我们直接访问nginx的8080端口(<a href="http://192.168.200.200:8080/">http://192.168.200.200:8080</a>), 此时nginx会根据负载均衡策略,将请求转发到后面的两台服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day02/202306290905919.png" alt="image-20210831082339085"> </p><p>在上述的测试过程中，我们看到请求均衡的转发到了8080和8081，因为模式的负载均衡策略是轮询。</p><p><font color="red" size="5">注意: 上述所有涉及到的端口号，都需要在对应的服务器的防火墙中开放，或者彻底关闭防火墙</font></p><h4 id="6-4-3-负载均衡策略"><a href="#6-4-3-负载均衡策略" class="headerlink" title="6.4.3 负载均衡策略"></a>6.4.3 负载均衡策略</h4><p>处理上述默认的轮询策略以外，在Nginx中还提供了其他的负载均衡策略，如下： </p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th>特点</th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td><td></td></tr><tr><td>weight</td><td>权重方式</td><td>根据权重分发请求,权重大的分配到请求的概率大</td></tr><tr><td>ip_hash</td><td>依据ip分配方式</td><td>根据客户端请求的IP地址计算hash值， 根据hash值来分发请求, 同一个IP发起的请求, 会发转发到同一个服务器上</td></tr><tr><td>least_conn</td><td>依据最少连接方式</td><td>哪个服务器当前处理的连接少, 请求优先转发到这台服务器</td></tr><tr><td>url_hash</td><td>依据url分配方式</td><td>根据客户端请求url的hash值，来分发请求, 同一个url请求, 会发转发到同一个服务器上</td></tr><tr><td>fair</td><td>依据响应时间方式</td><td>优先把请求分发给处理请求时间短的服务器</td></tr></tbody></table><p>权重的配置： </p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#upstream指令可以定义一组服务器</span></span><br><span class="line"><span class="attr">upstream</span> <span class="string">targetserver&#123;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.200.201:8080 weight=10;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">192.168.200.201:8081 weight=5;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>上述配置的weight权重是相对的，在上述的配置中，效果就是，在大数据量的请求下，最终8080接收的请求数是8081的两倍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖项目优化-Day01</title>
      <link href="/archives/10.html"/>
      <url>/archives/10.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖项目优化-Day01"><a href="#瑞吉外卖项目优化-Day01" class="headerlink" title="瑞吉外卖项目优化-Day01"></a>瑞吉外卖项目优化-Day01</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>环境搭建</li><li>缓存短信验证码</li><li>缓存菜品信息</li><li>SpringCache</li><li>缓存套餐数据</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>1). 当前系统存在的问题</p></blockquote><p>之前我们已经实现了移动端菜品展示、点餐、购物车、下单等功能，但是由于移动端是面向所有的消费者的，请求压力相对比较大，而我们当前所有的数据查询都是从数据库MySQL中直接查询的，那么可能就存在如下问题： &#x3D;&#x3D;频繁访问数据库，数据库访问压力大，系统性能下降，用户体验较差。&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251952581.png" alt="image-20210819232120838"> </p><blockquote><p>2). 解决该问题的方法</p></blockquote><p>要解决我们上述提到的问题，就可以使用我们前面学习的一个技术：Redis，通过Redis来做缓存，从而降低数据库的访问压力，提高系统的访问性能，从而提升用户体验。加入Redis做缓存之后，我们在进行数据查询时，就需要先查询缓存，如果缓存中有数据，直接返回，如果缓存中没有数据，则需要查询数据库，再将数据库查询的结果，缓存在redis中。</p><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-版本控制"><a href="#1-1-版本控制" class="headerlink" title="1.1 版本控制"></a>1.1 版本控制</h3><p>接下来，我们就需要对我们的功能进行优化，但是需要说明的是，我们不仅仅要对上述提到的缓存进行优化，还需要对我们程序的各个方面进行优化。我们本章节主要是针对于缓存进行优化，为了方便的对我们各个优化版本的代码进行管理，我们使用Git来控制代码版本。 那么此时我们就需要将我们之前开发完成的代码提交到Git，并且推送到码云Gitee的远程仓库，执行步骤如下： </p><p><strong>1). 创建Gitee远程仓库</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251952891.png" alt="image-20210820000329886" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270841326.png" alt="image-20230626090339548"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270841162.png" alt="image-20230626090434868"></p><p><strong>2). idea-创建本地仓库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251952082.png" alt="image-20210820000700459"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270841419.png" alt="image-20230626090613231"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842769.png" alt="image-20230626090653751"></p><p><strong>3). 准备忽略文件.gitignore</strong></p><p>在我们的项目中, 有一些文件是无需提交的到git，比如: .idea，target&#x2F;，*.iml等。我们可以直接将今天课程资料中提供的.gitignore 文件导入到我们的项目中。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251952265.png" alt="image-20210820001119649"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842602.png" alt="image-20230626091233591"></p><p><strong>4). idea-提交并推送本地代码</strong></p><p>A. 添加项目文件进暂存区</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251952152.png" alt="image-20210820001232154"  /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842988.png" alt="image-20230626091403179"></p><p>B. 提交代码</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953512.png" alt="image-20210820001805504"  /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306260847886.png" alt="image-20210820002006653"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282228688.png" alt="image-20230626091557001"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842960.png" alt="image-20230626091808468"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842560.png" alt="image-20230626091931699"></p><p>C. 推送代码到远程仓库 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953600.png" alt="image-20210820002159587"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229597.png" alt="image-20230626092016530"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229250.png" alt="image-20230626092648891"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842081.png" alt="image-20230626093013810"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842025.png" alt="image-20230626093101868"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229898.png" alt="image-20230626093345007"></p><p><strong>5). 查看gitee远程仓库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306252003088.png" alt="image-20210820002723619"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842337.png" alt="image-20230626093434623"></p><p><strong>6). 创建分支</strong></p><p>目前默认git中只有一个主分支master，我们接下来进行缓存的优化，就不在master分支来操作了，我们需要在git上创建一个单独的分支v1.0，缓存的优化，我们就在该分支上进行操作。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953193.png" alt="image-20210820003303544">  </p><p>当前创建的v1.0分支，是基于master分支创建出来的，所以目前master分支的代码， 和v1.0分支的代码是完全一样的，接下来把v1.0的代码也推送至远程仓库。</p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229196.png" alt="image-20230626093845092"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229571.png" alt="image-20230626093914907"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229540.png" alt="image-20230626093959397"></p><p><strong>7). 推送分支代码到远程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953657.png" alt="image-20210820003516900"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306260847118.png" alt="image-20210820003545764"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842921.png" alt="image-20230626094332442"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842479.png" alt="image-20230626094409809"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229932.png" alt="image-20230626094638340"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270842201.png" alt="image-20230626094820288"></p><h3 id="1-2-环境准备"><a href="#1-2-环境准备" class="headerlink" title="1.2 环境准备"></a>1.2 环境准备</h3><p><strong>1). 在项目的pom.xml文件中导入spring data redis的maven坐标</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843336.png" alt="image-20230626095403955"></p><p><strong>2). 在项目的application.yml中加入redis相关配置</strong></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.200</span><span class="number">.200</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root@123456</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意: 引入上述依赖时,需要注意yml文件前面的缩进,上述配置应该配置在spring层级下面。&#x3D;&#x3D;</p><p>我这边用SSH的host</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis:</span><br><span class="line">  host: 192.168.145.100</span><br><span class="line">  port: 6379</span><br><span class="line">  password: root@123456</span><br><span class="line">  database: 0</span><br></pre></td></tr></table></figure><p>启动redis </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/redis-4.0.0</span><br><span class="line">[root@localhost redis-4.0.0]# </span><br><span class="line">[root@localhost redis-4.0.0]# src/redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>这里面我把RedisConfig的Value<em>设置<strong>Value</strong>的序列化</em></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282229003.png" alt="image-20230627093435062"></p><p><strong>3). 编写Redis的配置类RedisConfig,定义RedisTemplate</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843036.png" alt="image-20230626102025544"></p><p>这个配置类如果自己不创建的话  也会自动帮我们创建redis的相关配置</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843757.png" alt="image-20230626102246537"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843035.png" alt="image-20230626102620132"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843789.png" alt="image-20230626102643872"></p><p><strong>解释说明:</strong> </p><p>1). 在SpringBoot工程启动时, 会加载一个自动配置类 RedisAutoConfiguration, 在里面已经声明了RedisTemplate这个bean</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306252003841.png" alt="image-20210821091441695" style="zoom:80%;" /> <p>上述框架默认声明的RedisTemplate用的key和value的序列化方式是默认的 JdkSerializationRedisSerializer，如果key采用这种方式序列化，最终我们在测试时通过redis的图形化界面查询不是很方便，如下形式：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953553.png" alt="image-20210822003112692"> </p><p>2). 如果使用我们自定义的RedisTemplate, key的序列化方式使用的是StringRedisSerializer, 也就是字符串形式, 最终效果如下: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953209.png" alt="image-20210822003408377"> </p><p>3). 定义了两个bean会不会出现冲突呢? 答案是不会, 因为源码如下:</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953576.png" alt="image-20210821092401172" style="zoom:80%;" /> <p>add并提交</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843706.png" alt="image-20230626103003812"></p><p>提交</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843593.png" alt="image-20230626103031626"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843529.png" alt="image-20230626103225639"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843936.png" alt="image-20230626103325231"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282230276.png" alt="image-20230626103407435"></p><p>在v1.0版本就多了一个配置类</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843777.png" alt="image-20230626103602150"></p><p>而在我们的master分支里面就没有配置类   我们现在的开发是基于v1.0版本进行开发  还没有进行合并</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270843161.png" alt="image-20230626103753864"></p><h2 id="2-缓存短信验证码"><a href="#2-缓存短信验证码" class="headerlink" title="2. 缓存短信验证码"></a>2. 缓存短信验证码</h2><h3 id="2-1-思路分析"><a href="#2-1-思路分析" class="headerlink" title="2.1 思路分析"></a>2.1 思路分析</h3><p>前面我们已经实现了移动端手机验证码登录，随机生成的验证码我们是保存在HttpSession中的。但是在我们实际的业务场景中，一般验证码都是需要设置过期时间的，如果存在HttpSession中就无法设置过期时间，此时我们就需要对这一块的功能进行优化。</p><p>现在需要改造为将验证码缓存在Redis中，具体的实现思路如下：</p><p>1). 在服务端UserController中注入RedisTemplate对象，用于操作Redis;</p><p>2). 在服务端UserController的sendMsg方法中，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟;</p><p>3). 在服务端UserController的login方法中，从Redis中获取缓存的验证码，如果登录成功则删除Redis中的验证码;</p><h3 id="2-2-代码改造"><a href="#2-2-代码改造" class="headerlink" title="2.2 代码改造"></a>2.2 代码改造</h3><p>1). 在UserController中注入RedisTemplate对象，用于操作Redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306270903243.png" alt="image-20230627090307174"></p><p>2). 在UserController的sendMsg方法中，将生成的验证码保存到Redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要将生成的验证码保存到Redis,设置过期时间</span></span><br><span class="line">redisTemplate.opsForValue().set(phone, code, <span class="number">5</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953792.png" alt="image-20210821194944557"  /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306280908024.png" alt="image-20230627090453957"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306280908141.png" alt="image-20230627090745809"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306280908945.png" alt="image-20230627091140173"></p><p>3). 在UserController的login方法中，从Redis中获取生成的验证码，如果登录成功则删除Redis中缓存的验证码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从Redis中获取缓存的验证码</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">codeInSession</span> <span class="operator">=</span> redisTemplate.opsForValue().get(phone);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306280908115.png" alt="image-20230627091344560"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从Redis中删除缓存的验证码</span></span><br><span class="line">redisTemplate.delete(phone);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953808.png" alt="image-20210821195329342"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306280908979.png" alt="image-20230627091551008"></p><h3 id="2-3-功能测试"><a href="#2-3-功能测试" class="headerlink" title="2.3 功能测试"></a>2.3 功能测试</h3><p>代码编写完毕之后,重启服务。</p><p><strong>1). 访问前端工程，获取验证码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953073.png" alt="image-20210821200212767"> </p><p>通过控制台的日志，我们可以看到生成的验证码：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306252002144.png" alt="image-20210822002439892">  </p><p><strong>2). 通过Redis的图形化界面工具查看Redis中的数据</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953760.png" alt="image-20210822003550941" style="zoom:97%;" /> <p><strong>3). 在登录界面填写验证码登录完成后,查看Redis中的数据是否删除</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251953968.png" alt="image-20210822003732542"> </p><p>测试</p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282230436.png" alt="image-20230628092821404"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282230146.png" alt="image-20230628092842280"></p><p>连接</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282230691.png" alt="image-20230628092938406"></p><p>发现连接不上 报错</p><p>idea报错如下 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.ConnectTimeoutException: connection timed out: /192.168.145.100:6379</span><br><span class="line">at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:261) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.util.concurrent.PromiseTask.runTask(PromiseTask.java:98) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:170) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) ~[netty-transport-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.63.Final.jar:4.1.63.Final]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_152]</span><br></pre></td></tr></table></figure><p>解决办法  ：</p><p>这个原因是因为防火墙没关的原因</p><p>原因分析:<br>这个问题有很大的可能是Linux的防火墙未关闭，请求无法到达redis客户端。</p><p>如果想要外部访问redis前提是把redis配置文件中的 protected-mode yes,改为 protected-mode no 这样redis才允许外部访问</p><p>1.使用命令查看防火墙是否关闭</p><p>查看Linux防火墙状态命令：systemctl status firewalld.service</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 三 2023-06-28 09:06:17 CST; 55min ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 6343 (firewalld)</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─6343 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line"></span><br><span class="line">6月 28 09:06:16 localhost.localdomain systemd[1]: Starting firewalld - dynamic firewall daemon...</span><br><span class="line">6月 28 09:06:17 localhost.localdomain systemd[1]: Started firewalld - dynamic firewall daemon.</span><br><span class="line">6月 28 09:06:19 localhost.localdomain firewalld[6343]: WARNING: /etc/sysconfig/network-scripts/ifcfg-ens33: Duplicate option definition: &#x27;DNS1=&quot;4.4.4.4&quot;            # DNS服务器&#x27;</span><br></pre></td></tr></table></figure><p>如上出现running(第四行，第三单词)表示防火墙未关闭</p><p>2.使用命令关闭防火强：systemctl stop firewalld.service</p><p>再次查看Linux防火墙状态命令：systemctl status firewalld.service<br>会发现变成这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-4.0.0]# systemctl stop firewalld.service</span><br><span class="line">[root@localhost redis-4.0.0]# systemctl status firewalld.service</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead) since 三 2023-06-28 10:01:42 CST; 10s ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line">  Process: 6343 ExecStart=/usr/sbin/firewalld --nofork --nopid $FIREWALLD_ARGS (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 6343 (code=exited, status=0/SUCCESS)</span><br><span class="line"></span><br><span class="line">6月 28 09:06:16 localhost.localdomain systemd[1]: Starting firewalld - dynamic firewall daemon...</span><br><span class="line">6月 28 09:06:17 localhost.localdomain systemd[1]: Started firewalld - dynamic firewall daemon.</span><br><span class="line">6月 28 09:06:19 localhost.localdomain firewalld[6343]: WARNING: /etc/sysconfig/network-scripts/ifcfg-ens33: Duplicate option definition: &#x27;DNS1=&quot;4.4.4.4&quot;            # DNS服务器&#x27;</span><br><span class="line">6月 28 10:01:41 localhost.localdomain systemd[1]: Stopping firewalld - dynamic firewall daemon...</span><br><span class="line">6月 28 10:01:42 localhost.localdomain systemd[1]: Stopped firewalld - dynamic firewall daemon.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282231007.png" alt="image-20230628101035552"></p><p>重新启动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-4.0.0]# src/redis-server ./redis.conf</span><br><span class="line">64711:C 28 Jun 10:02:59.238 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">64711:C 28 Jun 10:02:59.238 # Redis version=4.0.0, bits=64, commit=00000000, modified=0, pid=64711, just started</span><br><span class="line">64711:C 28 Jun 10:02:59.238 # Configuration loaded</span><br><span class="line">[root@localhost redis-4.0.0]# ps -ef | grep redis </span><br><span class="line">root      11070      1  0 09:13 ?        00:00:06 src/redis-server *:6379</span><br><span class="line">root      64968  60205  0 10:03 pts/0    00:00:00 grep --color=auto redis</span><br><span class="line">[root@localhost redis-4.0.0]#  cd  /usr/local/redis-4.0.0/src</span><br><span class="line">[root@localhost src]#  ./redis-cli</span><br><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282231796.png" alt="image-20230628101152490"></p><p>连接成功</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282231020.png" alt="image-20230628100513196"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282231314.png" alt="image-20230628102034040"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282231990.png" alt="image-20230628102135928"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282231228.png" alt="image-20230628102220647"></p><p>登录成功后 就没有这个按键了</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282231457.png" alt="image-20230628102423815"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232458.png" alt="image-20230628102405997"></p><h2 id="3-缓存菜品信息"><a href="#3-缓存菜品信息" class="headerlink" title="3. 缓存菜品信息"></a>3. 缓存菜品信息</h2><h3 id="3-1-实现思路"><a href="#3-1-实现思路" class="headerlink" title="3.1 实现思路"></a>3.1 实现思路</h3><p>前面我们已经实现了移动端菜品查看功能，对应的服务端方法为DishController的list方法，此方法会根据前端提交的查询条件(categoryId)进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。现在需要对此方法进行缓存优化，提高系统的性能。</p><p>那么,我们又需要思考一个问题, 具体缓存几份数据呢, 所有的菜品缓存一份 , 还是说需要缓存多份呢? 我们可以看一下我们之前做的移动端效果: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251954241.png" alt="image-20210822010136819" style="zoom:80%;" /> <p>我们点击哪一个分类,展示的就是该分类下的菜品, 其他菜品无需展示。所以，这里面我们在缓存时，可以根据菜品的分类，缓存多份数据，页面在查询时，点击的是哪个分类，我们就查询该分类下的菜品缓存数据。</p><p><strong>具体的实现思路如下：</strong></p><p>1). 改造DishController的list方法，先从Redis中获取分类对应的菜品数据，如果有则直接返回，无需查询数据库;如果没有则查询数据库，并将查询到的菜品数据存入Redis。</p><p>2). 改造DishController的save和update方法，加入清理缓存的逻辑。</p><blockquote><p>注意： </p><p>​在使用缓存过程中，要注意保证数据库中的数据和缓存中的数据一致，如果数据库中的数据发生变化，需要及时清理缓存数据。否则就会造成缓存数据与数据库数据不一致的情况。</p></blockquote><h3 id="3-2-代码改造"><a href="#3-2-代码改造" class="headerlink" title="3.2 代码改造"></a>3.2 代码改造</h3><p>需要改造的代码为： DishController</p><h4 id="3-2-1-查询菜品缓存"><a href="#3-2-1-查询菜品缓存" class="headerlink" title="3.2.1 查询菜品缓存"></a>3.2.1 查询菜品缓存</h4><table><thead><tr><th>改造的方法</th><th>redis的数据类型</th><th>redis缓存的key</th><th>redis缓存的value</th></tr></thead><tbody><tr><td>list</td><td>string</td><td>dish_分类Id_状态 , 比如: dish_12323232323_1</td><td>List<DishDto></td></tr></tbody></table><p><strong>1). 在DishController中注入RedisTemplate</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232834.png" alt="image-20230628103240447"></p><p><strong>2). 在list方法中,查询数据库之前,先查询缓存, 缓存中有数据, 直接返回</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;DishDto&gt; dishDtoList = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//动态构造key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dish.getCategoryId() + <span class="string">&quot;_&quot;</span> + dish.getStatus();<span class="comment">//dish_1397844391040167938_1</span></span><br><span class="line"><span class="comment">//先从redis中获取缓存数据</span></span><br><span class="line">dishDtoList = (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="keyword">if</span>(dishDtoList != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//如果存在，直接返回，无需查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> R.success(dishDtoList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251956601.png" alt="image-20210822011323316" style="zoom:90%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232221.png" alt="image-20230628103928546"></p><p>这个对象声明过了  这里直接给他赋值   就可以</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232462.png" alt="image-20230628110223065"></p><p><strong>3). 如果redis不存在，查询数据库，并将数据库查询结果，缓存在redis，并设置过期时间</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果不存在，需要查询数据库，将查询到的菜品数据缓存到Redis</span></span><br><span class="line">redisTemplate.opsForValue().set(key,dishDtoList,<span class="number">60</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251956040.png" alt="image-20210822011714110" style="zoom:90%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232826.png" alt="image-20230628103953366"></p><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232058.png" alt="image-20230628110637998"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232891.png" alt="image-20230628110709327"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232162.png" alt="image-20230628110749334"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232355.png" alt="image-20230628110809401"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282232057.png" alt="image-20230628110827503"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282234771.png" alt="image-20230628110937122"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282234497.png" alt="image-20230628111008261"></p><p>F8</p><p>第一次从redis里面获取  是获取不到的 要去查询数据库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282234786.png" alt="image-20230628111149489"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282234802.png" alt="image-20230628111247273"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282236674.png" alt="image-20230628111300683"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282235915.png" alt="image-20230628112201154"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282235144.png" alt="image-20230628112250725"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282235126.png" alt="image-20230628112325090"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282235033.png" alt="image-20230628112408623"></p><p>在点击这里</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282235010.png" alt="image-20230628151131387"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282236914.png" alt="image-20230628151351687"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282235978.png" alt="image-20230628151413126"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282236022.png" alt="image-20230628151435748"></p><p>这时的控制台就不会在发SQL</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282236139.png" alt="image-20230628151501361"></p><h4 id="3-2-2-清理菜品缓存"><a href="#3-2-2-清理菜品缓存" class="headerlink" title="3.2.2 清理菜品缓存"></a>3.2.2 清理菜品缓存</h4><p>为了保证数据库中的数据和缓存中的数据一致，如果数据库中的数据发生变化，需要及时清理缓存数据。所以，我们需要在添加菜品、更新菜品时清空缓存数据。</p><p>新增菜品</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282237522.png" alt="image-20230628152153743"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282237417.png" alt="image-20230628152305861"></p><p>正常情况下 如果我们点击菜品时 应该会有数据   可是我们现在并没有展示出来</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282237257.png" alt="image-20230628152425519"></p><p><strong>1). 保存菜品,清空缓存</strong></p><p>在保存菜品的方法save中，当菜品数据保存完毕之后，需要清空菜品的缓存。那么这里清理菜品缓存的方式存在两种：</p><p>A. 清理所有分类下的菜品缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清理所有菜品的缓存数据</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;dish_*&quot;</span>); <span class="comment">//获取所有以dish_xxx开头的key</span></span><br><span class="line">redisTemplate.delete(keys); <span class="comment">//删除这些key</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282237136.png" alt="image-20230628152854250"></p><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282237433.png" alt="image-20230628153132087"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282238858.png" alt="image-20230628153213559"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282238658.png" alt="image-20230628153245866"></p><p>和dish_有关的全删除了</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282238395.png" alt="image-20230628153307376"></p><p>B. 清理当前添加菜品分类下的缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清理某个分类下面的菜品缓存数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dishDto.getCategoryId() + <span class="string">&quot;_1&quot;</span>;</span><br><span class="line">redisTemplate.delete(key);</span><br></pre></td></tr></table></figure><p>此处, 我们推荐使用第二种清理的方式, 只清理当前菜品关联的分类下的菜品数据。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251956289.png" alt="image-20210822013114996" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282238092.png" alt="image-20230628153632640"></p><p><strong>2). 更新菜品,清空缓存</strong></p><p>在更新菜品的方法update中，当菜品数据更新完毕之后，需要清空菜品的缓存。这里清理缓存的方式和上述基本一致。</p><p>A. 清理所有分类下的菜品缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清理所有菜品的缓存数据</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;dish_*&quot;</span>); <span class="comment">//获取所有以dish_xxx开头的key</span></span><br><span class="line">redisTemplate.delete(keys); <span class="comment">//删除这些key</span></span><br></pre></td></tr></table></figure><p>B. 清理当前添加菜品分类下的缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清理某个分类下面的菜品缓存数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dishDto.getCategoryId() + <span class="string">&quot;_1&quot;</span>;</span><br><span class="line">redisTemplate.delete(key);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251956920.png" alt="image-20210822013609299"> </p><p>&#x3D;&#x3D;注意: 在这里我们推荐使用第一种方式进行清理，这样逻辑更加严谨。 因为对于修改操作，用户是可以修改菜品的分类的，如果用户修改了菜品的分类，那么原来分类下将少一个菜品，新的分类下将多一个菜品，这样的话，两个分类下的菜品列表数据都发生了变化。&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282239220.png" alt="image-20230628154156676"></p><h3 id="3-3-功能测试"><a href="#3-3-功能测试" class="headerlink" title="3.3 功能测试"></a>3.3 功能测试</h3><p>代码编写完毕之后,重新启动服务。</p><p>1). 访问移动端，根据分类查询菜品列表，然后再检查Redis的缓存数据，是否可以正常缓存；</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251956384.png" alt="image-20210822221038509"> </p><p>我们也可以在服务端，通过debug断点的形式一步一步的跟踪代码的执行。</p><p>2). 当我们在进行新增及修改菜品时, 查询Redis中的缓存数据, 是否被清除;</p><h3 id="3-4-提交并推送代码"><a href="#3-4-提交并推送代码" class="headerlink" title="3.4 提交并推送代码"></a>3.4 提交并推送代码</h3><p><strong>1). 提交并推送代码</strong></p><p>在v1.0分支中, 将我们已经实现并且测试通过的使用redis缓存验证码和菜品信息的代码,提交并推送至Gitee</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251956416.png" alt="image-20210822222206452" style="zoom:80%;" /> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306252002472.png" alt="image-20210822222244727" style="zoom:80%;" /> <p><strong>2). 合并代码到master分支</strong></p><p>A. 将代码切换到master分支</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957737.png" alt="image-20210822222756572" style="zoom:80%;" /> <p>B. 将v1.0分支的代码合并到当前master分支</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957888.png" alt="image-20210822223314087" style="zoom:80%;" /> <p>C. 将master分支合并后代码推送到Gitee</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957392.png" alt="image-20210822223837020" style="zoom:80%;" /> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306252003225.png" alt="image-20210822223912803" style="zoom:80%;" /> <p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282239234.png" alt="image-20230628154616701"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282239995.png" alt="image-20230628154658118"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282239698.png" alt="image-20230628154735706"></p><p>合并分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282239441.png" alt="image-20230628155006277"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282239988.png" alt="image-20230628155257068"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282239849.png" alt="image-20230628155403153"></p><h2 id="4-SpringCache"><a href="#4-SpringCache" class="headerlink" title="4. SpringCache"></a>4. SpringCache</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p><strong>Spring Cache</strong>是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能，大大简化我们在业务中操作缓存的代码。</p><p>Spring Cache只是提供了一层抽象，底层可以切换不同的cache实现。具体就是通过<strong>CacheManager</strong>接口来统一不同的缓存技术。CacheManager是Spring提供的各种缓存技术抽象接口。</p><p>针对不同的缓存技术需要实现不同的CacheManager：</p><table><thead><tr><th><strong>CacheManager</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>EhCacheCacheManager</td><td>使用EhCache作为缓存技术</td></tr><tr><td>GuavaCacheManager</td><td>使用Google的GuavaCache作为缓存技术</td></tr><tr><td>RedisCacheManager</td><td>使用Redis作为缓存技术</td></tr></tbody></table><h3 id="4-2-注解"><a href="#4-2-注解" class="headerlink" title="4.2 注解"></a>4.2 注解</h3><p>在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@EnableCaching</td><td>开启缓存注解功能</td></tr><tr><td>@Cacheable</td><td>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td>@CachePut</td><td>将方法的返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p><p>例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</p><h3 id="4-3-入门程序"><a href="#4-3-入门程序" class="headerlink" title="4.3 入门程序"></a>4.3 入门程序</h3><p>接下来，我们将通过一个入门案例来演示一下SpringCache的常见用法。 上面我们提到，SpringCache可以集成不同的缓存技术，如Redis、Ehcache甚至我们可以使用Map来缓存数据， 接下来我们在演示的时候，就先通过一个Map来缓存数据，最后我们再换成Redis来缓存。</p><h4 id="4-3-1-环境准备"><a href="#4-3-1-环境准备" class="headerlink" title="4.3.1 环境准备"></a>4.3.1 环境准备</h4><p><strong>1). 数据库准备</strong></p><p>将今天资料中的SQL脚本直接导入数据库中。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957481.png" alt="image-20210822230236957"> </p><p><strong>2). 导入基础工程</strong></p><p>基础环境的代码，在我们今天的资料中已经准备好了， 大家只需要将这个工程导入进来就可以了。导入进来的工程结构如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957057.png" alt="image-20210822225934512"> </p><p>由于SpringCache的基本功能是Spring核心(spring-context)中提供的，所以目前我们进行简单的SpringCache测试，是可以不用额外引入其他依赖的。</p><p><strong>3). 注入CacheManager</strong></p><p>我们可以在UserController注入一个CacheManager，在Debug时，我们可以通过CacheManager跟踪缓存中数据的变化。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957673.png" alt="image-20210822231333527" style="zoom:80%;" /> <p>我们可以看到CacheManager是一个接口，默认的实现有以下几种 ；</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957576.png" alt="image-20210822231217450"> </p><p>而在上述的这几个实现中，默认使用的是 ConcurrentMapCacheManager。稍后我们可以通过断点的形式跟踪缓存数据的变化。</p><p><strong>4). 引导类上加@EnableCaching</strong></p><p>在引导类上加该注解，就代表当前项目开启缓存注解功能。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957984.png" alt="image-20210822231616569"> </p><h4 id="4-3-2-CachePut注解"><a href="#4-3-2-CachePut注解" class="headerlink" title="4.3.2 @CachePut注解"></a>4.3.2 @CachePut注解</h4><blockquote><p>@CachePut 说明： </p><p>​作用: 将方法返回值，放入缓存</p><p>​value: 缓存的名称, 每个缓存名称下面可以有很多key</p><p>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p></blockquote><p><strong>1). 在save方法上加注解@CachePut</strong></p><p>当前UserController的save方法是用来保存用户信息的，我们希望在该用户信息保存到数据库的同时，也往缓存中缓存一份数据，我们可以在save方法上加上注解 @CachePut，用法如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* CachePut：将方法返回值放入缓存</span></span><br><span class="line"><span class="comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span></span><br><span class="line"><span class="comment">* key：缓存的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@CachePut(value = &quot;userCache&quot;, key = &quot;#user.id&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    userService.save(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>key的写法如下： </p><p>​#user.id : #user指的是方法形参的名称, id指的是user的id属性 , 也就是使用user的id属性作为key ;</p><p>​#user.name: #user指的是方法形参的名称, name指的是user的name属性 ,也就是使用user的name属性作为key ;</p><p>​</p><p>​#result.id : #result代表方法返回值，该表达式 代表以返回对象的id属性作为key ；</p><p>​#result.name : #result代表方法返回值，该表达式 代表以返回对象的name属性作为key ；</p></blockquote><p><strong>2). 测试</strong></p><p>启动服务,通过postman请求访问UserController的方法, 然后通过断点的形式跟踪缓存数据。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957922.png" alt="image-20210822233438182"></p><p>第一次访问时，缓存中的数据是空的，因为save方法执行完毕后才会缓存数据。 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957032.png" alt="image-20210822233724439"> </p><p>第二次访问时，我们通过debug可以看到已经有一条数据了，就是上次保存的数据，已经缓存了，缓存的key就是用户的id。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957328.png" alt="image-20210822234105085"> </p><p>&#x3D;&#x3D;注意: 上述的演示，最终的数据，实际上是缓存在ConcurrentHashMap中，那么当我们的服务器重启之后，缓存中的数据就会丢失。 我们后面使用了Redis来缓存就不存在这样的问题了。&#x3D;&#x3D;</p><h4 id="4-3-3-CacheEvict注解"><a href="#4-3-3-CacheEvict注解" class="headerlink" title="4.3.3 @CacheEvict注解"></a>4.3.3 @CacheEvict注解</h4><blockquote><p>@CacheEvict 说明： </p><p>​作用: 清理指定缓存</p><p>​value: 缓存的名称，每个缓存名称下面可以有多个key</p><p>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p></blockquote><p><strong>1). 在 delete 方法上加注解@CacheEvict</strong></p><p>当我们在删除数据库user表的数据的时候,我们需要删除缓存中对应的数据,此时就可以使用@CacheEvict注解, 具体的使用方式如下: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* CacheEvict：清理指定缓存</span></span><br><span class="line"><span class="comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span></span><br><span class="line"><span class="comment">* key：缓存的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;userCache&quot;,key = &quot;#p0&quot;)</span>  <span class="comment">//#p0 代表第一个参数</span></span><br><span class="line"><span class="comment">//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;) //#root.args[0] 代表第一个参数</span></span><br><span class="line"><span class="comment">//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#id&quot;) //#id 代表变量名为id的参数</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    userService.removeById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). 测试</strong></p><p>要测试缓存的删除，我们先访问save方法4次，保存4条数据到数据库的同时，也保存到缓存中，最终我们可以通过debug看到缓存中的数据信息。 然后我们在通过postman访问delete方法， 如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957688.png" alt="image-20210823000431356"> </p><p>删除数据时，通过debug我们可以看到已经缓存的4条数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251957040.png" alt="image-20210823000458089"> </p><p>当执行完delete操作之后，我们再次保存一条数据，在保存的时候debug查看一下删除的ID值是否已经被删除。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958400.png" alt="image-20210823000733218"> </p><p><strong>3). 在 update 方法上加注解@CacheEvict</strong></p><p>在更新数据之后，数据库的数据已经发生了变更，我们需要将缓存中对应的数据删除掉，避免出现数据库数据与缓存数据不一致的情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#p0.id&quot;)   //第一个参数的id属性</span></span><br><span class="line"><span class="comment">//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#user.id&quot;) //参数名为user参数的id属性</span></span><br><span class="line"><span class="comment">//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#root.args[0].id&quot;) //第一个参数的id属性</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;userCache&quot;,key = &quot;#result.id&quot;)</span>         <span class="comment">//返回值的id属性</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    userService.updateById(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上注解之后，我们可以重启服务，然后测试方式，基本和上述相同，先缓存数据，然后再更新某一条数据，通过debug的形式查询缓存数据的情况。</p><h4 id="4-3-4-Cacheable注解"><a href="#4-3-4-Cacheable注解" class="headerlink" title="4.3.4 @Cacheable注解"></a>4.3.4 @Cacheable注解</h4><blockquote><p>@Cacheable 说明:</p><p>​作用: 在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</p><p>​value: 缓存的名称，每个缓存名称下面可以有多个key</p><p>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p></blockquote><p><strong>1). 在getById上加注解@Cacheable</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</span></span><br><span class="line"><span class="comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span></span><br><span class="line"><span class="comment">* key：缓存的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(id);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). 测试</strong></p><p>我们可以重启服务，然后通过debug断点跟踪程序执行。我们发现，第一次访问，会请求我们controller的方法，查询数据库。后面再查询相同的id，就直接获取到数据库，不用再查询数据库了，就说明缓存生效了。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958171.png" alt="image-20210823002517941"> </p><p>当我们在测试时，查询一个数据库不存在的id值，第一次查询缓存中没有，也会查询数据库。而第二次再查询时，会发现，不再查询数据库了，而是直接返回，那也就是说如果根据ID没有查询到数据,那么会自动缓存一个null值。 我们可以通过debug，验证一下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958024.png" alt="image-20210823002907048"> </p><p>我们能不能做到，当查询到的值不为null时，再进行缓存，如果为null，则不缓存呢? 答案是可以的。</p><p><strong>3). 缓存非null值</strong></p><p>在@Cacheable注解中，提供了两个属性分别为： condition， unless 。</p><blockquote><p>condition : 表示满足什么条件, 再进行缓存 ;</p><p>unless : 表示满足条件则不缓存 ; 与上述的condition是反向的 ;</p></blockquote><p>具体实现方式如下: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</span></span><br><span class="line"><span class="comment"> * value：缓存的名称，每个缓存名称下面可以有多个key</span></span><br><span class="line"><span class="comment"> * key：缓存的key</span></span><br><span class="line"><span class="comment"> * condition：条件，满足条件时才缓存数据</span></span><br><span class="line"><span class="comment"> * unless：满足条件则不缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;, unless = &quot;#result == null&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(id);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意： 此处，我们使用的时候只能够使用 unless， 因为在condition中，我们是无法获取到结果 #result的。&#x3D;&#x3D;</p><p><strong>4). 在list方法上加注解@Cacheable</strong></p><p>在list方法中进行查询时，有两个查询条件，如果传递了id，根据id查询； 如果传递了name， 根据name查询，那么我们缓存的key在设计的时候，就需要既包含id，又包含name。 具体的代码实现如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;userCache&quot;,key = &quot;#user.id + &#x27;_&#x27; + #user.name&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(user.getId() != <span class="literal">null</span>,User::getId,user.getId());</span><br><span class="line">    queryWrapper.eq(user.getName() != <span class="literal">null</span>,User::getName,user.getName());</span><br><span class="line">    List&lt;User&gt; list = userService.list(queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再次重启服务，进行测试。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958696.png" alt="image-20210823005220230"> </p><p>第一次查询时，需要查询数据库，在后续的查询中，就直接查询了缓存，不再查询数据库了。</p><h3 id="4-4-集成Redis"><a href="#4-4-集成Redis" class="headerlink" title="4.4 集成Redis"></a>4.4 集成Redis</h3><p>在使用上述默认的ConcurrentHashMap做缓存时，服务重启之后，之前缓存的数据就全部丢失了，操作起来并不友好。在项目中使用，我们会选择使用redis来做缓存，主要需要操作以下几步： </p><p>1). pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2). application.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.200</span><span class="number">.200</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root@123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">1800000</span>   <span class="comment">#设置缓存过期时间，可选</span></span><br></pre></td></tr></table></figure><p>3). 测试</p><p>重新启动项目，通过postman发送根据id查询数据的请求，然后通过redis的图形化界面工具，查看redis中是否可以正常的缓存数据。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958720.png" alt="image-20210823010810680">  </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958120.png" alt="image-20210823010742530"></p><h2 id="5-缓存套餐数据"><a href="#5-缓存套餐数据" class="headerlink" title="5. 缓存套餐数据"></a>5. 缓存套餐数据</h2><h3 id="5-1-实现思路"><a href="#5-1-实现思路" class="headerlink" title="5.1 实现思路"></a>5.1 实现思路</h3><p>前面我们已经实现了移动端套餐查看功能，对应的服务端方法为SetmealController的list方法，此方法会根据前端提交的查询条件进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。现在需要对此方法进行缓存优化，提高系统的性能。</p><p>具体的实现思路如下：</p><p>1). 导入Spring Cache和Redis相关maven坐标</p><p>2). 在application.yml中配置缓存数据的过期时间</p><p>3). 在启动类上加入@EnableCaching注解，开启缓存注解功能</p><p>4). 在SetmealController的list方法上加入@Cacheable注解</p><p>5). 在SetmealController的save和delete方法上加入CacheEvict注解</p><h3 id="5-2-缓存套餐数据"><a href="#5-2-缓存套餐数据" class="headerlink" title="5.2 缓存套餐数据"></a>5.2 缓存套餐数据</h3><h4 id="5-2-1-代码实现"><a href="#5-2-1-代码实现" class="headerlink" title="5.2.1 代码实现"></a>5.2.1 代码实现</h4><p>1). pom.xml中引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;备注: spring-boot-starter-data-redis 这个依赖前面已经引入了, 无需再次引入。&#x3D;&#x3D;</p><p>2). application.yml中设置缓存过期时间</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">1800000</span> <span class="comment">#设置缓存数据的过期时间</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282240418.png" alt="image-20230628213939707"></p><p>3). 启动类上加入@EnableCaching注解</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958816.png" alt="image-20210823232419408"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282240857.png" alt="image-20230628214147878"></p><p>4). SetmealController的list方法上加入@Cacheable注解</p><p>在进行套餐数据查询时，我们需要根据分类ID和套餐的状态进行查询，所以我们在缓存数据时，可以将套餐分类ID和套餐状态组合起来作为key，如： 1627182182_1 (1627182182为分类ID，1为状态)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据条件查询套餐数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> setmeal</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;setmealCache&quot;,key = &quot;#setmeal.categoryId + &#x27;_&#x27; + #setmeal.status&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;List&lt;Setmeal&gt;&gt; <span class="title function_">list</span><span class="params">(Setmeal setmeal)</span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(setmeal.getCategoryId() != <span class="literal">null</span>,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">    queryWrapper.eq(setmeal.getStatus() != <span class="literal">null</span>,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">    queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282240212.png" alt="image-20230628214428661"></p><h4 id="5-2-2-测试"><a href="#5-2-2-测试" class="headerlink" title="5.2.2 测试"></a>5.2.2 测试</h4><p>缓存数据的代码编写完毕之后，重新启动服务，访问移动端进行测试，我们登陆之后在点餐界面，点击某一个套餐分类，查询套餐列表数据时，服务端报错了，错误信息如下： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958984.png" alt="image-20210823233406888" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306252002712.png" alt="image-20210823233514356"> </p><p>&#x3D;&#x3D;为什么会报出这个错误呢？&#x3D;&#x3D;</p><p>因为 @Cacheable 会将方法的返回值R缓存在Redis中，而在Redis中存储对象，该对象是需要被序列化的，而对象要想被成功的序列化，就必须得实现 Serializable 接口。而当前我们定义的R，并未实现 Serializable 接口。所以，要解决该异常，只需要让R实现  Serializable 接口即可。如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958809.png" alt="image-20210823233904520"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282240395.png" alt="image-20230628215422897"></p><p>修复完毕之后，再次重新测试，访问套餐分类下对应的套餐列表数据后，我们会看到Redis中确实可以缓存对应的套餐列表数据。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958552.png" alt="image-20210823234146526"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282240057.png" alt="image-20230628215856937"></p><h3 id="5-3-清理套餐数据"><a href="#5-3-清理套餐数据" class="headerlink" title="5.3 清理套餐数据"></a>5.3 清理套餐数据</h3><h4 id="5-3-1-代码实现"><a href="#5-3-1-代码实现" class="headerlink" title="5.3.1 代码实现"></a>5.3.1 代码实现</h4><p>为了保证数据库中数据与缓存数据的一致性，在我们添加套餐或者删除套餐数据之后，需要清空当前套餐缓存的全部数据。那么@CacheEvict注解如何清除某一份缓存下所有的数据呢，这里我们可以指定@CacheEvict中的一个属性 allEnties，将其设置为true即可。</p><p><strong>1). 在delete方法上加注解@CacheEvict</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除套餐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span> <span class="comment">//清除setmealCache名称下,所有的缓存数据</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;ids:&#123;&#125;&quot;</span>,ids);</span><br><span class="line">    setmealService.removeWithDish(ids);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;套餐数据删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282240002.png" alt="image-20230628220154630"></p><p><strong>2). 在delete方法上加注解@CacheEvict</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增套餐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> setmealDto</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span> <span class="comment">//清除setmealCache名称下,所有的缓存数据</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> SetmealDto setmealDto)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;套餐信息：&#123;&#125;&quot;</span>,setmealDto);</span><br><span class="line"></span><br><span class="line">    setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;新增套餐成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282240600.png" alt="image-20230628220308255"></p><h4 id="5-3-2-测试"><a href="#5-3-2-测试" class="headerlink" title="5.3.2 测试"></a>5.3.2 测试</h4><p>代码编写完成之后,重启工程,然后访问后台管理系统,对套餐数据进行新增 以及 删除, 然后通过Redis的图形化界面工具,查看Redis中的套餐缓存是否已经被删除。</p><h3 id="5-4-提交推送代码"><a href="#5-4-提交推送代码" class="headerlink" title="5.4 提交推送代码"></a>5.4 提交推送代码</h3><p>到目前为止，我们已经在v1.0这个分支中完成了套餐数据的缓存，接下来我们就需要将代码提交并推送到远程仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251958777.png" alt="image-20210823235612400"> </p><p>然后，在idea中切换到master分支，然后将v1.0分支的代码合并到master。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251959944.png" alt="image-20210823235822139"> </p><p>再将合并后的master分支的代码，推送到远程仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306251959400.png" alt="image-20210824000057260"> </p><p>视频解析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282241626.png" alt="image-20230628220836676"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282241785.png" alt="image-20230628220955401"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282241632.png" alt="image-20230628221034132"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282242745.png" alt="image-20230628221132114"></p><p>切换到master分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282242841.png" alt="image-20230628221236573"></p><p>合并分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282242251.png" alt="image-20230628221423541"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/optimization/day01/202306282242682.png" alt="image-20230628221511450"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础课程讲义</title>
      <link href="/archives/9.html"/>
      <url>/archives/9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>Redis入门</li><li>Redis数据类型</li><li>Redis常用命令</li><li>在Java中操作Redis</li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h3 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis"></a>1.1 什么是Redis</h3><p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件，它是「<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice」的首字母缩写，也就是「远程字典服务」。</p><ul><li><input disabled="" type="checkbox"> 基于内存存储，读写性能高</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221486.png" alt="image-20210927090555559"></p><ul><li><input disabled="" type="checkbox"> 适合存储热点数据（热点商品、资讯、新闻）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221184.png" alt="image-20210927090604994"></p><ul><li><input disabled="" type="checkbox"> 企业应用广泛</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221546.png" alt="image-20210927090612540"></p><h3 id="1-2-使用Redis能做什么"><a href="#1-2-使用Redis能做什么" class="headerlink" title="1.2 使用Redis能做什么"></a>1.2 使用Redis能做什么</h3><ul><li>数据缓存</li><li>消息队列</li><li>注册中心</li><li>发布订阅</li></ul><h2 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2. Redis入门"></a>2. Redis入门</h2><h3 id="2-1-Redis简介"><a href="#2-1-Redis简介" class="headerlink" title="2.1 Redis简介"></a>2.1 Redis简介</h3><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. 翻译为：Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p><p>官网：<a href="https://redis.io/">https://redis.io</a></p><p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p><p>NoSql（Not Only SQL），不仅仅是SQL，泛指<strong>非关系型数据库</strong>。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p><p>关系型数据库(RDBMS)：</p><ul><li>Mysql</li><li>Oracle</li><li>DB2</li><li>SQLServer</li></ul><p>非关系型数据库(NoSql)：</p><ul><li>Redis</li><li>Mongo db</li><li>MemCached</li></ul><h3 id="2-2-Redis下载与安装"><a href="#2-2-Redis下载与安装" class="headerlink" title="2.2 Redis下载与安装"></a>2.2 Redis下载与安装</h3><h4 id="2-2-1-Redis下载"><a href="#2-2-1-Redis下载" class="headerlink" title="2.2.1 Redis下载"></a>2.2.1 Redis下载</h4><p>Redis安装包分为windows版和Linux版：</p><ul><li>Windows版下载地址：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li><li>Linux版下载地址： <a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li></ul><p>下载后得到下面安装包：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221663.png" alt="image-20210927092053283"></p><h4 id="2-2-2-Redis安装"><a href="#2-2-2-Redis安装" class="headerlink" title="2.2.2 Redis安装"></a>2.2.2 Redis安装</h4><p><strong>1）在Linux中安装Redis</strong></p><p>在Linux系统安装Redis步骤：</p><ol><li>将Redis安装包上传到Linux</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251737170.png" alt="image-20230625101413825"></p><ol start="2"><li>解压安装包，命令：&#x3D;&#x3D;tar -zxvf redis-4.0.0.tar.gz -C &#x2F;usr&#x2F;local&#x3D;&#x3D;</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# tar -zxvf redis-4.0.0.tar.gz -C /usr/local</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251737545.png" alt="image-20230625101508890"></p><p>3.安装Redis的依赖环境gcc，命令：&#x3D;&#x3D;yum install gcc-c++&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# yum install gcc-c++</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251737905.png" alt="image-20230625102253662"></p><p>4.进入&#x2F;usr&#x2F;local&#x2F;redis-4.0.0，进行编译，命令：&#x3D;&#x3D;make&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis-4.0.0</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251737713.png" alt="image-20230625112332605"></p><p>5.进入redis的src目录进行安装，命令：&#x3D;&#x3D;make install&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd src</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251737408.png" alt="image-20230625112542982"></p><p><img src="C:\Users\zyz\AppData\Roaming\Typora\typora-user-images\image-20230702104631068.png" alt="image-20230702104631068"></p><p>安装后重点文件说明：</p><blockquote><p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-server：Redis服务启动脚本</p><p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;src&#x2F;redis-cli：Redis客户端脚本</p><p>&#x2F;usr&#x2F;local&#x2F;redis-4.0.0&#x2F;redis.conf：Redis配置文件</p></blockquote><p><strong>2）在Windows中安装Redis</strong></p><p>Redis的Windows版属于绿色软件，直接解压即可使用，解压后目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221479.png" alt="image-20210927093112281"></p><h3 id="2-3-Redis服务启动与停止"><a href="#2-3-Redis服务启动与停止" class="headerlink" title="2.3 Redis服务启动与停止"></a>2.3 Redis服务启动与停止</h3><p><strong>1）Linux系统中启动和停止Redis</strong></p><p>执行Redis服务启动脚本文件&#x3D;&#x3D;redis-server&#x3D;&#x3D;：</p><p>前台运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /usr/local/redis-4.0.0/src</span><br><span class="line">./redis-server</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221154.png" alt="image-20210927094452556"></p><p>通过启动日志可以看到，Redis默认端口号为&#x3D;&#x3D;6379&#x3D;&#x3D;。</p><p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p><p>通过&#x3D;&#x3D;redis-cli&#x3D;&#x3D;可以连接到本地的Redis服务，默认情况下不需要认证即可连接成功。</p><p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p><p>视频分析：</p><p>启动</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738951.png" alt="image-20230625144145781"></p><p>连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#  cd  /usr/local/redis-4.0.0/src</span><br><span class="line">[root@localhost src]# ./redis-cli</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738442.png" alt="image-20230625144418416"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738031.png" alt="image-20230625144613429"></p><p>修改配置文件 让他后台运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251743176.png" alt="image-20230625144828005"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738481.png" alt="image-20230625145846384"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738727.png" alt="image-20230625145908609"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738138.png" alt="image-20230625145921165"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738769.png" alt="image-20230625150105969"></p><p>启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/redis-4.0.0</span><br><span class="line">[root@localhost redis-4.0.0]# </span><br><span class="line">[root@localhost redis-4.0.0]# src/redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>查看是否启动成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis  </span><br></pre></td></tr></table></figure><p>如果启动成功是如下的样子  有6379的端口号表示启动成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-4.0.0]# ps -ef | grep redis  </span><br><span class="line">root      11070      1  0 09:10 ?        00:00:00 src/redis-server *:6379</span><br><span class="line">root      14229   7448  0 09:13 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p>连接 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#  cd  /usr/local/redis-4.0.0/src</span><br><span class="line">[root@localhost src]# ./redis-cli</span><br><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure><p>防火墙</p><p>查看Linux防火墙状态命令：systemctl status firewalld.service</p><p>使用命令关闭防火强：systemctl stop firewalld.service</p><p>再次查看Linux防火墙状态命令：systemctl status firewalld.service</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738778.png" alt="image-20230625150318630"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738924.png" alt="image-20230625150337013"></p><p>修改密码：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738681.png" alt="image-20230625150815088"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251738946.png" alt="image-20230625150855356"></p><p><img src="C:\Users\zyz\AppData\Roaming\Typora\typora-user-images\image-20230702110330023.png" alt="image-20230702110330023"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251739826.png" alt="image-20230625151055894"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740970.png" alt="image-20230625151152984"></p><p>远程连接</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740625.png" alt="image-20230625151406691"></p><p>重启  注意防火墙要关闭</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740607.png" alt="image-20230625151557310"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251743111.png" alt="image-20230625151707732"></p><p><strong>2）Windows系统中启动和停止Redis</strong></p><p>Windows系统中启动Redis，直接双击redis-server.exe即可启动Redis服务，redis服务默认端口号为6379</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221480.png" alt="image-20210927100421213"></p><p>&#x3D;&#x3D;Ctrl + C&#x3D;&#x3D;停止Redis服务</p><p>双击&#x3D;&#x3D;redis-cli.exe&#x3D;&#x3D;即可启动Redis客户端，默认连接的是本地的Redis服务，而且不需要认证即可连接成功。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242221903.png" alt="image-20210927100319016"></p><p>退出客户端可以输入&#x3D;&#x3D;exit&#x3D;&#x3D;或者&#x3D;&#x3D;quit&#x3D;&#x3D;命令。</p><h3 id="2-4-Redis配置文件"><a href="#2-4-Redis配置文件" class="headerlink" title="2.4 Redis配置文件"></a>2.4 Redis配置文件</h3><p>前面我们已经启动了Redis服务，默认情况下Redis启动后是在前台运行，而且客户端不需要密码就可以连接到Redis服务。如果我们希望Redis服务启动后是在后台运行，同时希望客户端认证通过后才能连接到Redis服务，应该如果做呢？</p><p>此时就需要修改Redis的配置文件：</p><ul><li>Linux系统中Redis配置文件：REDIS_HOME&#x2F;redis.conf</li><li>Windows系统中Redis配置文件：REDIS_HOME&#x2F;redis.windows.conf</li></ul><p><strong>通过修改Redis配置文件可以进行如下配置：</strong></p><p><strong>1）</strong>设置Redis服务后台运行</p><p>​将配置文件中的&#x3D;&#x3D;daemonize&#x3D;&#x3D;配置项改为yes，默认值为no。</p><p>​注意：Windows版的Redis不支持后台运行。</p><p><strong>2）</strong>设置Redis服务密码</p><p>​将配置文件中的 &#x3D;&#x3D;# requirepass foobared&#x3D;&#x3D; 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。</p><p><strong>3）</strong>设置允许客户端远程连接Redis服务</p><p>​Redis服务默认只能客户端本地连接，不允许客户端远程连接。将配置文件中的 &#x3D;&#x3D;bind 127.0.0.1&#x3D;&#x3D; 配置项注释掉。</p><p><strong>解释说明：</strong></p><blockquote><p>Redis配置文件中 &#x3D;&#x3D;#&#x3D;&#x3D; 表示注释</p><p>Redis配置文件中的配置项前面不能有空格，需要顶格写</p><p>daemonize：用来指定redis是否要用守护线程的方式启动，设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行</p><p>requirepass：设置Redis的连接密码</p><p>bind：如果指定了bind，则说明只允许来自指定网卡的Redis请求。如果没有指定，就说明可以接受来自任意一个网卡的Redis请求。</p></blockquote><p><strong>注意</strong>：修改配置文件后需要重启Redis服务配置才能生效，并且启动Redis服务时需要显示的指定配置文件：</p><p>1）Linux中启动Redis服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入Redis安装目录</span><br><span class="line">cd /usr/local/redis-4.0.0</span><br><span class="line"># 启动Redis服务，指定使用的配置文件</span><br><span class="line">./src/redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>2）Windows中启动Redis服务</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224381.png" alt="image-20210927104929169"></p><p>由于Redis配置文件中开启了认证校验，即客户端连接时需要提供密码，此时客户端连接方式变为：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224508.png" alt="image-20210927105909600"></p><p><strong>解释说明：</strong></p><blockquote><p>-h：指定连接的Redis服务的ip地址</p><p>-p：指定连接的Redis服务的端口号</p><p>-a：指定连接的Redis服务的密码</p></blockquote><h2 id="3-Redis数据类型"><a href="#3-Redis数据类型" class="headerlink" title="3. Redis数据类型"></a>3. Redis数据类型</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set &#x2F; zset</li></ul><h3 id="3-2-Redis-5种常用数据类型"><a href="#3-2-Redis-5种常用数据类型" class="headerlink" title="3.2 Redis 5种常用数据类型"></a>3.2 Redis 5种常用数据类型</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224243.png" alt="image-20210927111819871"></p><p><strong>解释说明：</strong></p><blockquote><p>字符串(string)：普通字符串，常用</p><p>哈希(hash)：适合存储对象</p><p>列表(list)：按照插入顺序排序，可以有重复元素</p><p>集合(set)：无序集合，没有重复元素</p><p>有序集合(sorted set &#x2F; zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</p></blockquote><h2 id="4-Redis常用命令"><a href="#4-Redis常用命令" class="headerlink" title="4. Redis常用命令"></a>4. Redis常用命令</h2><h3 id="4-1-字符串string操作命令"><a href="#4-1-字符串string操作命令" class="headerlink" title="4.1 字符串string操作命令"></a>4.1 字符串string操作命令</h3><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value          设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740247.png" alt="image-20230625152441267"></p><p>更多命令可以参考Redis中文网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn</a></p><h3 id="4-2-哈希hash操作命令"><a href="#4-2-哈希hash操作命令" class="headerlink" title="4.2 哈希hash操作命令"></a>4.2 哈希hash操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li><li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224733.png" alt="image-20210927113014567"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251743479.png" alt="image-20230625152705908"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740159.png" alt="image-20230625153004250"></p><h3 id="4-3-列表list操作命令"><a href="#4-3-列表list操作命令" class="headerlink" title="4.3 列表list操作命令"></a>4.3 列表list操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224172.png" alt="image-20210927113312384"></p><ul><li><p><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</p></li><li><p><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</p><p>后插入的先获取</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740646.png" alt="image-20230625153553636"></p><ul><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740478.png" alt="image-20230625154020218"></p><p><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251744959.png" alt="image-20230625154157023"></p><h3 id="4-4-集合set操作命令"><a href="#4-4-集合set操作命令" class="headerlink" title="4.4 集合set操作命令"></a>4.4 集合set操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224004.png" alt="image-20210927113632472"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740007.png" alt="image-20230625154752646"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740335.png" alt="image-20230625154917543"></p><p><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集     差集是有顺序的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251740189.png" alt="image-20230625155044056"></p><p><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741399.png" alt="image-20230625155309740"></p><h3 id="4-5-有序集合sorted-set操作命令"><a href="#4-5-有序集合sorted-set操作命令" class="headerlink" title="4.5 有序集合sorted set操作命令"></a>4.5 有序集合sorted set操作命令</h3><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224451.png" alt="image-20210927114003383"></p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741015.png" alt="image-20230625155656262"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251744847.png" alt="image-20230625155719087"></p><h3 id="4-6-通用命令"><a href="#4-6-通用命令" class="headerlink" title="4.6 通用命令"></a>4.6 通用命令</h3><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p><ul><li><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </li><li><strong>EXISTS</strong> key  检查给定 key 是否存在</li><li><strong>TYPE</strong> key  返回 key 所储存的值的类型</li><li><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</li><li><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741159.png" alt="image-20230625160322859"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741927.png" alt="image-20230625160438549"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741694.png" alt="image-20230625160515284"></p><h2 id="5-在Java中操作Redis"><a href="#5-在Java中操作Redis" class="headerlink" title="5. 在Java中操作Redis"></a>5. 在Java中操作Redis</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，官方推荐的有三种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Redisson</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><h3 id="5-2-Jedis"><a href="#5-2-Jedis" class="headerlink" title="5.2 Jedis"></a>5.2 Jedis</h3><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Jedis 操作 Redis 的步骤：</p><ol><li>获取连接</li><li>执行操作</li><li>关闭连接</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jedis操作Redis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 获取连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 执行具体的操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jedis.del(&quot;username&quot;);</span></span><br><span class="line"></span><br><span class="line">        jedis.hset(<span class="string">&quot;myhash&quot;</span>,<span class="string">&quot;addr&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hValue</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;myhash&quot;</span>, <span class="string">&quot;addr&quot;</span>);</span><br><span class="line">        System.out.println(hValue);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741271.png" alt="image-20230625160754583"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741488.png" alt="image-20230625161126744"></p><p>启动redsi</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741407.png" alt="image-20230625161207745"></p><p>通过客户端测试一下</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251744430.png" alt="image-20230625161243891"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741223.png" alt="image-20230625161316550"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741782.png" alt="image-20230625161348618"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741446.png" alt="image-20230625161414734"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251742279.png" alt="image-20230625161447721"></p><p>在idea上面也可以查到</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741665.png" alt="image-20230625161551663"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251741983.png" alt="image-20230625161646345"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251742079.png" alt="image-20230625161715071"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251742887.png" alt="image-20230625161841943"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251742919.png" alt="image-20230625161806313"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251742254.png" alt="image-20230625161937483"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251742576.png" alt="image-20230625162004860"></p><h3 id="5-3-Spring-Data-Redis"><a href="#5-3-Spring-Data-Redis" class="headerlink" title="5.3 Spring Data Redis"></a>5.3 Spring Data Redis</h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h4><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p><p>网址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306242224780.png" alt="image-20210927143741458"></p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot提供了对应的Starter，maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对hash类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ul><h4 id="5-3-2-使用方式"><a href="#5-3-2-使用方式" class="headerlink" title="5.3.2 使用方式"></a>5.3.2 使用方式</h4><h5 id="5-3-2-1-环境搭建"><a href="#5-3-2-1-环境搭建" class="headerlink" title="5.3.2.1 环境搭建"></a>5.3.2.1 环境搭建</h5><p>第一步：创建maven项目springdataredis_demo，配置pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdataredis_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(App.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：配置application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springdataredis_demo</span></span><br><span class="line">  <span class="comment">#Redis相关配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#操作的是0号数据库</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="comment">#Redis连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">1ms</span> <span class="comment">#连接池最大阻塞等待时间</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">4</span> <span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251745446.png" alt="image-20230625164740883"></p><p>第四步：提供配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p></blockquote><p>第五步：提供测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么可以直接注入redisTemplate</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251745734.png" alt="image-20230625165144403"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251745086.png" alt="image-20230625165510741"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251745167.png" alt="image-20230625165022724"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251745753.png" alt="image-20230625165646722"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Redis/202306251936195.png" alt="image-20230625165739748"></p><h5 id="5-3-2-2-操作字符串类型数据"><a href="#5-3-2-2-操作字符串类型数据" class="headerlink" title="5.3.2.2 操作字符串类型数据"></a>5.3.2.2 操作字符串类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作String类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;city123&quot;</span>,<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;city123&quot;</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，同时设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="number">10l</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值，如果存在则不执行任何操作</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;city1234&quot;</span>, <span class="string">&quot;nanjing&quot;</span>);</span><br><span class="line">    System.out.println(aBoolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-3-操作哈希类型数据"><a href="#5-3-2-3-操作哈希类型数据" class="headerlink" title="5.3.2.3 操作哈希类型数据"></a>5.3.2.3 操作哈希类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Hash类型数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    hashOperations.put(<span class="string">&quot;002&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;bj&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有字段</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得hash结构中的所有值</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-4-操作列表类型数据"><a href="#5-3-2-4-操作列表类型数据" class="headerlink" title="5.3.2.4 操作列表类型数据"></a>5.3.2.4 操作列表类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作List类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    List&lt;String&gt; mylist = listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String value : mylist) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得列表长度 llen</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lSize</span> <span class="operator">=</span> size.intValue();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lSize; i++) &#123;</span><br><span class="line">        <span class="comment">//出队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> (String) listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-5-操作集合类型数据"><a href="#5-3-2-5-操作集合类型数据" class="headerlink" title="5.3.2.5 操作集合类型数据"></a>5.3.2.5 操作集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作Set类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    setOperations.add(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    setOperations.remove(<span class="string">&quot;myset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-6-操作有序集合类型数据"><a href="#5-3-2-6-操作有序集合类型数据" class="headerlink" title="5.3.2.6 操作有序集合类型数据"></a>5.3.2.6 操作有序集合类型数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作ZSet类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存值</span></span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">10.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">11.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">12.0</span>);</span><br><span class="line">    zSetOperations.add(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">13.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    Set&lt;String&gt; myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改分数</span></span><br><span class="line">    zSetOperations.incrementScore(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">20.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除成员</span></span><br><span class="line">    zSetOperations.remove(<span class="string">&quot;myZset&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取值</span></span><br><span class="line">    myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-7-通用操作"><a href="#5-3-2-7-通用操作" class="headerlink" title="5.3.2.7 通用操作"></a>5.3.2.7 通用操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用操作，针对不同的数据类型都可以操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取Redis中所有的key</span></span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断某个key是否存在</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">itcast</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    System.out.println(itcast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定key</span></span><br><span class="line">    redisTemplate.delete(<span class="string">&quot;myZset&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定key对应的value的数据类型</span></span><br><span class="line">    <span class="type">DataType</span> <span class="variable">dataType</span> <span class="operator">=</span> redisTemplate.type(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">    System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Day02</title>
      <link href="/archives/8.html"/>
      <url>/archives/8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Day02"><a href="#Linux-Day02" class="headerlink" title="Linux-Day02"></a>Linux-Day02</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li><p>软件安装</p></li><li><p>项目部署</p></li></ul><h2 id="1-软件安装"><a href="#1-软件安装" class="headerlink" title="1. 软件安装"></a>1. 软件安装</h2><h3 id="1-1-软件安装方式"><a href="#1-1-软件安装方式" class="headerlink" title="1.1 软件安装方式"></a>1.1 软件安装方式</h3><p>在Linux系统中，安装软件的方式主要有四种，这四种安装方式的特点如下：</p><table><thead><tr><th>安装方式</th><th>特点</th></tr></thead><tbody><tr><td>二进制发布包安装</td><td>软件已经针对具体平台编译打包发布，只要解压，修改配置即可</td></tr><tr><td>rpm安装</td><td>软件已经按照redhat的包管理规范进行打包，使用rpm命令进行安装，&#x3D;&#x3D;不能自行解决库依赖问题&#x3D;&#x3D;</td></tr><tr><td>yum安装</td><td>一种在线软件安装方式，本质上还是rpm安装，自动下载安装包并安装，安装过程中自动解决库依赖问题(安装过程需要联网)</td></tr><tr><td>源码编译安装</td><td>软件以源码工程的形式发布，需要自己编译打包</td></tr></tbody></table><h3 id="1-2-安装JDK"><a href="#1-2-安装JDK" class="headerlink" title="1.2 安装JDK"></a>1.2 安装JDK</h3><p>上述我们介绍了Linux系统软件安装的四种形式，接下来我们就通过第一种(二进制发布包)形式来安装JDK。 JDK对应的二进制发布包，在课程资料中已经提供，如下：<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232256184.png" alt="image-20210814174022881"> </p><p>JDK具体安装步骤如下： </p><p><strong>1). 上传安装包</strong></p><p>使用FinalShell自带的上传工具将jdk的二进制发布包上传到Linux</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232256503.png" alt="image-20210814180303278"> </p><p>由于上述在进行文件上传时，选择的上传目录为根目录 &#x2F;，上传完毕后，我们执行指令 cd &#x2F; 切换到根目录下，查看上传的安装包。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232256718.png" alt="image-20210814180702071"> </p><p><strong>2). 解压安装包</strong></p><p>执行如下指令，将上传上来的压缩包进行解压，并通过-C参数指定解压文件存放目录为 &#x2F;usr&#x2F;local。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232256197.png" alt="image-20210814181014481"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306241635878.png" alt="image-20230623233228007"></p><p><strong>3). 配置环境变量</strong></p><p>使用vim命令修改&#x2F;etc&#x2F;profile文件，在文件末尾加入如下配置</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_171</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>具体操作指令如下: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1). 编辑/etc/profile文件，进入命令模式</span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">2). 在命令模式中，输入指令 G ， 切换到文件最后</span><br><span class="line">G</span><br><span class="line"></span><br><span class="line">3). 在命令模式中输入 i/a/o 进入插入模式，然后切换到文件最后一行</span><br><span class="line">i</span><br><span class="line"></span><br><span class="line">4). 将上述的配置拷贝到文件中</span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_171</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">5). 从插入模式，切换到指令模式</span><br><span class="line">ESC</span><br><span class="line"></span><br><span class="line">6). 按:进入底行模式，然后输入wq，回车保存</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306241635076.png" alt="image-20230623233431747"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306241635902.png" alt="image-20230623233608122"></p><p><strong>4). 重新加载profile文件</strong></p><p>为了使更改的配置立即生效，需要重新加载profile文件，执行命令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><strong>5). 检查安装是否成功</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257815.png" alt="image-20210814182327675"> </p><h3 id="1-3-安装Tomcat"><a href="#1-3-安装Tomcat" class="headerlink" title="1.3 安装Tomcat"></a>1.3 安装Tomcat</h3><h4 id="1-3-1-Tomcat安装"><a href="#1-3-1-Tomcat安装" class="headerlink" title="1.3.1 Tomcat安装"></a>1.3.1 Tomcat安装</h4><p>Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装，在我们的资料目录下，也已经准备了Tomcat的安装包： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257525.png" alt="image-20210814222911649"> </p><p>具体安装步骤如下： </p><p><strong>1). 上传安装包</strong></p><p>使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤一致)。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257021.png" alt="image-20210814223436296"> </p><p><strong>2). 解压安装包</strong></p><p>将上传上来的安装包解压到指定目录&#x2F;usr&#x2F;local下，执行命令为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p><strong>3). 启动Tomcat</strong></p><p>进入Tomcat的bin目录启动服务。执行命令为: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/apache-tomcat-7.0.57/</span><br><span class="line"></span><br><span class="line">cd bin</span><br><span class="line"></span><br><span class="line">sh startup.sh或者./startup.sh</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257086.png" alt="image-20210814223807228" style="zoom:85.5%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257712.png" alt="image-20210814223959266"> </p><h4 id="1-3-2-Tomcat进程查看"><a href="#1-3-2-Tomcat进程查看" class="headerlink" title="1.3.2 Tomcat进程查看"></a>1.3.2 Tomcat进程查看</h4><p>上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否成功，有多种方式，我们这里主要介绍常见的两种方式： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306241635668.png" alt="image-20230623234441471"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more  catalina.out</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306241635822.png" alt="image-20230623234705857"></p><p><strong>1). 查看启动日志</strong></p><p>Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为 catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1). 分页查询Tomcat的日志信息</span><br><span class="line">more /usr/local/apache-tomcat-7.0.57/logs/catalina.out</span><br><span class="line"></span><br><span class="line">2). 查询日志文件尾部的50行记录</span><br><span class="line">tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out</span><br></pre></td></tr></table></figure><p>只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。</p><p><strong>2). 查询系统进程</strong></p><p>我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是否启动。执行如下指令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257007.png" alt="image-20210814225635982"> </p><p><strong>说明:</strong> </p><ul><li><p>&#x3D;&#x3D;ps&#x3D;&#x3D;命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细信息</p></li><li><p>&#x3D;&#x3D;”|”&#x3D;&#x3D; 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入</p></li><li><p>使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程</p></li></ul><h4 id="1-3-3-防火墙操作"><a href="#1-3-3-防火墙操作" class="headerlink" title="1.3.3 防火墙操作"></a>1.3.3 防火墙操作</h4><p>前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们就可以尝试访问一下。访问地址：<a href="http://192.168.138.130:8080，我们发现是访问不到的。">http://192.168.138.130:8080，我们发现是访问不到的。</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257446.png" alt="image-20210814230753600"> </p><p>那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何操作防火墙，具体指令如下： </p><table><thead><tr><th>操作</th><th>指令</th><th>备注</th></tr></thead><tbody><tr><td>查看防火墙状态</td><td>systemctl status firewalld &#x2F; firewall-cmd –state</td><td></td></tr><tr><td>暂时关闭防火墙</td><td>systemctl stop firewalld</td><td></td></tr><tr><td>永久关闭防火墙(禁用开机自启)</td><td>systemctl disable firewalld</td><td>&#x3D;&#x3D;下次启动,才生效&#x3D;&#x3D;</td></tr><tr><td>暂时开启防火墙</td><td>systemctl start firewalld</td><td></td></tr><tr><td>永久开启防火墙(启用开机自启)</td><td>systemctl enable firewalld</td><td>&#x3D;&#x3D;下次启动,才生效&#x3D;&#x3D;</td></tr><tr><td>开放指定端口</td><td>firewall-cmd –zone&#x3D;public –add-port&#x3D;8080&#x2F;tcp –permanent</td><td>&#x3D;&#x3D;需要重新加载生效&#x3D;&#x3D;</td></tr><tr><td>关闭指定端口</td><td>firewall-cmd –zone&#x3D;public –remove-port&#x3D;8080&#x2F;tcp –permanent</td><td>&#x3D;&#x3D;需要重新加载生效&#x3D;&#x3D;</td></tr><tr><td>立即生效(重新加载)</td><td>firewall-cmd –reload</td><td></td></tr><tr><td>查看开放端口</td><td>firewall-cmd –zone&#x3D;public –list-ports</td><td></td></tr></tbody></table><blockquote><p>注意：</p><p>​A. systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作</p><p>​B. firewall-cmd是Linux中专门用于控制防火墙的命令</p><p>​C. 为了保证系统安全，服务器的防火墙不建议关闭</p></blockquote><p>那么我们要想访问到Tomcat，就可以采取两种类型的操作：</p><p><strong>A. 关闭防火墙</strong></p><p>执行指令 : </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>关闭之后，再次访问Tomcat，就可以访问到了。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257261.png" alt="image-20210814232643393"> </p><p><font color='red'>注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。</font></p><p><strong>B. 开放Tomcat的端口号8080</strong></p><p>执行指令: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①. 先开启系统防火墙</span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line">②. 再开放8080端口号</span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line">③. 重新加载防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257029.png" alt="image-20210814232643393"></p><h4 id="1-3-4-停止Tomcat"><a href="#1-3-4-停止Tomcat" class="headerlink" title="1.3.4 停止Tomcat"></a>1.3.4 停止Tomcat</h4><p>在Linux系统中，停止Tomcat服务的方式主要有两种： </p><p><strong>1). 运行Tomcat提供的脚本文件</strong></p><p>在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本就是用于停止tomcat服务的。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232257462.png" alt="image-20210814235615330"> </p><p>我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh shutdown.sh</span><br><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure><p><strong>2). 结束Tomcat进程</strong></p><p>我们可以先通过 <code>ps -ef|grep tomcat</code> 指令查看tomcat进程的信息，从进程信息中获取tomcat服务的进程号。然后通过kill -9 的形式，来杀死系统进程。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232258478.png" alt="image-20210814235926088"> </p><p>通过上述的指令，我们可以获取到tomcat的进程号为 79947。接下来，我们就可以通过指令 ，来杀死tomcat的进程 ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 79947 </span><br></pre></td></tr></table></figure><p>执行完上述指令之后，我们再访问Linux系统中的Tomcat，就访问不到了。</p><blockquote><p>注意：</p><p>​kill命令是Linux提供的用于结束进程的命令，-9表示强制结束</p></blockquote><blockquote><p>注意 ： </p><p>​虽然上述讲解的两种方式，都可以停止Tomcat服务，但是推荐使用第一种方式(.&#x2F;shutdown.sh)执行脚本来关闭tomcat服务，如果通过第一种方式停止不了tomcat了，这个时候，我们可以考虑使用第二种方式，强制杀死进程。</p></blockquote><h3 id="1-4-安装MySQL"><a href="#1-4-安装MySQL" class="headerlink" title="1.4 安装MySQL"></a>1.4 安装MySQL</h3><h4 id="1-4-1-MySQL安装"><a href="#1-4-1-MySQL安装" class="headerlink" title="1.4.1 MySQL安装"></a>1.4.1 MySQL安装</h4><p>对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？</p><blockquote><p><strong>RPM：</strong>全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。</p></blockquote><p>我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下：</p><p><strong>1). 检测当前系统是否安装过MySQL相关数据库</strong></p><p>需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa查询当前系统中安装的所有软件</span><br><span class="line">rpm -qa | grep mysql查询当前系统中安装的名称带mysql的软件</span><br><span class="line">rpm -qa | grep mariadb查询当前系统中安装的名称带mariadb的软件</span><br></pre></td></tr></table></figure><p>通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259245.png" alt="image-20210815002209121"> </p><p>通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。</p><p><strong>2). 卸载现有的MySQL数据库</strong></p><p>在rpm中，卸载软件的语法为： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps  软件名称</span><br></pre></td></tr></table></figure><p>那么，我们就可以通过指令，卸载 mariadb，具体指令为： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps  mariadb-libs-5.5.60-1.el7_5.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps  mariadb-libs-5.5.68-1.el7.x86_64    阿里 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259070.png" alt="image-20210815002649784"> </p><p>我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。</p><p><strong>3). 将资料中提供的MySQL安装包上传到Linux并解压</strong></p><p>A. 上传MySQL安装包</p><p>在课程资料中，提供的有MySQL的安装包 ，我们需要将该安装包上传到Linux系统的根目录 &#x2F; 下面。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232309870.png" alt="image-20210815002907050"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259102.png" alt="image-20210815003107734"> </p><p>B. 解压到&#x2F;usr&#x2F;local&#x2F;mysql</p><p>执行如下指令: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /usr/local/mysql</span><br><span class="line">tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259742.png" alt="image-20210815003647507"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/</span><br><span class="line">ll</span><br></pre></td></tr></table></figure><p><strong>4). 安装顺序安装rpm安装包</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm</span><br><span class="line">yum install net-tools</span><br><span class="line">rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>说明: </p><ul><li>因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。</li><li>安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网)</li><li>可以通过指令(yum update)升级现有软件及系统内核</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259936.png" alt="image-20210815004608198"> </p><p>安装不了mysql的解决办法：</p><p><a href="https://www.jianshu.com/p/3412e48845c4">https://www.jianshu.com/p/3412e48845c4</a></p><h4 id="1-4-2-MySQL启动"><a href="#1-4-2-MySQL启动" class="headerlink" title="1.4.2 MySQL启动"></a>1.4.2 MySQL启动</h4><p>MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld查看mysql服务状态</span><br><span class="line">systemctl start mysqld启动mysql服务</span><br><span class="line">systemctl stop mysqld停止mysql服务</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259032.png" alt="image-20210815005920721"></p><blockquote><p>说明： </p><p>​可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： </p><p>​systemctl enable mysqld</p></blockquote><p>我们可以通过如下两种方式，来判定mysql是否启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tunlp查看已经启动的服务</span><br><span class="line">netstat -tunlp | grep mysql查看mysql的服务信息</span><br><span class="line"></span><br><span class="line">ps –ef | grep mysql查看mysql进程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232309086.png" alt="image-20210815010410996"> </p><blockquote><p><font color='red'>备注: </font></p><p>​<font color='red'>A. netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</font></p><p>​参数说明: </p><p>​-l或–listening：显示监控中的服务器的Socket；<br>​-n或–numeric：直接使用ip地址，而不通过域名服务器；<br>​-p或–programs：显示正在使用Socket的程序识别码和程序名称；<br>​-t或–tcp：显示TCP传输协议的连线状况；<br>​-u或–udp：显示UDP传输协议的连线状况；</p><p>​<font color='red'>B. ps命令用于查看Linux中的进程数据。</font></p></blockquote><h4 id="1-4-3-MySQL登录"><a href="#1-4-3-MySQL登录" class="headerlink" title="1.4.3 MySQL登录"></a>1.4.3 MySQL登录</h4><h5 id="1-4-3-1-查阅临时密码"><a href="#1-4-3-1-查阅临时密码" class="headerlink" title="1.4.3.1 查阅临时密码"></a>1.4.3.1 查阅临时密码</h5><p>MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 &#x2F;var&#x2F;log&#x2F;mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。</p><p>可以执行如下指令：</p><p>1). cat &#x2F;var&#x2F;log&#x2F;mysqld.log</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259121.png" alt="image-20210815011744113"> </p><p>这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。</p><p>2). cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password</p><p>我们可以通过上述指令，查询日志文件内容中包含password的行信息。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259368.png" alt="image-20210815011938287"> </p><h5 id="1-4-3-2-登录MySQL"><a href="#1-4-3-2-登录MySQL" class="headerlink" title="1.4.3.2 登录MySQL"></a>1.4.3.2 登录MySQL</h5><p>获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。</p><p>执行如下指令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①. 登录mysql（复制日志中的临时密码登录）</span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">②. 修改密码</span><br><span class="line">    set global validate_password_length=4;设置密码长度最低位数</span><br><span class="line">    set global validate_password_policy=LOW;设置密码安全等级低，便于密码可以修改成root</span><br><span class="line">    set password = password(&#x27;root&#x27;);设置密码为root</span><br><span class="line">    </span><br><span class="line">③. 开启访问权限</span><br><span class="line">    grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br><span class="line">    flush privileges;</span><br></pre></td></tr></table></figure><p>操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">退出mysql: exit</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259288.png" alt="image-20210815012902871"> </p><p>当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259071.png" alt="image-20210815013909486" style="zoom: 67%;" /> <p>&#x3D;&#x3D;注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259010.png" alt="image-20210815014120709"> </p><h3 id="1-5-安装lrzsz"><a href="#1-5-安装lrzsz" class="headerlink" title="1.5 安装lrzsz"></a>1.5 安装lrzsz</h3><p>lrzsz 是用于在Linux系统中文件上传下载的软件。大家可能会存在疑问，我们用finalShell图形化界面就可以很方便的完成上传下载，为什么还要使用这个软件来完成上传下载呢？实际上是这样的，Linux的远程连接工具有很多，而finalShell只是其中的一种，而还有很多的远程连接工具并没有上传下载的功能，这个时候就需要依赖于lrzsz这个软件了。</p><p>对于lrzsz的安装，我们需要通过第三种软件安装方式yum来进行安装。这里，我们先对yum做一个简单介绍。</p><blockquote><p><strong>Yum：</strong> (Yellow dog Updater,Modified)，是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p></blockquote><p>安装lrzsz的步骤如下: </p><p><strong>1). 搜索lrzsz安装包</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list lrzsz</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259702.png" alt="image-20210815014811466"> </p><p><strong>2). 在线安装lrzsz</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install lrzsz.x86_64</span><br><span class="line">yum install lrzsz.x86_64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259512.png" alt="image-20210815014907816"> </p><p><strong>3). 测试</strong></p><p>在命令行中输入 rz , 就会自动打开一个文件选择的窗口，然后选择要上传的文件。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232259575.png" alt="image-20210815015047896"> </p><blockquote><p><strong>yum拓展知识:</strong></p><p>​ 1). 如果在不更改软件来源的情况下，是需要联网才能使用yum的，那么我们安装的软件是从哪儿下载的呢，这里就涉及到一个概念： yum源。</p><p>​</p><p>​ 2). 我们可以通过一个指令，来检查当前的yum源</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><blockquote><p>​<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232302966.png" alt="image-20210816192200749" style="zoom:80%;" />   </p><p>​从图中，我们可以看到我们安装的 CentOS7 采用的是网易的163yum源。</p><p>​</p><p>​  3). 网络 yum 源配置文件位于 &#x2F;etc&#x2F;yum.repos.d&#x2F; 目录下，文件扩展名为”*.repo”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /etc/yum.repos.d/</span><br></pre></td></tr></table></figure><p>​<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232302933.png" alt="image-20210816193941094" style="zoom:80%;" /> </p><p>​可以看到，该目录下有 7 个 yum 配置文件，通常情况下 CentOS-Base.repo 文件生效。</p><p>​</p><p>​  4). 添加阿里云yum源</p><p>​A. 先通过 <code>yum install wget</code> ,安装wget命令</p><p>​B. 备份默认的网易163的yum源，执行指令 ：</p><p>​切换目录: cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</p><p>​创建备份目录: mkdir bak</p><p>​移动现有的yum源文件到bak: mv *.repo bak&#x2F;</p><p>​C. 下载阿里云的yum源</p><p>​wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></p><p>​D. 执行命令，重新生成cache</p><p>​yum clean all</p><p>​yum makecache</p><p>​E. 再次查看yum源</p><p>​<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232302095.png" alt="image-20210816214230609" style="zoom:80%;" /> </p><p>​之后，我们通过yum指令安装软件，就是从阿里云下载的。</p></blockquote><h2 id="2-项目部署"><a href="#2-项目部署" class="headerlink" title="2. 项目部署"></a>2. 项目部署</h2><p>之前我们讲解Linux操作系统时，就提到，我们服务端开发工程师学习Linux系统的目的就是将来我们开发的项目绝大部分情况下都需要部署在Linux系统中。那么在本章节，我们将通过两种方式，来演示项目部署，分别是：手动部署项目 和 基于shell脚本自动部署。</p><h3 id="2-1-手动部署项目"><a href="#2-1-手动部署项目" class="headerlink" title="2.1 手动部署项目"></a>2.1 手动部署项目</h3><p><strong>1). 在IDEA中开发SpringBoot项目并打成jar包</strong></p><p>项目是一个很简单的springboot项目(可以自己开发一个，也可以直接导入资料中提供的)，结构如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303126.png" alt="image-20210815102934678"> </p><p>可以在本地的idea中先启动当前的demo工程，然后访问一下，看看工程是否正常访问。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303461.png" alt="image-20210815103130325"> </p><p>执行package指令，进行打包操作，将当前的springboot项目，打成一个jar包。 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303661.png" alt="image-20210815103344378"> </p><p><strong>2). 将jar包上传到Linux服务器</strong></p><p>通过 rz 指令，将打好的jar包上传至Linux服务器的 &#x2F;usr&#x2F;local&#x2F;app 目录下。 先执行指令创建app目录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A. 在/usr/local下创建目录app</span><br><span class="line">mkdir /usr/local/app</span><br><span class="line"></span><br><span class="line">B. 切换到app目录下</span><br><span class="line">cd /usr/local/app</span><br><span class="line"></span><br><span class="line">C. 执行指令,进行jar包上传</span><br><span class="line">rz</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303389.png" alt="image-20210815131101930"> </p><p>此时这个jar包就上传到 &#x2F;usr&#x2F;local&#x2F;app 目录了。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303285.png" alt="image-20210815131234243"> </p><p><strong>3). 启动SpringBoot程序</strong></p><p>由于我们的项目已经打成jar包上传上来到Linux服务器，我们只需要运行这个jar包项目就启动起来了，所以只需要执行如下指令即可： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar helloworld-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303734.png" alt="image-20210815131812582"> </p><p>&#x3D;&#x3D;注意： 由于前面安装的Tomcat在启动时，会占用端口号8080，而当前springboot项目我们没有配置端口号，默认也是8080，所以我们要想启动springboot项目，需要把之前运行的Tomcat停止掉。&#x3D;&#x3D;</p><p><strong>4). 检查防火墙，确保8080端口对外开放，访问SpringBoot项目</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303055.png" alt="image-20210815132430385"> </p><p>如果防火墙没有放开8080端口，还需要放开对应的端口号，执行如下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure><p><strong>5). 访问测试</strong></p><p><a href="http://192.168.138.130:8080/hello">http://192.168.138.130:8080/hello</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303118.png" alt="image-20210815132748655"> </p><p><strong>6). 后台运行项目</strong></p><p>当前这个demo工程我们已经部署成功了，并且我们也可以访问项目了。但是这个工程目前是存在问题的，就是当前我们项目启动的这个窗口被霸屏占用了，如果我们把这个窗口关闭掉(或ctrl+c)，当前服务也就访问不到了，我们可以试一下。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303278.png" alt="image-20210815133510405"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303047.png" alt="image-20210815133719642"> </p><p><strong>目前程序运行的问题：</strong></p><p>A. 线上程序不会采用控制台霸屏的形式运行程序，而是将程序在后台运行</p><p>B. 线上程序不会将日志输出到控制台，而是输出到日志文件，方便运维查阅信息</p><p><strong>后台运行程序:</strong></p><p>要想让我们部署的项目进行后台运行，这个时候我们需要使用到linux中的一个命令 nohup ，接下来，就来介绍一下nohup命令。</p><blockquote><p><strong>nohup命令：</strong>英文全称 no hang up（不挂起），用于不挂断地运行指定命令，退出终端不会影响程序的运行</p><p><strong>语法格式：</strong> nohup Command [ Arg … ] [&amp;]</p><p><strong>参数说明：</strong></p><p>​Command：要执行的命令</p><p>​Arg：一些参数，可以指定输出文件</p><p>​&amp;：让命令在后台运行</p><p><strong>举例：</strong></p><p>​nohup java -jar boot工程.jar &amp;&gt; hello.log &amp;</p><p>​上述指令的含义为： 后台运行 java -jar 命令，并将日志输出到hello.log文件</p></blockquote><p>那么经过上面的介绍，我们可以推测中，我们要想让当前部署的项目后台运行，就可以使用下面的指令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; hello.log &amp;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303927.png" alt="image-20210815140847083"> </p><p>这样的话，我们的项目就已经启动成功了，我们可以通过ps指令，查看到系统的进程。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303432.png" alt="image-20210815140944635"> </p><p>接下来，我们再次访问我们的项目，来看看服务是否可用。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232303831.png" alt="image-20210815132748655"> </p><p><strong>7). 停止SpringBoot项目</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304501.png" alt="image-20210815142132135"> </p><h3 id="2-2-基于Shell脚本自动部署"><a href="#2-2-基于Shell脚本自动部署" class="headerlink" title="2.2 基于Shell脚本自动部署"></a>2.2 基于Shell脚本自动部署</h3><h4 id="2-2-1-介绍"><a href="#2-2-1-介绍" class="headerlink" title="2.2.1 介绍"></a>2.2.1 介绍</h4><p>前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304921.png" alt="image-20210815143955229" style="zoom:80%;" /> <p>操作步骤如下： </p><p>1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中</p><p>2). 在Linux中安装Git,克隆代码</p><p>3). 在Linux中安装maven</p><p>4). 编写Shell脚本（拉取代码、编译、打包、启动）</p><p>5). 为用户授予执行Shell脚本的权限</p><p>6). 执行Shell脚本</p><h4 id="2-2-2-推送代码到远程"><a href="#2-2-2-推送代码到远程" class="headerlink" title="2.2.2 推送代码到远程"></a>2.2.2 推送代码到远程</h4><p>这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。</p><p>A. 创建远程仓库</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304702.png" alt="image-20210815145550077" style="zoom:80%;" /> <p>B. 将idea中的代码提交并推送到远程仓库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304493.png" alt="image-20210815145253347"> </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232315190.png" alt="image-20210815145432883" style="zoom:78%;" /> <h4 id="2-2-3-Git操作"><a href="#2-2-3-Git操作" class="headerlink" title="2.2.3 Git操作"></a>2.2.3 Git操作</h4><p>1). Git软件安装</p><p>通过yum命令在线安装git，执行如下指令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list git列出git安装包</span><br><span class="line">yum install git在线安装git</span><br></pre></td></tr></table></figure><p>通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304773.png" alt="image-20210815145934265">   </p><p>2). Git克隆代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">git clone https://gitee.com/ChuanZhiBoKe/helloworld.git</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304694.png" alt="image-20210815150452988"> </p><h4 id="2-2-4-Maven安装"><a href="#2-2-4-Maven安装" class="headerlink" title="2.2.4 Maven安装"></a>2.2.4 Maven安装</h4><p>由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下：</p><p><strong>1). 上传资料中提供的maven的安装包</strong></p><p>通过rz指令上传课程资料中的maven安装包</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232310701.png" alt="image-20210815151544489"> </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304215.png" alt="image-20210815151807043" style="zoom:90%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304383.png" alt="image-20210815151901262"> </p><p><strong>2). 解压maven安装包到&#x2F;usr&#x2F;local目录</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304149.png" alt="image-20210815152033246"> </p><p><strong>3). 在&#x2F;etc&#x2F;profile配置文件中配置环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 :</span><br><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.5.4</span><br><span class="line">export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">然后按ESC进入到命令模式，输入 :wq 保存并退出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304749.png" alt="image-20210815152321369"> </p><p>要想让配置的环境变量生效,还需要执行如下指令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">mvn -v</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304583.png" alt="image-20210815152616703"> </p><p><strong>4). 修改maven的settings.xml配置文件,配置本地仓库地址</strong></p><p>A. 切换目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/apache-maven-3.5.4/conf</span><br></pre></td></tr></table></figure><p>B. 编辑settings.xml配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim settings.xml</span><br></pre></td></tr></table></figure><p>在其中增加如下配置,配置本地仓库地址:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;localRepository&gt;/usr/local/repo&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304630.png" alt="image-20210815152936129"> </p><p>并在settings.xml中的<mirrors>标签中,配置阿里云的私服(&#x3D;&#x3D;选做&#x3D;&#x3D;):</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232304304.png" alt="image-20210815170915170"> </p><h4 id="2-2-5-Shell脚本准备"><a href="#2-2-5-Shell脚本准备" class="headerlink" title="2.2.5 Shell脚本准备"></a>2.2.5 Shell脚本准备</h4><blockquote><p>Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 </p><p>对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。</p></blockquote><p>在&#x2F;usr&#x2F;local&#x2F;目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305719.png" alt="image-20210815153759071"></p><p><strong>脚本解读:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305095.png" alt="image-20210815154943654"> </p><h4 id="2-2-6-Linux权限"><a href="#2-2-6-Linux权限" class="headerlink" title="2.2.6 Linux权限"></a>2.2.6 Linux权限</h4><p>前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。</p><blockquote><p>1). &#x3D;&#x3D;chmod&#x3D;&#x3D;（英文全拼：change mode）命令是控制用户对文件的权限的命令</p><p>2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x)</p><p>3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）</p><p>4). 只有文件的所有者和超级用户可以修改文件或目录的权限</p><p>5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行</p></blockquote><p>Linux系统中权限描述如下: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305655.png" alt="image-20210815162945754"> </p><p>解析当前脚本的权限情况: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305981.png" alt="image-20210815162135509" style="zoom:80%;" /> <p>chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r):</p><table><thead><tr><th>值</th><th>权限</th><th>rwx</th></tr></thead><tbody><tr><td>7</td><td>读 + 写 + 执行</td><td>rwx</td></tr><tr><td>6</td><td>读 + 写</td><td>rw-</td></tr><tr><td>5</td><td>读 + 执行</td><td>r-x</td></tr><tr><td>4</td><td>只读</td><td>r–</td></tr><tr><td>3</td><td>写 + 执行</td><td>-wx</td></tr><tr><td>2</td><td>只写</td><td>-w-</td></tr><tr><td>1</td><td>只执行</td><td>–x</td></tr><tr><td>0</td><td>无</td><td>—</td></tr></tbody></table><p><strong>举例:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 bootStart.sh   为所有用户授予读、写、执行权限</span><br><span class="line">chmod 755 bootStart.sh   为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限</span><br><span class="line">chmod 210 bootStart.sh   为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><p>三个数字分别代表不同用户的权限</p><ul><li>第1位表示文件拥有者的权限</li><li>第2位表示同组用户的权限</li><li>第3位表示其他用户的权限</li></ul><h4 id="2-2-7-授权并执行脚本"><a href="#2-2-7-授权并执行脚本" class="headerlink" title="2.2.7 授权并执行脚本"></a>2.2.7 授权并执行脚本</h4><p>在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 bootStart.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305845.png" alt="image-20210815163957647"> </p><p>权限解读: </p><p>A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限；</p><p>B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限；</p><p>B. 第三个7，代表其他用户，对该文件具有读写执行权限；</p><p>执行该shell脚本:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305717.png" alt="image-20210815170334935"> </p><p>&#x3D;&#x3D;注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。&#x3D;&#x3D;</p><p>启动完成之后, 我们可以查看java进程：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305658.png" alt="image-20210815170418707"> </p><p>访问项目：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305768.png" alt="image-20210815132748655"> </p><h4 id="2-2-8-设置静态IP"><a href="#2-2-8-设置静态IP" class="headerlink" title="2.2.8 设置静态IP"></a>2.2.8 设置静态IP</h4><p>我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 </p><p>1). 设置静态IP</p><p>设置静态ip，我们就需要修改 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 配置文件，内容如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim  /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">TYPE</span>=<span class="string">Ethernet</span></span><br><span class="line"><span class="attr">PROXY_METHOD</span>=<span class="string">none</span></span><br><span class="line"><span class="attr">BROWSER_ONLY</span>=<span class="string">no</span></span><br><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">static</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="string">&quot;192.168.138.100&quot;        # 设置的静态IP地址</span></span><br><span class="line"><span class="attr">NETMASK</span>=<span class="string">&quot;255.255.255.0&quot;         # 子网掩码</span></span><br><span class="line"><span class="attr">GATEWAY</span>=<span class="string">&quot;192.168.138.2&quot;         # 网关地址</span></span><br><span class="line"><span class="attr">DNS1</span>=<span class="string">&quot;192.168.138.2&quot;            # DNS服务器</span></span><br><span class="line"><span class="attr">DEFROUTE</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">IPV4_FAILURE_FATAL</span>=<span class="string">no</span></span><br><span class="line"><span class="attr">IPV6INIT</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">IPV6_AUTOCONF</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">IPV6_DEFROUTE</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">IPV6_FAILURE_FATAL</span>=<span class="string">no</span></span><br><span class="line"><span class="attr">IPV6_ADDR_GEN_MODE</span>=<span class="string">stable-privacy</span></span><br><span class="line"><span class="attr">NAME</span>=<span class="string">ens33</span></span><br><span class="line"><span class="attr">UUID</span>=<span class="string">afd0baa3-8bf4-4e26-8d20-5bc426b75fd6</span></span><br><span class="line"><span class="attr">DEVICE</span>=<span class="string">ens33</span></span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">ZONE</span>=<span class="string">public</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=&quot;192.168.145.100&quot;        # 设置的静态IP地址</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;         # 子网掩码</span><br><span class="line">GATEWAY=&quot;192.168.145.2&quot;         # 网关地址</span><br><span class="line">DNS1=&quot;192.168.145.2&quot;            # DNS服务器</span><br><span class="line">DNS2=&quot;8.8.8.8&quot;            # DNS服务器</span><br><span class="line">DNS3=&quot;4.4.4.4&quot;            # DNS服务器</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">ZONE=public</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=&quot;192.168.145.100&quot;        # 设置的静态IP地址</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;         # 子网掩码</span><br><span class="line">GATEWAY=&quot;192.168.145.2&quot;         # 网关地址</span><br><span class="line">DNS1=&quot;192.168.145.2&quot;            # DNS服务器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=&quot;192.168.145.101&quot;        # 设置的静态IP地址</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;         # 子网掩码</span><br><span class="line">GATEWAY=&quot;192.168.145.2&quot;         # 网关地址</span><br><span class="line">DNS1=&quot;192.168.145.2&quot;            # DNS服务器</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305686.png" alt="image-20210815171934667"> </p><p>上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305663.png" alt="image-20210815172303896"> </p><p>2). 重启网络服务</p><p>ip地址修改完毕之后，需要重启网络服务，执行如下指令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305423.png" alt="image-20210815172448448"> </p><p>&#x3D;&#x3D;注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。&#x3D;&#x3D;</p><p>再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day02/202306232305887.png" alt="image-20210815172832108"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Day01</title>
      <link href="/archives/7.html"/>
      <url>/archives/7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Day01"><a href="#Linux-Day01" class="headerlink" title="Linux-Day01"></a>Linux-Day01</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>Linux简介</li><li>Linux安装</li><li>Linux常用命令</li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h3 id="1-1-什么是Linux"><a href="#1-1-什么是Linux" class="headerlink" title="1.1 什么是Linux"></a>1.1 什么是Linux</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231922012.png" alt="image-20210808232140228"> </p><p>Linux是一套免费使用和自由传播的操作系统。说到操作系统，大家比较熟知的应该就是Windows和MacOS操作系统，我们今天所学习的Linux也是一款操作系统。</p><h3 id="1-2-为什么要学Linux"><a href="#1-2-为什么要学Linux" class="headerlink" title="1.2 为什么要学Linux"></a>1.2 为什么要学Linux</h3><p>那么我们为什么要学习Linux呢，主要出于两个方面的原因。</p><p><strong>1). 企业用人要求</strong></p><p>以下，是从知名招聘网站上搜索的java开发工程师的岗位要求，在很多的岗位要求中都提到了Linux操作系统的经验。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231851029.png" alt="image-20210808233115557"> </p><p>为什么作为javaEE开发工程师，企业还要求我们会Linux操作系统的相关知识呢?</p><p>这是因为Linux操作系统提供了很多稳定的发行版本，广泛的应用在我们的各种服务器操作系统领域，我们将来开发出来的项目，最终要上线运行，就需要将项目部署在Linux服务器中。</p><p><strong>2). 个人发展需要</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231851101.png" alt="image-20210808233951662"> </p><p>我们作为javaEE开发工程师，将来在企业中开发时会涉及到很多的数据库、中间件等技术，比如MySQL、Redis、MQ等技术，而这些应用软件大多都是需要安装在Linux系统中使用的。我们做为开发人员，是需要通过远程工具连接Linux操作系统，然后来操作这些软件的。而且一些小公司，可能还需要我们自己在服务器上安装这些软件。</p><p>所以，不管从企业的用人需求层面，还是个人发展需要层面来讲，我们作为服务端开发工程师，Linux的基本使用是我们必不可少的技能。</p><h3 id="1-3-学完Linux能干什么"><a href="#1-3-学完Linux能干什么" class="headerlink" title="1.3 学完Linux能干什么"></a>1.3 学完Linux能干什么</h3><p>学习完Linux操作系统课程之后，我们可以做以下几个方面的事情： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231851949.png" alt="image-20210808234042174" style="zoom:80%;" /> <p><strong>1). 环境搭建</strong></p><p>系统安装 : 一般我们不会直接将Linux系统安装在本机电脑上，而会安装在公司的一台专门的服务器上。 </p><p>远程连接 : 那么我们要想使用服务器，一般都是通过远程连接工具连接Linux系统进行操作。</p><p><strong>2). 常用命令</strong></p><p>连接上服务器之后，我们可以通过所学习的相关指令， 来操作Linux服务器，在Linux服务器中可以执行如下操作： </p><p>A. 文件、目录的基本操作(查看,删除,创建等)</p><p>B. 文件及文件夹的拷贝、移动、重命名</p><p>C. 文件的打包、压缩、解压缩操作</p><p>D. 文本的编辑</p><p><strong>3). 安装软件</strong></p><p>基本的常用指令学会操作之后，我们可以在Linux服务器中安装我们开发常用的软件，比如： JDK、Tomcat、MySQL的安装及配置。</p><p><strong>4). 项目部署</strong></p><p>把基础的软件及环境安装配置好之后，我们就可以将我们开发的项目部署在服务器中进行运行并测试。</p><p>对于我们学习Linux操作系统时，Linux命令是基础，也是学习Linux系统的重点内容，虽然Linux的指令有很多，但是我们常用的指令并不多，大家在学习的时候，主要掌握这部分常用的指令就可以了，对于其他的指令，以后我们用到的时候，知道怎么查询即可。</p><p><strong>对于Linux的常用指令的学习，最好的学习方法就是：<font color='red' size=7>多敲</font></strong></p><h2 id="2-Linux简介"><a href="#2-Linux简介" class="headerlink" title="2. Linux简介"></a>2. Linux简介</h2><h3 id="2-1-主流操作系统"><a href="#2-1-主流操作系统" class="headerlink" title="2.1 主流操作系统"></a>2.1 主流操作系统</h3><p>不同领域的主流操作系统，主要分为以下这么几类： 桌面操作系统、服务器操作系统、移动设备操作系统、嵌入式操作系统。接下来，这几个领域中，代表性的操作系统是那些?</p><p>1). 桌面操作系统</p><table><thead><tr><th>操作系统</th><th>特点</th></tr></thead><tbody><tr><td>Windows</td><td>用户数量最多</td></tr><tr><td>MacOS</td><td>操作体验好，办公人士首选</td></tr><tr><td>Linux</td><td>用户数量少(桌面操作系统,Linux使用较少)</td></tr></tbody></table><p>2). 服务器操作系统</p><table><thead><tr><th>操作系统</th><th>特点</th></tr></thead><tbody><tr><td>Unix</td><td>安全、稳定、付费</td></tr><tr><td>Linux</td><td>安全、稳定、免费、占有率高</td></tr><tr><td>Windows Server</td><td>付费、占有率低</td></tr></tbody></table><p>3). 移动设备操作系统</p><table><thead><tr><th>操作系统</th><th>特点</th></tr></thead><tbody><tr><td>Android</td><td>基于 Linux 、开源，主要用于智能手机、平板电脑和智能电视</td></tr><tr><td>IOS</td><td>苹果公司开发、不开源，用于苹果公司的产品，例如：iPhone、 iPad</td></tr></tbody></table><p>4). 嵌入式操作系统</p><table><thead><tr><th>操作系统</th><th>特点</th></tr></thead><tbody><tr><td>Linux</td><td>机顶盒、路由器、交换机</td></tr></tbody></table><h3 id="2-2-Linux发展历史"><a href="#2-2-Linux发展历史" class="headerlink" title="2.2 Linux发展历史"></a>2.2 Linux发展历史</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852453.png" alt="image-20210809000920156">  </p><p>时间：1991年</p><p>地点：芬兰赫尔辛基大学</p><p>人物：Linus Torvalds（21岁）</p><p>语言：C语言、汇编语言</p><p>logo：企鹅</p><p>特点：免费、开源(源代码开放)、多用户(同时允许多个用户操作同一个Linux系统)、多任务(同时允许多个任务执行)</p><h3 id="2-3-Linux系统版本"><a href="#2-3-Linux系统版本" class="headerlink" title="2.3 Linux系统版本"></a>2.3 Linux系统版本</h3><p>Linux系统的版本分为两种，分别是： 内核版 和 发行版。</p><p><strong>1). 内核版</strong></p><ul><li><p>由Linus Torvalds及其团队开发、维护</p></li><li><p>免费、开源</p></li><li><p>负责控制硬件</p></li></ul><p><strong>2). 发行版</strong></p><ul><li><p>基于Linux内核版进行扩展</p></li><li><p>由各个Linux厂商开发、维护</p></li><li><p>有收费版本和免费版本</p></li></ul><p>我们使用Linux操作系统，实际上选择的是Linux的发行版本。在linux系统中，有各种各样的发行版本，具体如下： </p><table><thead><tr><th>发行版本</th><th>Logo</th><th>特点</th></tr></thead><tbody><tr><td>Ubuntu</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231922572.png" alt="image-20210809001838861" style="zoom:50%;" /></td><td>以桌面应用为主</td></tr><tr><td>RedHat</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231922180.png" alt="image-20210809001731378" style="zoom:50%;" /></td><td>应用最广泛、收费</td></tr><tr><td>CentOS</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231922331.png" alt="image-20210809001741238" style="zoom:50%;" /></td><td>RedHat的社区版、免费</td></tr><tr><td>openSUSE</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231922206.png" alt="image-20210809001750999" style="zoom:50%;" /></td><td>对个人完全免费、图形界面华丽</td></tr><tr><td>Fedora</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231923314.png" alt="image-20210809001800676" style="zoom:50%;" /></td><td>功能完备、快速更新、免费</td></tr><tr><td>红旗Linux</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231923371.png" alt="image-20210809001814942" style="zoom:50%;" /></td><td>北京中科红旗软件技术有限公司开发</td></tr></tbody></table><p>除了上述罗列出来的发行版，还有很多Linux发行版，这里，我们就不再一一列举了。</p><h2 id="3-Linux安装"><a href="#3-Linux安装" class="headerlink" title="3. Linux安装"></a>3. Linux安装</h2><h3 id="3-1-安装方式介绍"><a href="#3-1-安装方式介绍" class="headerlink" title="3.1 安装方式介绍"></a>3.1 安装方式介绍</h3><p>Linux系统的安装方式，主要包含以下两种：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852949.png" alt="image-20210809184915617"> </p><table><thead><tr><th>方式</th><th>概述</th><th>场景</th></tr></thead><tbody><tr><td>物理机安装</td><td>直接将操作系统安装到服务器硬件上</td><td>企业开发中，我们使用的服务器基本都是采用这种方式</td></tr><tr><td>虚拟机安装</td><td>通过虚拟机软件安装</td><td>我们在学习阶段，没有自己服务器，而我们又需要学Linux，就可以安装在虚拟机上</td></tr></tbody></table><p><strong>虚拟机</strong>（Virtual Machine）指通过<strong>软件</strong>模拟的具有完整硬件系统功能、运行在完全隔离环境中的完整计算机系统。常用虚拟机软件： </p><ul><li><p>VMWare </p></li><li><p>VirtualBox</p></li><li><p>VMLite WorkStation</p></li><li><p>Qemu</p></li><li><p>HopeddotVOS</p></li></ul><p>那么我们就可以在课程中将Linux操作系统安装在虚拟机中，我们课上选择的虚拟机软件是VMware。</p><h3 id="3-2-安装VMware"><a href="#3-2-安装VMware" class="headerlink" title="3.2 安装VMware"></a>3.2 安装VMware</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306232237639.png" alt="image-20210809223354144"> </p><p>在我们的课程资料中提供了VMware的安装程序。直接双击运行VMware安装程序，根据提示完成安装即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852820.png" alt="image-20210809223932893"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231857726.png" alt="image-20210809223953820"> </p><p>以上就是VMware在安装时的每一步操作，基本上就是点击 “下一步” 一直进行安装。</p><h3 id="3-3-安装Linux"><a href="#3-3-安装Linux" class="headerlink" title="3.3 安装Linux"></a>3.3 安装Linux</h3><p>VMware虚拟机安装完毕之后，我们就可以打开VMware，并在上面来安装Linux操作系统。具体步骤如下： </p><p><strong>1). 选择创建新的虚拟机</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852892.png" alt="image-20210809224601436" style="zoom:80%;" /> <p><strong>2). 选择”典型”配置</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852580.png" alt="image-20210809224640245"  /> <p><strong>3). 选择”稍后安装操作系统(S)”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852700.png" alt="image-20210809224740271"> </p><p><strong>4). 选择”Linux”操作系统,”CentOS7 64位”版本</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852731.png" alt="image-20210809224851755"> </p><p><strong>5). 设置虚拟机的名称及系统文件存放路径</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231852228.png" alt="image-20210809225106268"> </p><p><strong>6). 设置磁盘容量</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231853237.png" alt="image-20210809225243488"> </p><p><strong>7). 自定义硬件信息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231854157.png" alt="image-20210809225706412"> </p><p><strong>8). 启动上述创建的新虚拟机</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231854085.png" alt="image-20210809230230390" style="zoom:80%;" />  <p><strong>9). 选择”Install CentOS7”</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231854420.png" alt="image-20210809230720673" style="zoom:80%;" /> <blockquote><p>进入到Linux系统里面, 我们发现光标无法移动到windows操作系统中了, 这个时候, 我们可以通过快捷键 “Ctrl+Alt” 切换光标到windows系统中。</p></blockquote><p><strong>10). 选择语言为 “简体中文”</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231857564.png" alt="image-20210809231002444" style="zoom:80%;" /> <p><strong>11). 选择”自动配置分区”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231857972.png" alt="image-20210809231704202">  </p><p>12). 选择”最小安装”</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231857108.png" alt="image-20210809232041661"> </p><p><strong>13). 设置”root”用户密码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231923332.png" alt="image-20210809232438579"> </p><p>安装完毕后，点击窗口中的蓝色的 “重启” 按钮，重启Linux系统。</p><p>密码是root</p><p><strong>14). 登录系统</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231858557.png" alt="image-20210809232913715"> </p><blockquote><p><font color='red'>注意 : 在Linux系统中，在命令行中输入密码信息，为了保证安全性，密码是不显示的(看似没有输入，实际已经输入了)；</font></p></blockquote><h3 id="3-4-网卡设置"><a href="#3-4-网卡设置" class="headerlink" title="3.4 网卡设置"></a>3.4 网卡设置</h3><p>服务器重启完成之后，我们可以通过linux的指令 <code>ip addr</code> 来查询Linux系统的IP地址，具体信息如下: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231858019.png" alt="image-20210809233341574" style="zoom:80%;" /> <p>从图中我们可以看到，并没有获取到linux系统的IP地址，这是为什么呢？这是由于启动服务器时未加载网卡，导致IP地址初始化失败而造成的。那么接下来我们就需要来修改网络初始化配置，设定网卡在系统启动时初始化。</p><p><strong>具体操作步骤如下：</strong> </p><p>1). 修改网卡的配置项</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd /进入根目录</span><br><span class="line">cd etc进入etc目录</span><br><span class="line">cd sysconfig进入sysconfig目录</span><br><span class="line">cd network-scripts进入network-scripts</span><br><span class="line">vi ifcfg-ens33编辑ifcfg-ens33文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进入文件后执行如下操作: </span><br><span class="line">①. 按 i 键  进入编辑状态</span><br><span class="line">②. 按↑↓键来移动光标, 删除no,输入yes </span><br><span class="line">③. 按 ESC 键</span><br><span class="line">④. 输入 :wq</span><br><span class="line">⑤. 按 ENTER保存退出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231858188.png" alt="image-20210809234131816"> </p><blockquote><p><font color='red'>备注: 在上述的操作中用到了Linux中的相关指令, 目前大家不用深究, 后面会详细讲解, 目前大家只需要把这个文件的配置项ONBOOT的值有no改为yes即可。</font></p></blockquote><p>2). 重新启动虚拟机</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231858995.png" alt="image-20210809234617798" style="zoom:80%;" /> <p>重启之后, 再次输入root的用户名密码，登录到Linux系统之后，可以通过指令 <code>ip addr</code> 来查看IP地址。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231859108.png" alt="image-20210809235056773"  /> <h3 id="3-5-安装SSH连接工具"><a href="#3-5-安装SSH连接工具" class="headerlink" title="3.5 安装SSH连接工具"></a>3.5 安装SSH连接工具</h3><h4 id="3-5-1-SSH连接工具介绍"><a href="#3-5-1-SSH连接工具介绍" class="headerlink" title="3.5.1 SSH连接工具介绍"></a>3.5.1 SSH连接工具介绍</h4><p>Linux已经安装并且配置好了，接下来我们要来学习Linux的基本操作指令。而在学习之前，我们还需要做一件事情，由于我们企业开发时，Linux服务器一般都是在远程的机房部署的，我们要操作服务器，不会每次都跑到远程的机房里面操作，而是会直接通过SSH连接工具进行连接操作。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231859036.png" alt="image-20210810000224690"> </p><p>SSH（Secure Shell），建立在应用层基础上的安全协议。常用的SSH连接工具: </p><table><thead><tr><th>SSH工具</th><th>Logo</th><th>说明</th></tr></thead><tbody><tr><td>putty</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231859180.png" alt="image-20210809235613688" style="zoom:15%;" /></td><td>免费, 界面简单, 功能单一</td></tr><tr><td>secureCRT</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231859020.png" alt="image-20210809235723109" style="zoom:20%;" /></td><td>收费, 功能强大</td></tr><tr><td>xshell</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231859324.png" alt="image-20210809235802640" style="zoom:50%;" /></td><td>收费版&#x2F;免费版</td></tr><tr><td>finalshell</td><td><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231859477.png" alt="image-20210809235841384" style="zoom: 67%;" /></td><td>免费, 功能强大, 界面效果好 (课程中采用)</td></tr></tbody></table><h4 id="3-5-2-FinalShell安装"><a href="#3-5-2-FinalShell安装" class="headerlink" title="3.5.2 FinalShell安装"></a>3.5.2 FinalShell安装</h4><p>在课程资料中，提供了finalShell的安装包</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306232238287.png" alt="image-20210810000309123"> </p><p>双击.exe文件，然后进行正常的安装即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231859788.png" alt="image-20210810000318212"> </p><h4 id="3-5-3-连接Linux"><a href="#3-5-3-连接Linux" class="headerlink" title="3.5.3 连接Linux"></a>3.5.3 连接Linux</h4><p><strong>1). 打开finalShell</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231900788.png" alt="image-20210810173004153" style="zoom:80%;" /> <p><strong>2). 建立连接</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231900301.png" alt="image-20210810173138650" style="zoom:80%;" /> <p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231900605.png" alt="image-20210810173900140"> </p><h3 id="3-6-Linux目录结构"><a href="#3-6-Linux目录结构" class="headerlink" title="3.6 Linux目录结构"></a>3.6 Linux目录结构</h3><p>登录到Linux系统之后，我们需要先来熟悉一下Linux的目录结构。在Linux系统中，也是存在目录的概念的，但是Linux的目录结构和Windows的目录结构是存在比较多的差异的 在Windows目录下，是一个一个的盘符(C盘、D盘、E盘)，目录是归属于某一个盘符的。Linux系统中的目录有以下特点： </p><p><strong>A. &#x2F; 是所有目录的顶点</strong></p><p><strong>B. 目录结构像一颗倒挂的树</strong></p><p><strong>Linux 和 Windows的目录结构对比:</strong> </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231901741.png" alt="image-20210810174831655" style="zoom: 80%;" /> <p>Linux的目录结构，如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231901486.png" alt="image-20210810174954476"> </p><p>根目录&#x2F; 下各个目录的作用及含义说明:  </p><table><thead><tr><th>编号</th><th>目录</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>&#x2F;bin</td><td>存放二进制可执行文件</td></tr><tr><td>2</td><td>&#x2F;boot</td><td>存放系统引导时使用的各种文件</td></tr><tr><td>3</td><td>&#x2F;dev</td><td>存放设备文件</td></tr><tr><td>4</td><td>&#x2F;etc</td><td>存放系统配置文件</td></tr><tr><td>5</td><td>&#x2F;home</td><td>存放系统用户的文件</td></tr><tr><td>6</td><td>&#x2F;lib</td><td>存放程序运行所需的共享库和内核模块</td></tr><tr><td>7</td><td>&#x2F;opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>8</td><td>&#x2F;root</td><td>超级用户目录</td></tr><tr><td>9</td><td>&#x2F;sbin</td><td>存放二进制可执行文件，只有root用户才能访问</td></tr><tr><td>10</td><td>&#x2F;tmp</td><td>存放临时文件</td></tr><tr><td>11</td><td>&#x2F;usr</td><td>存放系统应用程序</td></tr><tr><td>12</td><td>&#x2F;var</td><td>存放运行时需要改变数据的文件，例如日志文件</td></tr></tbody></table><h2 id="4-Linux常用命令"><a href="#4-Linux常用命令" class="headerlink" title="4. Linux常用命令"></a>4. Linux常用命令</h2><h3 id="4-1-Linux命令初体验"><a href="#4-1-Linux命令初体验" class="headerlink" title="4.1 Linux命令初体验"></a>4.1 Linux命令初体验</h3><h4 id="4-1-1-常用命令演示"><a href="#4-1-1-常用命令演示" class="headerlink" title="4.1.1 常用命令演示"></a>4.1.1 常用命令演示</h4><p>在这一部分中，我们主要介绍几个常用的命令，让大家快速感受以下Linux指令的操作方式。主要包含以下几个指令： </p><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>ls [目录名]</td><td>list</td><td>查看当前目录下的内容</td></tr><tr><td>2</td><td>pwd</td><td>print work directory</td><td>查看当前所在目录</td></tr><tr><td>3</td><td>cd [目录名]</td><td>change directory</td><td>切换目录</td></tr><tr><td>4</td><td>touch [文件名]</td><td>touch</td><td>如果文件不存在,创建文件</td></tr><tr><td>5</td><td>mkdir [目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>6</td><td>rm [文件名]</td><td>remove</td><td>删除指定文件</td></tr></tbody></table><p>接下来，我们快速的来演示一下这些常用的指令。</p><p><strong>1). ls</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231901356.png" alt="image-20210810182042076"> </p><blockquote><p>指令解读: </p><p>​ls 查看当前目录下的内容(文件及目录)</p><p>​ls &#x2F;   查看指定目录(&#x2F;)下的内容</p></blockquote><p><strong>2). pwd</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231901212.png" alt="image-20210810182335470"> </p><blockquote><p>指令解读: </p><p>​pwd查看当前所在目录</p></blockquote><p><strong>3). cd</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231901868.png" alt="image-20210810182607821"> </p><blockquote><p>指令解读: </p><p>​cd  &#x2F;切换到根目录</p><p>​cd  &#x2F;root切换到&#x2F;root目录</p></blockquote><p><strong>4). touch</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231914964.png" alt="image-20210810182917750"> </p><blockquote><p>指令解读: </p><p>​touch  1.txt    创建文件1.txt</p><p>​touch  2.txt 3.txt 4.txt   一次性创建文件2.txt,3.txt,3.txt</p></blockquote><p><strong>5). mkdir</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231914892.png" alt="image-20210810183154023"> </p><blockquote><p>指令解读: </p><p>​mkdir 01 创建文件夹01 </p></blockquote><p><strong>6). rm</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231914269.png" alt="image-20210810183522849"> </p><blockquote><p>指令解读: </p><p>​rm  4.txt删除文件 (删除文件时,需要确认,输入y, 代表确定)</p></blockquote><p>&#x3D;&#x3D;注意:&#x3D;&#x3D; </p><p>​<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231914837.png" alt="image-20210810184600425"> </p><p>​&#x3D;&#x3D;在执行Linux命令时，提示信息如果显示为乱码，如上图所示。这是由于编码问题导致，只需要修改Linux的编码即可，命令如下：&#x3D;&#x3D;</p><p>​echo ‘LANG&#x3D;”en_US.UTF-8”‘ &gt;&gt; &#x2F;etc&#x2F;profile</p><p>​source &#x2F;etc&#x2F;profile</p><h4 id="4-1-2-Linux命令使用技巧"><a href="#4-1-2-Linux命令使用技巧" class="headerlink" title="4.1.2 Linux命令使用技巧"></a>4.1.2 Linux命令使用技巧</h4><p>在我们使用Linux系统命令时，可以使用以下几个技巧： </p><p>1). Tab键自动补全</p><p>2). 连续两次Tab键，给出操作提示</p><p>3). 使用上下箭头快速调出曾经使用过的命令</p><p>4). 使用clear命令或者Ctrl+l快捷键实现清屏</p><p><strong>操作示例:</strong> </p><p>A. 执行指令的时候，对于操作的文件&#x2F;目录，按一下Tab会自动补全:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231914443.png" alt="image-20210810185641027"> </p><p>B. 如果上述以 “1.” 开头的文件有多个，可以按两下Tab键，给出操作提示:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231914604.png" alt="image-20210810190101671"> </p><p>C. 使用clear命令或者Ctrl+l快捷键实现清屏:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915478.png" alt="image-20210810190458929"></p><p>清屏之后，界面就变得干净了: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915909.png" alt="image-20210810190546209"> </p><h4 id="4-1-3-Linux命令格式"><a href="#4-1-3-Linux命令格式" class="headerlink" title="4.1.3 Linux命令格式"></a>4.1.3 Linux命令格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command [-options] [parameter]</span><br><span class="line"></span><br><span class="line">说明: </span><br><span class="line">command:  命令名</span><br><span class="line">[-options]:  选项，可用来对命令进行控制，也可以省略</span><br><span class="line">[parameter]: 传给命令的参数，可以是零个、一个或者多个</span><br><span class="line"></span><br><span class="line">注意: </span><br><span class="line">[]  代表可选</span><br><span class="line">命令名、选项、参数之间有空格进行分隔</span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915021.png" alt="image-20210810192202455"> </p><h3 id="4-2-文件目录操作命令"><a href="#4-2-文件目录操作命令" class="headerlink" title="4.2 文件目录操作命令"></a>4.2 文件目录操作命令</h3><h4 id="4-2-1-ls"><a href="#4-2-1-ls" class="headerlink" title="4.2.1 ls"></a>4.2.1 ls</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 显示指定目录下的内容</span><br><span class="line">语法: ls [-al] [dir]</span><br><span class="line">说明: </span><br><span class="line">-a 显示所有文件及目录 (. 开头的隐藏文件也会列出)</span><br><span class="line">-l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出</span><br><span class="line"></span><br><span class="line">注意: </span><br><span class="line">由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll</span><br><span class="line"></span><br><span class="line">常见用法: </span><br><span class="line">ls -al 查看当前目录的所有文件及目录详细信息</span><br><span class="line">ls -al /etc   查看/etc目录下所有文件及目录详细信息</span><br><span class="line">ll  查看当前目录文件及目录的详细信息 </span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915773.png" alt="image-20210810193149925"> </p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915039.png" alt="image-20210810193302047"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231924213.png" alt="image-20210810193605487"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915022.png" alt="image-20210810194129919"> </p><h4 id="4-2-2-cd"><a href="#4-2-2-cd" class="headerlink" title="4.2.2 cd"></a>4.2.2 cd</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 用于切换当前工作目录，即进入指定目录</span><br><span class="line">语法: cd [dirName]</span><br><span class="line"></span><br><span class="line">特殊说明: </span><br><span class="line">~表示用户的home目录</span><br><span class="line">. 表示目前所在的目录</span><br><span class="line">.. 表示目前目录位置的上级目录</span><br><span class="line"></span><br><span class="line">举例: </span><br><span class="line">cd ..切换到当前目录的上级目录</span><br><span class="line">cd ~切换到用户的home目录</span><br><span class="line">cd /usr/local切换到/usr/local目录</span><br></pre></td></tr></table></figure><blockquote><p>备注: </p><p>​用户的home目录 </p><p>​root用户&#x2F;root</p><p>​其他用户&#x2F;home&#x2F;xxx</p></blockquote><p>操作示例: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915668.png" alt="image-20210810230949775"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915221.png" alt="image-20210810231024129"> </p><p>cd .. 切换到当前目录位置的上级目录; 可以通过 cd ..&#x2F;.. 来切换到上级目录的上级目录。</p><h4 id="4-2-3-cat"><a href="#4-2-3-cat" class="headerlink" title="4.2.3 cat"></a>4.2.3 cat</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 用于显示文件内容</span><br><span class="line">语法: cat [-n] fileName</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">-n: 由1开始对所有输出的行数编号</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line">cat /etc/profile查看/etc目录下的profile文件内容</span><br></pre></td></tr></table></figure><p><strong>操作演示:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915972.png" alt="image-20210810231651338"> </p><p>cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。</p><h4 id="4-2-4-more"><a href="#4-2-4-more" class="headerlink" title="4.2.4 more"></a>4.2.4 more</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 以分页的形式显示文件内容</span><br><span class="line">语法: more fileName</span><br><span class="line"></span><br><span class="line">操作说明:</span><br><span class="line">    回车键 向下滚动一行</span><br><span class="line">    空格键 向下滚动一屏</span><br><span class="line">    b 返回上一屏</span><br><span class="line">    q或者Ctrl+C退出more</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">more /etc/profile以分页方式显示/etc目录下的profile文件内容</span><br></pre></td></tr></table></figure><p><strong>操作示例：</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915565.png" alt="image-20210810232212430" style="zoom:80%;" /> <p>当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。</p><h4 id="4-2-5-tail"><a href="#4-2-5-tail" class="headerlink" title="4.2.5 tail"></a>4.2.5 tail</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 查看文件末尾的内容</span><br><span class="line">语法: tail [-f] fileName</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">-f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出</span><br><span class="line"></span><br><span class="line">举例: </span><br><span class="line">tail /etc/profile显示/etc目录下的profile文件末尾10行的内容</span><br><span class="line">tail -20 /etc/profile显示/etc目录下的profile文件末尾20行的内容</span><br><span class="line">tail -f /itcast/my.log动态读取/itcast目录下的my.log文件末尾内容并显示</span><br></pre></td></tr></table></figure><p><strong>操作示例：</strong> </p><p>A. 默认查询文件尾部10行记录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231915237.png" alt="image-20210810232758510"> </p><p>B. 可以通过指定参数设置查询尾部指定行数的数据</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917436.png" alt="image-20210810232947018"> </p><p>C. 动态读取文件尾部的数据</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917629.png" alt="image-20210810233514284"> </p><p>在窗口1中执行指令 <code>tail -f 1.txt</code> 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 <code>echo 1 &gt;&gt; 1.txt</code> , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。</p><p>如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。</p><h4 id="4-2-6-mkdir"><a href="#4-2-6-mkdir" class="headerlink" title="4.2.6 mkdir"></a>4.2.6 mkdir</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 创建目录</span><br><span class="line">语法: mkdir [-p] dirName</span><br><span class="line"></span><br><span class="line">说明: </span><br><span class="line">-p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建</span><br><span class="line"></span><br><span class="line">举例: </span><br><span class="line">    mkdir itcast  在当前目录下，建立一个名为itcast的子目录</span><br><span class="line">    mkdir -p itcast/test   在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个</span><br></pre></td></tr></table></figure><p><strong>操作演示:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917251.png" alt="image-20210810234541073"> </p><h4 id="4-2-7-rmdir"><a href="#4-2-7-rmdir" class="headerlink" title="4.2.7 rmdir"></a>4.2.7 rmdir</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 删除空目录</span><br><span class="line">语法: rmdir [-p] dirName</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">-p: 当子目录被删除后使父目录为空目录的话，则一并删除</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line">    rmdir itcast   删除名为itcast的空目录</span><br><span class="line">    rmdir -p itcast/test   删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除</span><br><span class="line">    rmdir itcast*   删除名称以itcast开始的空目录</span><br></pre></td></tr></table></figure><p><strong>操作演示:</strong> </p><p>A. 删除空目录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917948.png" alt="image-20210810235044921"> </p><p>B. 删除非空目录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917811.png" alt="image-20210810235221722"> </p><p>C. 使用*通配符删除目录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917040.png" alt="image-20210810235305140"> </p><blockquote><p>*: 是一个通配符，代表任意字符； </p><p>rmdir  itcast* : 删除以itcast开头的目录</p><p>rmdir  *itcast : 删除以itcast结尾的目录</p></blockquote><h4 id="4-2-8-rm"><a href="#4-2-8-rm" class="headerlink" title="4.2.8 rm"></a>4.2.8 rm</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 删除文件或者目录</span><br><span class="line">语法: rm [-rf] name</span><br><span class="line"></span><br><span class="line">说明: </span><br><span class="line">    -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除</span><br><span class="line">    -f: 无需确认，直接删除</span><br><span class="line"></span><br><span class="line">举例: </span><br><span class="line">    rm -r itcast/     删除名为itcast的目录和目录中所有文件，删除前需确认</span><br><span class="line">    rm -rf itcast/    无需确认，直接删除名为itcast的目录和目录中所有文件</span><br><span class="line">    rm -f hello.txt   无需确认，直接删除hello.txt文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917419.png" alt="image-20210810235809473"> </p><p>&#x3D;&#x3D;注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。&#x3D;&#x3D;</p><h3 id="4-3-拷贝移动命令"><a href="#4-3-拷贝移动命令" class="headerlink" title="4.3 拷贝移动命令"></a>4.3 拷贝移动命令</h3><h4 id="4-3-1-cp"><a href="#4-3-1-cp" class="headerlink" title="4.3.1 cp"></a>4.3.1 cp</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 用于复制文件或目录</span><br><span class="line">语法: cp [-r] source dest</span><br><span class="line"></span><br><span class="line">说明: </span><br><span class="line">-r: 如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</span><br><span class="line"> </span><br><span class="line">举例: </span><br><span class="line">    cp hello.txt itcast/            将hello.txt复制到itcast目录中   </span><br><span class="line">    cp hello.txt ./hi.txt           将hello.txt复制到当前目录，并改名为hi.txt    ./hi.txt  这里面的.是指当前目录</span><br><span class="line">    cp -r itcast/ ./itheima/    将itcast目录和目录下所有文件复制到itheima目录下</span><br><span class="line">    cp -r itcast/* ./itheima/  将itcast目录下所有文件复制到itheima目录下</span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917964.png" alt="image-20210811180508369"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917620.png" alt="image-20210811180638556"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917013.png" alt="image-20210811180914417"> </p><p>如果拷贝的内容是目录，需要加上参数 -r </p><h4 id="4-3-2-mv"><a href="#4-3-2-mv" class="headerlink" title="4.3.2 mv"></a>4.3.2 mv</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 为文件或目录改名、或将文件或目录移动到其它位置</span><br><span class="line">语法: mv source dest</span><br><span class="line"></span><br><span class="line">举例: </span><br><span class="line">    mv hello.txt hi.txt                 将hello.txt改名为hi.txt</span><br><span class="line">    mv hi.txt itheima/                  将文件hi.txt移动到itheima目录中</span><br><span class="line">    mv hi.txt itheima/hello.txt   将hi.txt移动到itheima目录中，并改名为hello.txt</span><br><span class="line">    mv itcast/ itheima/                 如果itheima目录不存在，将itcast目录改名为itheima</span><br><span class="line">    mv itcast/ itheima/                 如果itheima目录存在，将itcast目录移动到itheima目录中</span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong> </p><p>mv 命令既能够改名，又可以移动，具体是改名还是移动,系统会根据我们输入的参数进行判定(如果第二个参数dest是一个已存在的目录,将执行移动操作,其他情况都是改名)</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917789.png" alt="image-20210811184240003"></p><h3 id="4-4-打包压缩命令"><a href="#4-4-打包压缩命令" class="headerlink" title="4.4 打包压缩命令"></a>4.4 打包压缩命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 对文件进行打包、解包、压缩、解压</span><br><span class="line">语法: tar  [-zcxvf]  fileName  [files]</span><br><span class="line">    包文件后缀为.tar表示只是完成了打包，并没有压缩</span><br><span class="line">    包文件后缀为.tar.gz表示打包的同时还进行了压缩</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">    -z: z代表的是gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压</span><br><span class="line">    -c: c代表的是create，即创建新的包文件</span><br><span class="line">    -x: x代表的是extract，实现从包文件中还原文件</span><br><span class="line">    -v: v代表的是verbose，显示命令的执行过程</span><br><span class="line">    -f: f代表的是file，用于指定包文件的名称</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">    打包</span><br><span class="line">        tar -cvf hello.tar ./*  将当前目录下所有文件打包，打包后的文件名为hello.tar</span><br><span class="line">        tar -zcvf hello.tar.gz ./*  将当前目录下所有文件打包并压缩，打包后的文件名为hello.tar.gz</span><br><span class="line"></span><br><span class="line">    解包</span><br><span class="line">        tar -xvf hello.tar  将hello.tar文件进行解包，并将解包后的文件放在当前目录</span><br><span class="line">        tar -zxvf hello.tar.gz  将hello.tar.gz文件进行解压，并将解压后的文件放在当前目录</span><br><span class="line">        tar -zxvf hello.tar.gz -C /usr/local     将hello.tar.gz文件进行解压，并将解压后的文件放在/usr/local目录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong> </p><p>A. 打包</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917917.png" alt="image-20210811185728541"> </p><p>B. 打包并压缩</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917783.png" alt="image-20210811190035256"> </p><p>C. 解包</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917236.png" alt="image-20210811190307630"> </p><p>D. 解压</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917221.png" alt="image-20210811190450820"> </p><p>解压到指定目录,需要加上参数 -C</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917784.png" alt="image-20210811190626414"> </p><h3 id="4-5-文本编辑命令"><a href="#4-5-文本编辑命令" class="headerlink" title="4.5 文本编辑命令"></a>4.5 文本编辑命令</h3><p>文本编辑的命令，主要包含两个: vi 和 vim，两个命令的用法类似，我们课程中主要讲解vim的使用。</p><h4 id="4-5-1-vi-amp-vim介绍"><a href="#4-5-1-vi-amp-vim介绍" class="headerlink" title="4.5.1 vi&amp;vim介绍"></a>4.5.1 vi&amp;vim介绍</h4><p>作用: vi命令是Linux系统提供的一个文本编辑工具，可以对文件内容进行编辑，类似于Windows中的记事本</p><p>语法: vi fileName</p><p>说明:<br>  1). vim是从vi发展来的一个功能更加强大的文本编辑工具，编辑文件时可以对文本内容进行着色，方便我们对文件进行编辑处理，所以实际工作中vim更加常用。<br>  2). 要使用vim命令，需要我们自己完成安装。可以使用下面的命令来完成安装：<code>yum install vim</code></p><h4 id="4-5-2-vim安装"><a href="#4-5-2-vim安装" class="headerlink" title="4.5.2 vim安装"></a>4.5.2 vim安装</h4><p>命令： yum install vim</p><p>我现在分配到时的yum是这个</p><p>阿里</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231917549.png" alt="image-20210811192217715"> </p><p>安装过程中，会有确认提示，此时输入 y，然后回车，继续安装：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231918067.png" alt="image-20210811192256269"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231918356.png" alt="image-20210811192350907"> </p><h4 id="4-5-3-vim使用"><a href="#4-5-3-vim使用" class="headerlink" title="4.5.3 vim使用"></a>4.5.3 vim使用</h4><p>作用: 对文件内容进行编辑，vim其实就是一个文本编辑器<br>语法: vim fileName<br>说明:<br>    1). 在使用vim命令编辑文件时，如果指定的文件存在则直接打开此文件。如果指定的文件不存在则新建文件。<br>    2). vim在进行文本编辑时共分为三种模式，分别是 命令模式（Command mode），插入模式（Insert mode）和底行模式（Last line mode）。这三种模式之间可以相互切换。我们在使用vim时一定要注意我们当前所处的是哪种模式。</p><p>三种模式:<br>    - 命令模式<br>      A. 命令模式下可以查看文件内容、移动光标（上下左右箭头、gg、G）<br>      B. 通过vim命令打开文件后，默认进入命令模式<br>      C. 另外两种模式需要首先进入命令模式，才能进入彼此</p><pre><code>  | 命令模式指令 | 含义                              |  | ------------ | --------------------------------- |  | gg           | 定位到文本内容的第一行            |  | G            | 定位到文本内容的最后一行          |  | dd           | 删除光标所在行的数据              |  | ndd          | 删除当前光标所在行及之后的n行数据 |  | u            | 撤销操作                          |  | shift+zz     | 保存并退出                        |  | i 或 a 或 o  | 进入插入模式                      |</code></pre><p>​      </p><ul><li><p>插入模式<br> A. 插入模式下可以对文件内容进行编辑<br> B. 在命令模式下按下[i,a,o]任意一个，可以进入插入模式。进入插入模式后，下方会出现【insert】字样<br> C. 在插入模式下按下ESC键，回到命令模式</p></li><li><p>底行模式<br> A. 底行模式下可以通过命令对文件内容进行查找、显示行号、退出等操作<br> B. 在命令模式下按下[:,&#x2F;]任意一个，可以进入底行模式<br> C. 通过&#x2F;方式进入底行模式后，可以对文件内容进行查找<br> D. 通过:方式进入底行模式后，可以输入wq（保存并退出）、q!（不保存退出）、set nu（显示行号）</p><table><thead><tr><th>底行模式命令</th><th>含义</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>:q!</td><td>不保存退出</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>取消行号显示</td></tr><tr><td>:n</td><td>定位到第n行, 如 :10 就是定位到第10行</td></tr></tbody></table></li></ul><p>​     <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231925996.png" alt="image-20210811194627474" style="zoom: 80%;" /> </p><p>​</p><p><strong>操作示例:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231918612.png" alt="image-20210811200005097"> </p><h3 id="4-6-查找命令"><a href="#4-6-查找命令" class="headerlink" title="4.6 查找命令"></a>4.6 查找命令</h3><h4 id="4-6-1-find"><a href="#4-6-1-find" class="headerlink" title="4.6.1 find"></a>4.6.1 find</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 在指定目录下查找文件</span><br><span class="line">语法: find dirName -option fileName</span><br><span class="line">举例:</span><br><span class="line">    find  .  –name &quot;*.java&quot;在当前目录及其子目录下查找.java结尾文件</span><br><span class="line">    find  /itcast  -name &quot;*.java&quot;在/itcast目录及其子目录下查找.java结尾的文件</span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231918820.png" alt="image-20210811200438459"> </p><h4 id="4-6-2-grep"><a href="#4-6-2-grep" class="headerlink" title="4.6.2 grep"></a>4.6.2 grep</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 从指定文件中查找指定的文本内容</span><br><span class="line">语法: grep word fileName</span><br><span class="line">举例: </span><br><span class="line">    grep Hello HelloWorld.java查找HelloWorld.java文件中出现的Hello字符串的位置</span><br><span class="line">    grep hello *.java查找当前目录中所有.java结尾的文件中包含hello字符串的位置</span><br></pre></td></tr></table></figure><p><strong>操作示例:</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Linux/Day01/202306231918236.png" alt="image-20210811200737596"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git课程讲义</title>
      <link href="/archives/6.html"/>
      <url>/archives/6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-分布式版本控制工具"><a href="#Git-分布式版本控制工具" class="headerlink" title="Git 分布式版本控制工具"></a>Git 分布式版本控制工具</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>Git概述</li><li>Git代码托管服务</li><li>Git常用命令</li><li>在IDEA中使用Git</li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h3 id="1-1-什么是Git"><a href="#1-1-什么是Git" class="headerlink" title="1.1 什么是Git"></a>1.1 什么是Git</h3><p>Git是一个分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java类、xml文件、html页面等），在软件开发过程中被广泛使用。</p><p>在IDEA开发工具中可以集成Git（后面会讲解Git安装和集成过程）：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220929893.png" alt="image-20210924171926037"></p><p>集成后在IDEA中可以看到Git相关图标：<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220954345.png" alt="image-20210924172028329"></p><p>可以通过启动两个IDEA窗口模拟两个开发人员来展示Git的使用：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220931576.png" alt="image-20210926080623416"></p><p>其他的版本控制工具：</p><ul><li>SVN</li><li>CVS</li><li>VSS</li></ul><h3 id="1-2-使用Git能做什么"><a href="#1-2-使用Git能做什么" class="headerlink" title="1.2 使用Git能做什么"></a>1.2 使用Git能做什么</h3><ul><li>代码回溯：Git在管理文件过程中会记录日志，方便回退到历史版本</li><li>版本切换：Git存在分支的概念，一个项目可以有多个分支（版本），可以任意切换</li><li>多人协作：Git支持多人协作，即一个团队共同开发一个项目，每个团队成员负责一部分代码，通过Git就可以管理和协调</li><li>远程备份：Git通过仓库管理文件，在Git中存在远程仓库，如果本地文件丢失还可以从远程仓库获取</li></ul><h2 id="2-Git概述"><a href="#2-Git概述" class="headerlink" title="2. Git概述"></a>2. Git概述</h2><h3 id="2-1-Git简介"><a href="#2-1-Git简介" class="headerlink" title="2.1 Git简介"></a>2.1 Git简介</h3><p>Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git 仓库分为两种：</p><ul><li>本地仓库：开发人员自己电脑上的 Git 仓库</li><li>远程仓库：远程服务器上的 Git 仓库</li></ul><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220931929.png" alt="image-20210924173708313" style="zoom: 50%;" /><p>解释说明：</p><blockquote><p>commit：提交,将本地文件和版本信息保存到本地仓库</p><p>push：推送,将本地仓库文件和版本信息上传到远程仓库</p><p>pull：拉取,将远程仓库文件和版本信息下载到本地仓库</p></blockquote><h3 id="2-2-Git下载与安装"><a href="#2-2-Git下载与安装" class="headerlink" title="2.2 Git下载与安装"></a>2.2 Git下载与安装</h3><p>下载地址： <a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220931816.png" alt="image-20210924174639182"></p><p>下载完成后得到安装文件：<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932736.png" alt="image-20210924174717172"></p><p>直接双击完成安装即可，安装完成后可以在任意目录下点击鼠标右键，如果能够看到如下菜单则说明安装成功：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932751.png" alt="image-20210924174934683"></p><p>Git GUI Here：打开Git 图形界面</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932232.png" alt="image-20210924175209242"></p><p>Git Bash Here：打开Git 命令行</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932911.png" alt="image-20210924175314485"></p><p>Git安装目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932191.png" alt="image-20210926094227522"></p><h2 id="3-Git代码托管服务"><a href="#3-Git代码托管服务" class="headerlink" title="3. Git代码托管服务"></a>3. Git代码托管服务</h2><h3 id="3-1-常用的Git代码托管服务"><a href="#3-1-常用的Git代码托管服务" class="headerlink" title="3.1 常用的Git代码托管服务"></a>3.1 常用的Git代码托管服务</h3><p>Git中存在两种类型的仓库，即<strong>本地仓库</strong>和<strong>远程仓库</strong>。那么我们如何搭建Git<strong>远程仓库</strong>呢？</p><p>我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p><table><thead><tr><th>名称</th><th>网址</th><th>说明</th></tr></thead><tbody><tr><td>gitHub</td><td><a href="https://github.com/">https://github.com/</a></td><td>一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub</td></tr><tr><td>码云</td><td><a href="https://gitee.com/">https://gitee.com/</a></td><td>国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快</td></tr><tr><td>GitLab</td><td><a href="https://about.gitlab.com/">https://about.gitlab.com/</a></td><td>一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务</td></tr><tr><td>BitBucket</td><td><a href="https://bitbucket.org/">https://bitbucket.org/</a></td><td>一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户</td></tr></tbody></table><h3 id="3-2-码云代码托管服务"><a href="#3-2-码云代码托管服务" class="headerlink" title="3.2 码云代码托管服务"></a>3.2 码云代码托管服务</h3><p>码云网址：<a href="https://gitee.com/">https://gitee.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932775.png" alt="image-20210926082758518"></p><p>使用码云的操作流程如下：</p><ol><li>注册码云账号</li><li>登录码云</li><li>创建远程仓库</li><li>邀请其他用户成为仓库成员</li></ol><h4 id="3-2-1-注册码云账号"><a href="#3-2-1-注册码云账号" class="headerlink" title="3.2.1 注册码云账号"></a>3.2.1 注册码云账号</h4><p>注册网址： <a href="https://gitee.com/signup">https://gitee.com/signup</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932687.png" alt="image-20210926083229013"></p><h4 id="3-2-2-登录码云"><a href="#3-2-2-登录码云" class="headerlink" title="3.2.2 登录码云"></a>3.2.2 登录码云</h4><p>注册完成后可以使用刚刚注册的邮箱进行登录（地址： <a href="https://gitee.com/login">https://gitee.com/login</a> ）</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935047.png" alt="image-20210926083328306"></p><h4 id="3-2-3-创建远程仓库"><a href="#3-2-3-创建远程仓库" class="headerlink" title="3.2.3 创建远程仓库"></a>3.2.3 创建远程仓库</h4><p>登录成功后可以创建远程仓库，操作方式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932343.png" alt="image-20210926083510298"></p><p>页面跳转到新建仓库页面：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932639.png" alt="image-20210926083629924"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231344840.png" alt="image-20230622130312636"></p><p>解释说明：</p><blockquote><p>仓库名称：必填，每个仓库都需要有一个名称，同一个码云账号下的仓库名称不能重复</p><p>路径：访问远程仓库时会使用到，一般无需手动指定，和仓库名称自动保持一致</p><p>开源：所有人都可以查看此仓库</p><p>私有：只有此仓库的成员可见，其他人不可见</p></blockquote><p>创建完成后可以查看仓库信息：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932183.png" alt="image-20210926090131032"></p><p><strong>注意</strong>：每个Git远程仓库都会对应一个网络地址，点击【克隆&#x2F;下载】按钮，在弹出窗口点击【复制】按钮即可复制网络地址，地址如下：</p><p><a href="https://gitee.com/ChuanZhiBoKe/myGitRepo.git">https://gitee.com/ChuanZhiBoKe/myGitRepo.git</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231344836.png" alt="image-20230622130503786"></p><p>查看仓库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345212.png" alt="image-20230622130606846"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345019.png" alt="image-20230622130628414"></p><h4 id="3-2-4-邀请其他用户成为仓库成员"><a href="#3-2-4-邀请其他用户成为仓库成员" class="headerlink" title="3.2.4 邀请其他用户成为仓库成员"></a>3.2.4 邀请其他用户成为仓库成员</h4><p>前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。</p><p>点击管理按钮进入仓库管理页面，左侧菜单中可以看到【仓库成员管理】：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345489.png" alt="image-20230622130735843"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231412899.png" alt="image-20230622130803498"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220932679.png" alt="image-20210926090608272"></p><p>点击【开发者】菜单，跳转到如下页面：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935568.png" alt="image-20210926091027151"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345729.png" alt="image-20230622130834027"></p><p>点击【添加仓库成员】菜单下的【邀请用户】菜单，跳转到如下页面：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345526.png" alt="image-20230622130956119"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935128.png" alt="image-20210926091204422"></p><p>可以看到邀请用户有多种方式：链接邀请、直接添加、通过仓库邀请成员</p><p><strong>注意</strong>：被邀请用户必须为码云的注册用户，否则无法成为仓库成员</p><h2 id="4-Git常用命令"><a href="#4-Git常用命令" class="headerlink" title="4. Git常用命令"></a>4. Git常用命令</h2><h3 id="4-1-Git全局设置"><a href="#4-1-Git全局设置" class="headerlink" title="4.1 Git全局设置"></a>4.1 Git全局设置</h3><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息。在Git 命令行中执行下面命令：</p><p><strong>设置用户信息</strong> </p><p>  git config –global user.name “itcast”</p><p>  git config –global user.email “<a href="mailto:&#104;&#x65;&#108;&#x6c;&#x6f;&#64;&#105;&#x74;&#x63;&#97;&#x73;&#116;&#46;&#x63;&#x6e;">&#104;&#x65;&#108;&#x6c;&#x6f;&#64;&#105;&#x74;&#x63;&#97;&#x73;&#116;&#46;&#x63;&#x6e;</a>“</p><p><strong>查看配置信息</strong></p><p>  git config –list</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935064.png" alt="image-20210926092820321"></p><p>注意：上面设置的user.name和user.email并不是我们在注册码云账号时使用的用户名和邮箱，此处可以任意设置。</p><h3 id="4-2-获取Git仓库"><a href="#4-2-获取Git仓库" class="headerlink" title="4.2 获取Git仓库"></a>4.2 获取Git仓库</h3><p>要使用Git对我们的代码进行管理，首先需要获得Git仓库。</p><p>获取Git仓库通常有两种方式：</p><ul><li>在本地初始化Git仓库（不常用）</li><li>从远程仓库克隆（常用）</li></ul><h4 id="4-2-1-在本地初始化Git仓库"><a href="#4-2-1-在本地初始化Git仓库" class="headerlink" title="4.2.1 在本地初始化Git仓库"></a>4.2.1 在本地初始化Git仓库</h4><p><strong>操作步骤如下</strong>：</p><ol><li>在任意目录下创建一个空目录（例如repo1）作为我们的本地Git仓库</li><li>进入这个目录中，点击右键打开Git bash窗口</li><li>执行命令<strong>git</strong> <strong>init</strong></li></ol><p>如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935647.png" alt="image-20210926093721515"></p><h4 id="4-2-2-从远程仓库克隆"><a href="#4-2-2-从远程仓库克隆" class="headerlink" title="4.2.2 从远程仓库克隆"></a>4.2.2 从远程仓库克隆</h4><p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地</p><p><strong>命令格式</strong>：git clone 远程仓库地址</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935455.png" alt="image-20210926094404332"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345447.png" alt="image-20230622131900717"></p><p>第一次要输入gitee的用户名和密码</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345306.png" alt="image-20230622131955386"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231345837.png" alt="image-20230622132118278"></p><h3 id="4-3-工作区、暂存区、版本库"><a href="#4-3-工作区、暂存区、版本库" class="headerlink" title="4.3 工作区、暂存区、版本库"></a>4.3 工作区、暂存区、版本库</h3><p>为了更好的学习Git，我们需要了解Git相关的一些概念，这些概念在后面的学习中会经常提到。</p><p><strong>版本库</strong>：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231413042.png" alt="image-20230622132350064"></p><p><strong>工作区</strong>：包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231346362.png" alt="image-20230622132414304"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231346534.png" alt="image-20230622132456537"></p><p><strong>暂存区</strong>：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935487.png" alt="image-20210926094831386"></p><p>创建文件</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231346170.png" alt="image-20230622132801927"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231346902.png" alt="image-20230622132825190"></p><h3 id="4-4-Git工作区中文件的状态"><a href="#4-4-Git工作区中文件的状态" class="headerlink" title="4.4 Git工作区中文件的状态"></a>4.4 Git工作区中文件的状态</h3><p>Git工作区中的文件存在两种状态：</p><ul><li><p>untracked 未跟踪（未被纳入版本控制）</p></li><li><p>tracked 已跟踪（被纳入版本控制）</p><p>​     1）Unmodified 未修改状态</p><p>​     2）Modified 已修改状态</p><p>​     3）Staged 已暂存状态</p></li></ul><p><strong>注意</strong>：文件的状态会随着我们执行Git的命令发生变化</p><h3 id="4-5-本地仓库操作"><a href="#4-5-本地仓库操作" class="headerlink" title="4.5 本地仓库操作"></a>4.5 本地仓库操作</h3><p>本地仓库常用命令如下：</p><ul><li>git status 查看文件状态</li><li>git add 将文件的修改加入暂存区</li><li>git reset 将暂存区的文件取消暂存或者是切换到指定版本</li><li>git commit 将暂存区的文件修改提交到版本库</li><li>git log  查看日志</li></ul><h4 id="4-5-1-git-status"><a href="#4-5-1-git-status" class="headerlink" title="4.5.1 git status"></a>4.5.1 git status</h4><p>git status 命令用于查看文件状态</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935279.png" alt="image-20210926095623297"></p><p>注意：由于工作区中文件状态的不同，执行 git status 命令后的输出也会不同</p><h4 id="4-5-2-git-add"><a href="#4-5-2-git-add" class="headerlink" title="4.5.2 git add"></a>4.5.2 git add</h4><p>git add 命令的作用是将文件的修改加入暂存区，命令格式：git add fileName</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935039.png" alt="image-20210926100003056"></p><p>加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。</p><p>视频分析</p><p>理解    Staged 已暂存状态</p><ul><li>git status 查看文件状态</li><li>git add 将文件的修改加入暂存区</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231346987.png" alt="image-20230622133320994"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231413481.png" alt="image-20230622133550605"></p><p>现在我们让git管理   状态变成Staged 已暂存状态</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231346741.png" alt="image-20230622133738508"></p><h4 id="4-5-3-git-reset"><a href="#4-5-3-git-reset" class="headerlink" title="4.5.3 git reset"></a>4.5.3 git reset</h4><p>git reset 命令的作用是将暂存区的文件<strong>取消暂存</strong>或者是<strong>切换到指定版本</strong></p><p>取消暂存命令格式：git reset 文件名</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935439.png" alt="image-20210926101346514"></p><p>切换到指定版本命令格式：git reset –hard 版本号</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220935399.png" alt="image-20210926101401721"></p><p>注意：每次Git提交都会产生新的版本号，通过版本号就可以回到历史版本</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347595.png" alt="image-20230622134533222"></p><h4 id="4-5-4-git-commit"><a href="#4-5-4-git-commit" class="headerlink" title="4.5.4 git commit"></a>4.5.4 git commit</h4><p>git commit 命令的作用是将暂存区的文件修改提交到版本库，命令格式：git commit -m msg 文件名</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220936423.png" alt="image-20210926101859601"></p><p>解释说明：</p><blockquote><p>-m：代表message，每次提交时需要设置，会记录到日志中</p><p>可以使用通配符*一次提交多个文件</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347378.png" alt="image-20230622134915912"></p><p>现在的User.java处于Unmodified 未修改状态</p><p>现在修改User.java</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347355.png" alt="image-20230622135151421"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347431.png" alt="image-20230622135251499"></p><p>把User.java放在暂存区并提交</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347381.png" alt="image-20230622140157665"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231413658.png" alt="image-20230622140004779"></p><p>把user.xml放在暂存区并提交</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347811.png" alt="image-20230622140459197"></p><p>现在的user.xml已经让git管理    并处理Unmodified 未修改状态</p><h4 id="4-5-5-git-log"><a href="#4-5-5-git-log" class="headerlink" title="4.5.5 git log"></a>4.5.5 git log</h4><p>git log 命令的作用是查看提交日志</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220936471.png" alt="image-20210926102305539"></p><p>通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347310.png" alt="image-20230622145913337"></p><p>回到以前版本</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231413114.png" alt="image-20230622150132095"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347122.png" alt="image-20230622150226291"></p><p>回到另一个版本  有修改 有user.xml的版本</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231347665.png" alt="image-20230622151455535"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231348955.png" alt="image-20230622151518829"></p><h3 id="4-6-远程仓库操作"><a href="#4-6-远程仓库操作" class="headerlink" title="4.6 远程仓库操作"></a>4.6 远程仓库操作</h3><p>前面执行的命令操作都是针对的本地仓库，本节我们会学习关于远程仓库的一些操作，具体包括：</p><ul><li>git remote  查看远程仓库</li><li>git remote add 添加远程仓库</li><li>git clone 从远程仓库克隆</li><li>git pull 从远程仓库拉取</li><li>git push 推送到远程仓库</li></ul><h4 id="4-6-1-git-remote"><a href="#4-6-1-git-remote" class="headerlink" title="4.6.1 git remote"></a>4.6.1 git remote</h4><p>如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。</p><p>如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220936664.png" alt="image-20210926103746721"></p><p>解释说明：</p><blockquote><p>可以通过-v参数查看远程仓库更加详细的信息</p><p>本地仓库配置的远程仓库都需要一个简称，后续在和远程仓库交互时会使用到这个简称</p></blockquote><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231348180.png" alt="image-20230622152009899"></p><p>如果仓库在本地初始化   在本地创建的仓库     没有远程仓库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231348822.png" alt="image-20230622152143961"></p><h4 id="4-6-2-git-remote-add"><a href="#4-6-2-git-remote-add" class="headerlink" title="4.6.2 git remote add"></a>4.6.2 git remote add</h4><p>添加远程仓库命令格式：git remote add 简称 远程仓库地址</p><p>在本地初始化的仓库和远程仓库没有关系  我们可以通过这个命令来把本地初始化的仓库添加到远程</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220936232.png" alt="image-20210926104723901"></p><p>注意：一个本地仓库可以关联多个远程仓库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231348858.png" alt="image-20230622152907268"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231348393.png" alt="image-20230622154500263"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231413418.png" alt="image-20230622154611240"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231413441.png" alt="image-20230622155310318"></p><h4 id="4-6-3-git-clone"><a href="#4-6-3-git-clone" class="headerlink" title="4.6.3 git clone"></a>4.6.3 git clone</h4><p>如果你想获得一份已经存在了的 Git 远程仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）。</p><p>克隆仓库的命令格式： git clone 远程仓库地址</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942561.png" alt="image-20210926105017148"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414953.png" alt="image-20230622155518892"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414625.png" alt="image-20230622155608754"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414185.png" alt="image-20230622155736397"></p><h4 id="4-6-4-git-push"><a href="#4-6-4-git-push" class="headerlink" title="4.6.4 git push"></a>4.6.4 git push</h4><p>将本地仓库内容推送到远程仓库，命令格式：git push 远程仓库简称 分支名称</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220936936.png" alt="image-20210926105413681"></p><p>在使用git push命令将本地文件推送至码云远程仓库时，如果是第一次操作，需要进行身份认证，认证通过才可以推送，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220936600.png" alt="image-20210926105913504"></p><p>注意：上面的用户名和密码对应的就是我们在码云上注册的用户名和密码，认证通过后会将用户名和密码保存到windows系统中（如下图），后续再推送则无需重复输入用户名和密码。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942239.png" alt="image-20210926110810630"></p><p>推送完成后可以到远程仓库中查看文件的变化。</p><p>解释说明：</p><blockquote><p>一个仓库可以有多个分支，默认情况下在创建仓库后会自动创建一个master分支</p><p>后面会讲解分支相关的操作</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414778.png" alt="image-20230622160611361"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414913.png" alt="image-20230622160629072"></p><p>现在我们修改一下文件内容在重新保存到暂存区（     <code>git add  test.txt</code>    ）  重新提交到本地仓库（     <code>git commit -m &quot;edit test.txt&quot; test.txt                                        </code>    ）  在重新推送到远程仓库（     <code>git push origin  master                                                       </code>    ）</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414553.png" alt="image-20230622160838170"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414241.png" alt="image-20230622161143343"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414610.png" alt="image-20230622161348760"></p><h4 id="4-6-5-git-pull"><a href="#4-6-5-git-pull" class="headerlink" title="4.6.5 git pull"></a>4.6.5 git pull</h4><p><strong>git</strong> <strong>pull</strong> 命令的作用是从远程仓库获取最新版本并合并到本地仓库</p><p>命令格式：git pull 远程仓库简称 分支名称</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220939182.png" alt="image-20210926111013002"></p><p><strong>注意</strong>：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ）</p><p>解决此问题可以在git pull命令后加入参数–allow-unrelated-histories</p><p>视频解析</p><p>准备工作</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414746.png" alt="image-20230622210710614"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414929.png" alt="image-20230622162658842"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414753.png" alt="image-20230622162906848"></p><p>关联</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414155.png" alt="image-20230622211041797"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231604052.png" alt="image-20230622211306234"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414609.png" alt="image-20230622211526163"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231603419.png" alt="image-20230622211601233"></p><p>拉取</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414449.png" alt="image-20230622211716016"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414729.png" alt="image-20230622211838760"></p><p>如果远程仓库和本地仓库一样的话  就不用更新  则拉取时报以下提示</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231603860.png" alt="image-20230622211938099"></p><p>现在我们让小黑修改代码并推送到远程仓库让小白去拉</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231414144.png" alt="image-20230622212306916"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231603237.png" alt="image-20230622212825860"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415193.png" alt="image-20230622212910859"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415833.png" alt="image-20230622212938731"></p><p>小白拉取</p><p>还没拉取前</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415232.png" alt="image-20230622213140745"></p><p>拉取</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415728.png" alt="image-20230622214112140"></p><p>上面的例子是我自己在本地初始化init的  所以合并时 会报错    所以应该在git pull命令后加入参数–allow-unrelated-histories</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415585.png" alt="image-20230622214843414"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415385.png" alt="image-20230622215037287"></p><p><strong>注意</strong>：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ）</p><p>解决此问题可以在git pull命令后加入参数–allow-unrelated-histories</p><h3 id="4-7-分支操作"><a href="#4-7-分支操作" class="headerlink" title="4.7 分支操作"></a>4.7 分支操作</h3><p>分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p><p>本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。</p><p>通过git init 命令创建本地仓库时默认会创建一个master分支。</p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415442.png" alt="image-20230622215456234"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415633.png" alt="image-20230622215613161"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415689.png" alt="image-20230622215721636"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415449.png" alt="image-20230622215953188"></p><p>本节我们会学习关于分支的相关命令，具体命令如下：</p><ul><li>git branch                                     查看分支</li><li>git branch [name]                       创建分支</li><li>git checkout [name]                    切换分支</li><li>git push [shortName] [name]   推送至远程仓库分支</li><li>git merge [name]                        合并分支</li></ul><h4 id="4-7-1-查看分支"><a href="#4-7-1-查看分支" class="headerlink" title="4.7.1 查看分支"></a>4.7.1 查看分支</h4><p>查看分支命令：git branch</p><p>git branch 列出所有本地分支</p><p>git branch -r 列出所有远程分支</p><p>git branch -a 列出所有本地分支和远程分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220939878.png" alt="image-20210926124843275"></p><h4 id="4-7-2-创建分支"><a href="#4-7-2-创建分支" class="headerlink" title="4.7.2 创建分支"></a>4.7.2 创建分支</h4><p>创建分支命令格式：git branch 分支名称</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220940942.png" alt="image-20210926125053711"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415818.png" alt="image-20230622220242853"></p><h4 id="4-7-3-切换分支"><a href="#4-7-3-切换分支" class="headerlink" title="4.7.3 切换分支"></a>4.7.3 切换分支</h4><p>一个仓库中可以有多个分支，切换分支命令格式：git checkout 分支名称</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942424.png" alt="image-20210926125259155"></p><p>注意：在命令行中会显示出当前所在分支，如上图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231415960.png" alt="image-20230622220506722"></p><h4 id="4-7-4-推送至远程仓库分支"><a href="#4-7-4-推送至远程仓库分支" class="headerlink" title="4.7.4 推送至远程仓库分支"></a>4.7.4 推送至远程仓库分支</h4><p>推送至远程仓库分支命令格式：git push 远程仓库简称 分支命令</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220940166.png" alt="image-20210926125628894"></p><p>推送完成后可以查看远程仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942640.png" alt="image-20210926125810878"></p><p>现在只有一个分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231416746.png" alt="image-20230622220608814"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231431771.png" alt="image-20230622220654640"></p><p>现在把本地仓库b1 b2这二个分支推送到远程仓库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231416481.png" alt="image-20230622220852456"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353426.png" alt="image-20230622220939716"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353337.png" alt="image-20230622221157911"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353514.png" alt="image-20230622221137827"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353201.png" alt="image-20230622221341512"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353897.png" alt="image-20230622221455744"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353065.png" alt="image-20230622221530776"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353779.png" alt="image-20230622221700671"></p><p>现在切换到b1分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353235.png" alt="image-20230622221746005"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353195.png" alt="image-20230622221905708"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353192.png" alt="image-20230622222115071"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353497.png" alt="image-20230622222133325"></p><p>现在切换到b2分支</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353649.png" alt="image-20230622222329527"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353976.png" alt="image-20230622222512713"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231353802.png" alt="image-20230622222542938"></p><h4 id="4-7-5-合并分支"><a href="#4-7-5-合并分支" class="headerlink" title="4.7.5 合并分支"></a>4.7.5 合并分支</h4><p>合并分支就是将两个分支的文件进行合并处理，命令格式：git merge 分支命令</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220940294.png" alt="image-20210926130213015"></p><p>注意：分支合并时需注意合并的方向，如上图所示，在Master分支执行操作，结果就是将b3分支合并到Master分支。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231350617.png" alt="image-20230622222945917"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231350720.png" alt="image-20230622223024188"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231350273.png" alt="image-20230622223059486"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231350562.png" alt="image-20230622223222646"></p><p>分支合并时冲突解决</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231350163.png" alt="image-20230622224320824"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231352393.png" alt="image-20230622224544846"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231350914.png" alt="image-20230622224723129"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231352027.png" alt="image-20230622224928064"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231352337.png" alt="image-20230622225003441"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231352609.png" alt="image-20230622225129297"></p><p>现在我们想把b1分支合并到时master分支上</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231352747.png" alt="image-20230622225256272"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231350394.png" alt="image-20230622225406553"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231351536.png" alt="image-20230622225429092"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231351793.png" alt="image-20230622225949005"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231352106.png" alt="image-20230622230013272"></p><h3 id="4-8-标签操作"><a href="#4-8-标签操作" class="headerlink" title="4.8 标签操作"></a>4.8 标签操作</h3><p>Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231416105.png" alt="image-20230623135511437"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417137.png" alt="image-20230623135547818"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417954.png" alt="image-20230623135629090"></p><p>比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。下面是mybatis-plus的标签：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220940125.png" alt="image-20210926130452557"></p><p>在本节中，我们将学习如下和标签相关的命令：</p><ul><li>git tag                                                查看标签</li><li>git tag [name]                                  创建标签</li><li>git push [shortName] [name]       将标签推送至远程仓库</li><li>git checkout -b [branch] [name]   检出标签</li></ul><h4 id="4-8-1-查看标签"><a href="#4-8-1-查看标签" class="headerlink" title="4.8.1 查看标签"></a>4.8.1 查看标签</h4><p>查看标签命令：git tag</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942992.png" alt="image-20210926151333473"></p><h4 id="4-8-2-创建标签"><a href="#4-8-2-创建标签" class="headerlink" title="4.8.2 创建标签"></a>4.8.2 创建标签</h4><p>创建标签命令：git tag 标签名</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942191.png" alt="image-20210926151452581"></p><h4 id="4-8-3-将标签推送至远程仓库"><a href="#4-8-3-将标签推送至远程仓库" class="headerlink" title="4.8.3 将标签推送至远程仓库"></a>4.8.3 将标签推送至远程仓库</h4><p>将标签推送至远程仓库命令：git push 远程仓库简称 标签名</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220946432.png" alt="image-20210926151621286"></p><p>推送完成后可以在远程仓库中查看标签。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417601.png" alt="image-20230623140051655"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417866.png" alt="image-20230623140131440"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417169.png" alt="image-20230623140606812"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417289.png" alt="image-20230623140657782"></p><h4 id="4-8-4-检出标签"><a href="#4-8-4-检出标签" class="headerlink" title="4.8.4 检出标签"></a>4.8.4 检出标签</h4><p>检出标签时需要新建一个分支来指向某个标签，检出标签的命令格式：git checkout -b 分支名 标签名</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942807.png" alt="image-20210926152111514"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417929.png" alt="image-20230623140935571"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231417913.png" alt="image-20230623141024840"></p><p>标签与分支的区别 ：标签是静态的  比如照相    照下就不会在发生变化   分支可以接着修改</p><h2 id="5-在IDEA中使用Git"><a href="#5-在IDEA中使用Git" class="headerlink" title="5. 在IDEA中使用Git"></a>5. 在IDEA中使用Git</h2><p>通过Git命令可以完成Git相关操作，为了简化操作过程，我们可以在IEDA中配置Git，配置好后就可以在IDEA中通过图形化的方式来操作Git。</p><h3 id="5-1-在IDEA中配置Git"><a href="#5-1-在IDEA中配置Git" class="headerlink" title="5.1 在IDEA中配置Git"></a>5.1 在IDEA中配置Git</h3><p>在IDEA中使用Git，本质上还是使用的本地安装的Git软件，所以需要提前安装好Git并在IDEA中配置Git。</p><p>Git安装目录：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942600.png" alt="image-20210926152847948"></p><p>解释说明：</p><blockquote><p>git.exe：Git安装目录下的可执行文件，前面执行的git命令，其实就是执行的这个文件</p></blockquote><p>IDEA中的配置：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942327.png" alt="image-20210926152950420"></p><p>说明：如果Git安装在默认目录中（C:\Program Files\Git），则IDEA中无需再手动配置，直接就可以使用。</p><h3 id="5-2-获取Git仓库"><a href="#5-2-获取Git仓库" class="headerlink" title="5.2 获取Git仓库"></a>5.2 获取Git仓库</h3><p>在IDEA中获取Git仓库有两种方式：</p><ul><li>本地初始化仓库，本质就是执行 git init 命令</li><li>从远程仓库克隆，本质就是执行 git clone 命令</li></ul><h4 id="5-2-1-本地初始化仓库"><a href="#5-2-1-本地初始化仓库" class="headerlink" title="5.2.1 本地初始化仓库"></a>5.2.1 本地初始化仓库</h4><p>在IDEA中通过如下操作可以在本地初始化一个本地仓库，其实底层就是执行的 git init 命令。操作过程如下：</p><p>1）依次选择菜单【VCS】—【Import into Version Control】—【Create Git Repository】</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942407.png" alt="image-20210926153806414"></p><p>2）在弹出的【Create Git Repository】对话框中选择当前项目根目录，点击【OK】按钮：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220942943.png" alt="image-20210926154201744"></p><p>操作完成后可以看到当前项目根目录下出现了.git隐藏目录：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220946911.png" alt="image-20210926154757082"></p><p>操作完成后可以在IDEA的工具栏中看到Git的相关操作图标：<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220957735.png" alt="image-20210926154933876"></p><h4 id="5-2-2-从远程仓库克隆"><a href="#5-2-2-从远程仓库克隆" class="headerlink" title="5.2.2 从远程仓库克隆"></a>5.2.2 从远程仓库克隆</h4><p>在IDEA中从远程仓库克隆本质就是执行的 git clone 命令，具体操作过程如下：</p><p>1）在IDEA开始窗口中点击【Get from Version Control】</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943703.png" alt="image-20210926155434202"></p><p>2）在弹出的【Get from Version Control】窗口中输入远程仓库的URL地址和对应的本地仓库存放目录，点击【Clone】按钮进行仓库克隆操作</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943592.png" alt="image-20210926155750107"></p><p>另一种打开方式</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601291.png" alt="image-20230623144315913"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601092.png" alt="image-20230623144515661"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601691.png" alt="image-20230623144627534"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601131.png" alt="image-20230623144821303"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601747.png" alt="image-20230623144847752"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601901.png" alt="image-20230623144903559"></p><h3 id="5-3-Git忽略文件"><a href="#5-3-Git忽略文件" class="headerlink" title="5.3 Git忽略文件"></a>5.3 Git忽略文件</h3><p>在Git工作区中有一个特殊的文件 .gitignore，通过此文件可以指定工作区中的哪些文件不需要Git管理。我们在码云上创建Git远程仓库时可以指定生成此文件，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943671.png" alt="image-20210926161050169"></p><p>创建完成后效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943639.png" alt="image-20210926161233052"></p><p>解释说明：</p><blockquote><p>1）我们在使用Git管理项目代码时，并不是所有文件都需要Git管理，例如Java项目中编译的.class文件、开发工具自带的配置文件等，这些文件没有必要交给Git管理，所以也就不需要提交到Git版本库中</p><p>2）注意忽略文件的名称是固定的，不能修改</p><p>3）添加到忽略列表中的文件后续Git工具就会忽略它</p></blockquote><p>一个参考的.gitignore文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">logs</span><br><span class="line">rebel.xml</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">log.path_IS_UNDEFINED</span><br><span class="line">.DS_Store</span><br><span class="line">offline_user.md</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br></pre></td></tr></table></figure><h3 id="5-4-本地仓库操作"><a href="#5-4-本地仓库操作" class="headerlink" title="5.4 本地仓库操作"></a>5.4 本地仓库操作</h3><p>本地仓库操作：</p><ul><li>将文件加入暂存区，本质就是执行 git add 命令</li><li>将暂存区的文件提交到版本库，本质就是执行 git commit 命令</li><li>查看日志，本质就是执行 git log 命令</li></ul><h4 id="5-4-1-将文件加入暂存区"><a href="#5-4-1-将文件加入暂存区" class="headerlink" title="5.4.1 将文件加入暂存区"></a>5.4.1 将文件加入暂存区</h4><p>当在Git工作区新增文件或者对已有文件修改后，就需要将文件的修改加入暂存区，具体操作如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943447.png" alt="image-20210926162515597"></p><h4 id="5-4-2-将暂存区文件提交到版本库"><a href="#5-4-2-将暂存区文件提交到版本库" class="headerlink" title="5.4.2 将暂存区文件提交到版本库"></a>5.4.2 将暂存区文件提交到版本库</h4><p>将暂存区文件提交到版本库，可以选择一个文件进行提交，也可以选择整个项目提交多个文件。在IEDA中对文件的提交进行了简化操作，也就是如果文件修改后，无需再加入暂存区，可以直接提交。</p><p>1）提交一个文件：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943759.png" alt="image-20210926162809740"></p><p>可以看到，如果选中一个文件提交，则菜单名称为【Commit File…】</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601828.png" alt="image-20230623145839186"></p><p>2）提交多个文件：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943943.png" alt="image-20210926162843891"></p><p>可以看到，如果提交多个文件，则菜单名称为【Commit Directory…】</p><p>由于提交操作属于高频操作，所以为了进一步方便操作，在IDEA的工具栏中提供了提交操作的快捷按钮：<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220957455.png" alt="image-20210926163535277"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601580.png" alt="image-20230623150112848"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601638.png" alt="image-20230623150311657"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306231601262.png" alt="image-20230623150645021"></p><h4 id="5-4-3-查看日志"><a href="#5-4-3-查看日志" class="headerlink" title="5.4.3 查看日志"></a>5.4.3 查看日志</h4><p>查看日志，既可以查看整个仓库的提交日志，也可以查看某个文件的提交日志。</p><p>1）查看整个项目的提交日志：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943079.png" alt="image-20210926163902184"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943751.png" alt="image-20210926164138430"></p><p>2）查看某个文件的提交日志</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943599.png" alt="image-20210926164210056"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943535.png" alt="image-20210926164233935"></p><h3 id="5-5-远程仓库操作"><a href="#5-5-远程仓库操作" class="headerlink" title="5.5 远程仓库操作"></a>5.5 远程仓库操作</h3><p>远程仓库操作：</p><ul><li>查看远程仓库，本质就是执行 git remote 命令</li><li>添加远程仓库，本质就是执行 git remote add 命令</li><li>推送至远程仓库，本质就是执行 git push 命令</li><li>从远程仓库拉取，本质就是执行 git pull 命令</li></ul><h4 id="5-5-1-查看远程仓库"><a href="#5-5-1-查看远程仓库" class="headerlink" title="5.5.1 查看远程仓库"></a>5.5.1 查看远程仓库</h4><p>操作过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943183.png" alt="image-20210926165935756"></p><p>在弹出的【Git Remotes】窗口中可以看到配置的远程仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220944247.png" alt="image-20210926170143160"></p><h4 id="5-5-2-添加远程仓库"><a href="#5-5-2-添加远程仓库" class="headerlink" title="5.5.2 添加远程仓库"></a>5.5.2 添加远程仓库</h4><p>一个本地仓库可以配置多个远程仓库，在【Git Remotes】窗口中点击【+】来添加一个新的远程仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220943487.png" alt="image-20210926170653126"></p><h4 id="5-5-3-推送至远程仓库"><a href="#5-5-3-推送至远程仓库" class="headerlink" title="5.5.3 推送至远程仓库"></a>5.5.3 推送至远程仓库</h4><p>可以通过如下操作将本地仓库文件推送至远程仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220944901.png" alt="image-20210926170908769"></p><p>在弹出的【Push Commits】窗口中可以看到本次推送的文件，点击【Push】按钮即可推送至远程仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220944079.png" alt="image-20210926171058705"></p><p>由于推送至远程仓库操作属于高频操作，所以可以通过IDEA工具栏中的提交快捷按钮同时完成提交和推送：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220947696.png" alt="image-20210926171408649"></p><p>点击【Commit and Push…】按钮同时完成提交和推送操作</p><h4 id="5-5-4-从远程仓库拉取"><a href="#5-5-4-从远程仓库拉取" class="headerlink" title="5.5.4 从远程仓库拉取"></a>5.5.4 从远程仓库拉取</h4><p>可以通过如下操作从远程仓库拉取：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220938976.png" alt="image-20210926171646041"></p><p>由于从远程仓库拉取文件属于高频操作，所以在IDEA的工具栏中提供了对应的快捷按钮：<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220956567.png" alt="image-20210926171919288"></p><p>在弹出的【Update Project】窗口中点击【OK】：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937856.png" alt="image-20210926171950911"></p><h3 id="5-6-分支操作"><a href="#5-6-分支操作" class="headerlink" title="5.6 分支操作"></a>5.6 分支操作</h3><p>分支操作：</p><ul><li>查看分支，本质就是执行 git branch 命令</li><li>创建分支，本质就是执行 git branch 分支名 命令</li><li>切换分支，本质就是执行 git checkout 命令</li><li>将分支推送到远程仓库，本质就是执行 git push 命令</li><li>合并分支，本质就是执行 git merge 命令</li></ul><h4 id="5-6-1-查看分支"><a href="#5-6-1-查看分支" class="headerlink" title="5.6.1 查看分支"></a>5.6.1 查看分支</h4><p>可以通过如下操作查看分支：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937903.png" alt="image-20210926172752562"></p><p>在弹出的窗口中可以看到本地分支和远程分支：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937215.png" alt="image-20210926172903493"></p><p>由于分支操作属于高频操作，所以在IDEA的状态栏中提供了分支操作的快捷按钮：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937031.png" alt="image-20210926173622605"></p><p>点击【master】快捷按钮即可弹出【Git Branches】分支窗口：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937727.png" alt="image-20210926173744979"></p><h4 id="5-6-2-创建分支"><a href="#5-6-2-创建分支" class="headerlink" title="5.6.2 创建分支"></a>5.6.2 创建分支</h4><p>在【Git Branches】分支窗口中点击【New Branch】，弹出如下窗口：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937078.png" alt="image-20210926173903894"></p><p>在弹出的【Create New Branch】窗口中输入新分支的名称，点击【Create】按钮完成分支创建</p><h4 id="5-6-3-切换分支"><a href="#5-6-3-切换分支" class="headerlink" title="5.6.3 切换分支"></a>5.6.3 切换分支</h4><p>通过如下操作可以切换分支：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937456.png" alt="image-20210926174358500"></p><h4 id="5-6-4-将分支推送到远程仓库"><a href="#5-6-4-将分支推送到远程仓库" class="headerlink" title="5.6.4 将分支推送到远程仓库"></a>5.6.4 将分支推送到远程仓库</h4><p>通过如下操作可以将分支推送到远程仓库：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220937952.png" alt="image-20210926175004502"></p><h4 id="5-6-5-合并分支"><a href="#5-6-5-合并分支" class="headerlink" title="5.6.5 合并分支"></a>5.6.5 合并分支</h4><p>通过下面操作可以进行分支的合并：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/Git/202306220936746.png" alt="image-20210926175216197"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖-Day06</title>
      <link href="/archives/5.html"/>
      <url>/archives/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖-Day06"><a href="#瑞吉外卖-Day06" class="headerlink" title="瑞吉外卖-Day06"></a>瑞吉外卖-Day06</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>用户地址簿功能</li><li>菜品展示</li><li>购物车</li><li>下单</li></ul><h2 id="1-用户地址簿功能"><a href="#1-用户地址簿功能" class="headerlink" title="1. 用户地址簿功能"></a>1. 用户地址簿功能</h2><h3 id="1-1-需求分析"><a href="#1-1-需求分析" class="headerlink" title="1.1 需求分析"></a>1.1 需求分析</h3><p>地址簿，指的是移动端消费者用户的地址信息，用户登录成功后可以维护自己的地址信息。同一个用户可以有多个地址信息，但是只能有一个<strong>默认地址</strong>。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031416420.png" alt="image-20210812191332892" style="zoom: 67%;" />  <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031425691.png" alt="image-20210812191822693" style="zoom:67%;" /> <p>对于地址簿管理，我们需要实现以下几个功能： </p><ul><li>新增地址</li><li>地址列表查询</li><li>设置默认地址</li><li>编辑地址</li><li>删除地址</li></ul><h3 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h3><p>用户的地址信息会存储在address_book表，即地址簿表中。具体表结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031416731.png" alt="image-20210812192228678"> </p><p>这里面有一个字段is_default，实际上我们在设置默认地址时，只需要更新这个字段就可以了。</p><h3 id="1-3-导入功能代码"><a href="#1-3-导入功能代码" class="headerlink" title="1.3 导入功能代码"></a>1.3 导入功能代码</h3><p>对于这一类的单表的增删改查，我们已经写过很多了，基本的开发思路都是一样的，那么本小节的用户地址簿管理的增删改查功能，我们就不再一一实现了，基本的代码我们都已经提供了，直接导入进来，做一个测试即可。</p><p>对于下面的地址管理的代码，我们可以直接从资料拷贝，也可以直接从下面的讲义中复制。</p><p><strong>1). 实体类 AddressBook（直接从课程资料中导入即可）</strong></p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址簿</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressBook</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String consignee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性别 0 女 1 男</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省级区划编号</span></span><br><span class="line">    <span class="keyword">private</span> String provinceCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省级名称</span></span><br><span class="line">    <span class="keyword">private</span> String provinceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//市级区划编号</span></span><br><span class="line">    <span class="keyword">private</span> String cityCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//市级名称</span></span><br><span class="line">    <span class="keyword">private</span> String cityName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//区级区划编号</span></span><br><span class="line">    <span class="keyword">private</span> String districtCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//区级名称</span></span><br><span class="line">    <span class="keyword">private</span> String districtName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//详细地址</span></span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标签</span></span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否默认 0 否 1是</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDefault;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建人</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改人</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否删除</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). Mapper接口 AddressBookMapper（直接从课程资料中导入即可）</strong></p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.AddressBook;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddressBookMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;AddressBook&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3). 业务层接口 AddressBookService（直接从课程资料中导入即可）</strong></p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.AddressBook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddressBookService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;AddressBook&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4). 业务层实现类 AddressBookServiceImpl（直接从课程资料中导入即可）</strong></p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.AddressBookMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.AddressBookService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressBookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;AddressBookMapper, AddressBook&gt; <span class="keyword">implements</span> <span class="title class_">AddressBookService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 控制层 AddressBookController（直接从课程资料中导入即可）</strong></p><p>所属包: com.itheima.reggie.controller</p><p>controller主要开发的功能: </p><p>A. 新增地址逻辑说明： </p><ul><li>需要记录当前是哪个用户的地址(关联当前登录用户)</li></ul><p>B. 设置默认地址 </p><ul><li><p>每个用户可以有很多地址，但是默认地址只能有一个 ；</p></li><li><p>先将该用户所有地址的is_default更新为0 , 然后将当前的设置的默认地址的is_default设置为1</p></li></ul><p>C. 根据ID查询地址</p><p>D. 查询默认地址</p><ul><li>根据当前登录用户ID 以及 is_default进行查询，查询当前登录用户is_default为1的地址信息</li></ul><p>E. 查询指定用户的全部地址</p><ul><li>根据当前登录用户ID，查询所有的地址列表</li></ul><p>代码实现如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.common.BaseContext;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.common.R;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.AddressBookService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址簿管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/addressBook&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressBookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;AddressBook&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        addressBookService.save(addressBook);</span><br><span class="line">        <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;AddressBook&gt; <span class="title function_">setDefault</span><span class="params">(<span class="meta">@RequestBody</span> AddressBook addressBook)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line">        LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        wrapper.set(AddressBook::getIsDefault, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 0 where user_id = ?</span></span><br><span class="line">        addressBookService.update(wrapper);</span><br><span class="line"></span><br><span class="line">        addressBook.setIsDefault(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//SQL:update address_book set is_default = 1 where id = ?</span></span><br><span class="line">        addressBookService.updateById(addressBook);</span><br><span class="line">        <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (addressBook != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询默认地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;default&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;AddressBook&gt; <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());</span><br><span class="line">        queryWrapper.eq(AddressBook::getIsDefault, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? and is_default = 1</span></span><br><span class="line">        <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == addressBook) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;没有找到该对象&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.success(addressBook);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定用户的全部地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;List&lt;AddressBook&gt;&gt; <span class="title function_">list</span><span class="params">(AddressBook addressBook)</span> &#123;</span><br><span class="line">        addressBook.setUserId(BaseContext.getCurrentId());</span><br><span class="line">        log.info(<span class="string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件构造器</span></span><br><span class="line">        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="literal">null</span> != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());</span><br><span class="line">        queryWrapper.orderByDesc(AddressBook::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SQL:select * from address_book where user_id = ? order by update_time desc</span></span><br><span class="line">        <span class="keyword">return</span> R.success(addressBookService.list(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-功能测试"><a href="#1-4-功能测试" class="headerlink" title="1.4 功能测试"></a>1.4 功能测试</h3><p>代码导入进来，并且去阅读了一下地址管理各个功能的逻辑实现，接下来，我们就可以启动项目，进行一个测试。测试过程中，通过debug断点调试观察服务端程序的执行过程，在浏览器中使用调试工具查看页面和服务端的交互过程和请求响应数据。</p><p><strong>1). 新增</strong></p><p>填写表单数据，点击保存地址，查看网络请求。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031416915.png" alt="image-20210812201636567"> </p><p>测试完毕之后，检查数据库中的数据，是否正常插入。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031416275.png" alt="image-20210812201845336"> </p><p><strong>2). 列表查询</strong></p><p>当新增地址完成后，页面会再次发送一个请求，来查询该用户的所有地址列表，在界面进行展示。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031416459.png" alt="image-20210812202430677"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031426539.png" alt="image-20210812202534169"> </p><p><strong>3). 设置默认</strong></p><p>在地址列表页面中，勾选 “设为默认地址” ，此时会发送PUT请求，来设置默认地址。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031416571.png" alt="image-20210812202841250"> </p><p>测试完毕后，我们再次查看数据库表中的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031417595.png" alt="image-20210812203123499"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306202223789.png" alt="image-20230620222239935"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212045455.png" alt="image-20230620222353179"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212045650.png" alt="image-20230620222406985"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212045703.png" alt="image-20230620222554545"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212045816.png" alt="image-20230620222654927"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212045751.png" alt="image-20230620222707549"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212046351.png" alt="image-20230620223130060"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212046343.png" alt="image-20230620223203483"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212047231.png" alt="image-20230620223304234"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212047359.png" alt="image-20230620223336450"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212047567.png" alt="image-20230620223356608"></p><p>重新添加一条</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212047183.png" alt="image-20230620225322245"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212047983.png" alt="image-20230620225345514"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212047759.png" alt="image-20230620225404535"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212047991.png" alt="image-20230620225418698"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048007.png" alt="image-20230620225433208"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048375.png" alt="image-20230620225518580"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048679.png" alt="image-20230620225602517"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048176.png" alt="image-20230620225620581"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048832.png" alt="image-20230620225722234"></p><p>为什么报404</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048472.png" alt="image-20230620222515688"></p><p>在增加一条</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048712.png" alt="image-20230620225832213"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212048616.png" alt="image-20230620230012314"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212049303.png" alt="image-20230620230108254"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212049336.png" alt="image-20230620230123675"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212049175.png" alt="image-20230620230149484"></p><h2 id="2-菜品展示"><a href="#2-菜品展示" class="headerlink" title="2. 菜品展示"></a>2. 菜品展示</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>用户登录成功后跳转到系统首页，在首页需要根据分类来展示菜品和套餐。如果菜品设置了口味信息，需要展示<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031427907.png" alt="image-20210812205330291" style="zoom:80%;" />按钮，否则显示<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031427243.png" alt="image-20210812205346846" style="zoom:80%;" />按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031417036.png" alt="image-20210812210328249"> </p><h3 id="2-2-前端页面分析"><a href="#2-2-前端页面分析" class="headerlink" title="2.2 前端页面分析"></a>2.2 前端页面分析</h3><p>在开发代码之前，需要梳理一下前端页面和服务端的交互过程：</p><p><strong>1). 页面(front&#x2F;index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212049159.png" alt="image-20230621105602786"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212049783.png" alt="image-20230621105932157"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212104486.png" alt="image-20230621105957582"></p><p>请求已经发了 数据响应了  可是并没有展示在页面上</p><p>这是因为这个页面又发送了另一个请求  这个请求是加载我们的购物车数据   而我们的购物车我们还没有开始写</p><p>所以他报了一个404   所以我们的页面没法正常的去展示</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212049546.png" alt="image-20230621110700253"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212104711.png" alt="image-20230621110722170"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031417292.png" alt="image-20210812215624794"> </p><p>该功能在之前的业务开发中，我们都已经实现了。通过请求响应的数据，我们也可以看到数据是可以正确获取到的。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031417516.png" alt="image-20210812221107947"> </p><p>注意：首页加载时，不仅发送请求获取分类列表，还发送了一次ajax请求用于加载购物车数据，而这两次请求必须全部成功，页面才可以正常渲染，而当前购物车列表查询功能还未实现(报404)，所以列表目前并未渲染。此处可以将这次请求的地址暂时修改一下，从静态json文件获取数据，等后续开发购物车功能时再修改回来，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212050720.png" alt="image-20230621111940722"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212104536.png" alt="image-20230621112231617"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031417452.png" alt="image-20210812221835628" style="zoom:80%;" /> <p>重新登录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212050160.png" alt="image-20230621112657057"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212050672.png" alt="image-20230621112820021"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212050655.png" alt="image-20230621112753028"></p><p>修改之后，我们再次测试：  </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031417996.png" alt="image-20210812222713700"> </p><p>目前该部分的功能我们已经调通，左侧的分类菜单，和右侧的菜品信息我们都可以看到，后续我们只需要将购物车列表的数据改成调用服务端接口查询即可。</p><p><strong>2). 页面发送ajax请求，获取第一个分类下的菜品或者套餐</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031418716.png" alt="image-20230403141820682"></p><p>第一次请求</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212050367.png" alt="image-20230621111049556"></p><p>第二次请求</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212106215.png" alt="image-20230621111217551"></p><p>两次请求都必须发送成功  页面才能渲染成功  才能够成功加载并展示</p><p>A. 根据分类ID查询套餐列表：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031418043.png" alt="image-20210812224810551" style="zoom:80%;" /> <p>B. 根据分类ID查询菜品列表： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031419059.png" alt="image-20210812224624459" style="zoom:80%;" /> <p>异步请求，查询分类对应的菜品列表，功能我们已经实现了，但是我们之前查询的只是菜品的基本信息，不包含菜品的口味信息。所以在前端界面中，我们看不到选择菜品分类的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031419683.png" alt="image-20210812231220115"> </p><p>经过上述的分析，我们可以看到，服务端我们主要提供两个方法， 分别用来：</p><p>A. 根据分类ID查询菜品列表(包含菜品口味列表), 具体请求信息如下: </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;dish&#x2F;list</td></tr><tr><td>请求参数</td><td>?categoryId&#x3D;1397844263642378242&amp;status&#x3D;1</td></tr></tbody></table><p><font color='red'>该功能在服务端已经实现，我们需要修改此方法，在原有方法的基础上增加查询菜品的口味信息。</font></p><p>B. 根据分类ID查询套餐列表, 具体请求信息如下: </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;setmeal&#x2F;list</td></tr><tr><td>请求参数</td><td>?categoryId&#x3D;1397844263642378242&amp;status&#x3D;1</td></tr></tbody></table><p><font color='red'>该功能在服务端并未实现。</font></p><h3 id="2-3-代码开发"><a href="#2-3-代码开发" class="headerlink" title="2.3 代码开发"></a>2.3 代码开发</h3><h4 id="2-3-1-查询菜品方法修改"><a href="#2-3-1-查询菜品方法修改" class="headerlink" title="2.3.1 查询菜品方法修改"></a>2.3.1 查询菜品方法修改</h4><p>由于之前我们实现的根据分类查询菜品列表，仅仅查询了菜品的基本信息，未查询菜品口味信息，而移动端用户在点餐时，是需要选择口味信息的，所以我们需要对之前的代码实现进行完善，那么如何完善呢？</p><p>我们需要修改DishController的list方法，原来此方法的返回值类型为：R&lt;List<Dish>&gt;。为了满足移动端对数据的要求(菜品基本信息和菜品对应的口味信息)，现在需要将方法的返回值类型改为：R&lt;List<DishDto>&gt; ，因为在DishDto中封装了菜品对应的口味信息： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031419931.png" alt="image-20210812231825043" style="zoom:67%;" /> <p><strong>代码逻辑:</strong> </p><p>A. 根据分类ID查询，查询目前正在启售的菜品列表 (已实现)</p><p>B. 遍历菜品列表，并查询菜品的分类信息及菜品的口味列表</p><p>C. 组装数据DishDto，并返回</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;List&lt;DishDto&gt;&gt; <span class="title function_">list</span><span class="params">(Dish dish)</span>&#123;</span><br><span class="line">        <span class="comment">//构造查询条件</span></span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(dish.getCategoryId() != <span class="literal">null</span> ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">        <span class="comment">//添加条件，查询状态为1（起售状态）的菜品</span></span><br><span class="line">        queryWrapper.eq(Dish::getStatus,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//添加排序条件</span></span><br><span class="line">        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">        List&lt;DishDto&gt; dishDtoList = list.stream().map((item) -&gt; &#123;</span><br><span class="line">            <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line">            BeanUtils.copyProperties(item,dishDto);</span><br><span class="line"></span><br><span class="line">            <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();<span class="comment">//分类id</span></span><br><span class="line">            <span class="comment">//根据id查询分类对象</span></span><br><span class="line">            <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line">            <span class="keyword">if</span>(category != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">                dishDto.setCategoryName(categoryName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前菜品的id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> item.getId();</span><br><span class="line">            LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">            lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId);</span><br><span class="line">            <span class="comment">//SQL:select * from dish_flavor where dish_id = ?</span></span><br><span class="line">            List&lt;DishFlavor&gt; dishFlavorList = dishFlavorService.list(lambdaQueryWrapper);</span><br><span class="line">            dishDto.setFlavors(dishFlavorList);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dishDto;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> R.success(dishDtoList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212050959.png" alt="image-20230621114500582"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212050231.png" alt="image-20230621114546221"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212106151.png" alt="image-20230621114724934"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051919.png" alt="image-20230621114825113"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051391.png" alt="image-20230621114925060"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051527.png" alt="image-20230621115020170"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212106799.png" alt="image-20230621115058259"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051534.png" alt="image-20230621115541254"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212106871.png" alt="image-20230621115258570"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051222.png" alt="image-20230621115348075"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051190.png" alt="image-20230621115411277"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051287.png" alt="image-20230621115516659"></p><h4 id="2-3-2-根据分类ID查询套餐"><a href="#2-3-2-根据分类ID查询套餐" class="headerlink" title="2.3.2 根据分类ID查询套餐"></a>2.3.2 根据分类ID查询套餐</h4><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051887.png" alt="image-20230621115711197"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212051831.png" alt="image-20230621115800360"></p><p>在SetmealController中创建list方法，根据条件查询套餐数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据条件查询套餐数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> setmeal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;List&lt;Setmeal&gt;&gt; <span class="title function_">list</span><span class="params">(Setmeal setmeal)</span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(setmeal.getCategoryId() != <span class="literal">null</span>,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">    queryWrapper.eq(setmeal.getStatus() != <span class="literal">null</span>,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">    queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-功能测试"><a href="#2-4-功能测试" class="headerlink" title="2.4 功能测试"></a>2.4 功能测试</h3><p>把菜品展示的功能代码完善完成之后，我们重新启动服务，来测试一个菜品展示的功能。测试过程中可以使用浏览器的监控工具查看页面和服务端的数据交互细节。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031419491.png" alt="image-20210813175554516"> </p><p>点击分类，根据分类查询菜品列表&#x2F;套餐列表:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031419395.png" alt="image-20210813175835304"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212052907.png" alt="image-20230621120748044"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212052399.png" alt="image-20230621120818037"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212052182.png" alt="image-20230621120859357"></p><h2 id="3-购物车"><a href="#3-购物车" class="headerlink" title="3. 购物车"></a>3. 购物车</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>移动端用户可以将菜品或者套餐添加到购物车。对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车;对于套餐来说，可以直接点击<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031420675.png" alt="image-20210813181916235" style="zoom:67%;" />将当前套餐加入购物车。在购物车中可以修改菜品和套餐的数量，也可以清空购物车。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031420035.png" alt="image-20210813182828045"> </p><p>这里面我们需要实现的功能包括: </p><p>1). 添加购物车</p><p>2). 查询购物车</p><p>3). 清空购物车</p><h3 id="3-2-数据模型"><a href="#3-2-数据模型" class="headerlink" title="3.2 数据模型"></a>3.2 数据模型</h3><p>用户的购物车数据，也是需要保存在数据库中的，购物车对应的数据表为shopping_cart表，具体表结构如下：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031420483.png" alt="image-20210813183334933" style="zoom:80%;" /> <p>说明： </p><ul><li>购物车数据是关联用户的，在表结构中，我们需要记录，每一个用户的购物车数据是哪些</li><li>菜品列表展示出来的既有套餐，又有菜品，如果APP端选择的是套餐，就保存套餐ID(setmeal_id)，如果APP端选择的是菜品，就保存菜品ID(dish_id)</li><li>对同一个菜品&#x2F;套餐，如果选择多份不需要添加多条记录，增加数量number即可</li></ul><p><strong>最终shopping_cart表中存储的数据示例:</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031420819.png" alt="image-20210815183440051" style="zoom:80%;" /> <h3 id="3-3-前端页面分析"><a href="#3-3-前端页面分析" class="headerlink" title="3.3 前端页面分析"></a>3.3 前端页面分析</h3><p>在开发代码之前，需要梳理一下购物车操作时前端页面和服务端的交互过程：</p><p>1). 点击 “加入购物车” 或者 “+” 按钮，页面发送ajax请求，请求服务端，将菜品或者套餐添加到购物车</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031420091.png" alt="image-20210813185414102"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031420419.png" alt="image-20210813185731809"> </p><p>2). 点击购物车图标，页面发送ajax请求，请求服务端查询购物车中的菜品和套餐</p><p>此时，我们就需要将查询购物车的代码放开，不用再加载静态的json数据了。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031420354.png" alt="image-20210813190814766" style="zoom:80%;" /> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031421371.png" alt="image-20210813191237556" style="zoom:70%;" /> <p>3). 点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031421066.png" alt="image-20210813192012994"> </p><p>经过上述的分析，我们可以看到，对于购物车的功能，我们主要需要开发以下几个功能，具体的请求信息如下：</p><p><strong>1). 加入购物车</strong></p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;shoppingCart&#x2F;add</td></tr><tr><td>请求参数</td><td>json格式</td></tr></tbody></table><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">菜品数据<span class="punctuation">:</span> </span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span><span class="number">118</span><span class="punctuation">,</span><span class="attr">&quot;dishFlavor&quot;</span><span class="punctuation">:</span><span class="string">&quot;不要蒜,微辣&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dishId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1397851099502260226&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;全家福&quot;</span><span class="punctuation">,</span><span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="string">&quot;a53a4e6a-3b83-4044-87f9-9d49b30a8fdc.jpg&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">套餐数据<span class="punctuation">:</span> </span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span><span class="number">38</span><span class="punctuation">,</span><span class="attr">&quot;setmealId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1423329486060957698&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;营养超值工作餐&quot;</span><span class="punctuation">,</span><span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="string">&quot;9cd7a80a-da54-4f46-bf33-af3576514cec.jpg&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>2). 查询购物车列表</strong></p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;shoppingCart&#x2F;list</td></tr></tbody></table><p><strong>3). 清空购物车功能</strong></p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>DELETE</td></tr><tr><td>请求路径</td><td>&#x2F;shoppingCart&#x2F;clean</td></tr></tbody></table><h3 id="3-4-准备工作"><a href="#3-4-准备工作" class="headerlink" title="3.4 准备工作"></a>3.4 准备工作</h3><p>分析完毕购物车的业务需求和实现思路之后，在开发业务功能前，先将需要用到的类和接口基本结构创建好：</p><p><strong>1). 实体类 ShoppingCart（直接从课程资料中导入即可）</strong></p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 购物车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCart</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品id</span></span><br><span class="line">    <span class="keyword">private</span> Long dishId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//套餐id</span></span><br><span class="line">    <span class="keyword">private</span> Long setmealId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//口味</span></span><br><span class="line">    <span class="keyword">private</span> String dishFlavor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). Mapper接口 ShoppingCartMapper</strong></p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.ShoppingCart;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShoppingCartMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;ShoppingCart&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3). 业务层接口 ShoppingCartService</strong></p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.ShoppingCart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShoppingCartService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;ShoppingCart&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4). 业务层实现类 ShoppingCartServiceImpl</strong></p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.ShoppingCart;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.ShoppingCartMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.ShoppingCartService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCartServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShoppingCartMapper, ShoppingCart&gt; <span class="keyword">implements</span> <span class="title class_">ShoppingCartService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 控制层 ShoppingCartController</strong></p><p>所属包: com.itheima.reggie.controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.ShoppingCartService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 购物车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/shoppingCart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShoppingCartController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShoppingCartService shoppingCartService;</span><br><span class="line"> </span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure><h3 id="3-5-代码开发"><a href="#3-5-代码开发" class="headerlink" title="3.5 代码开发"></a>3.5 代码开发</h3><h4 id="3-5-1-添加购物车"><a href="#3-5-1-添加购物车" class="headerlink" title="3.5.1 添加购物车"></a>3.5.1 添加购物车</h4><p>在ShoppingCartController中创建add方法，来完成添加购物车的逻辑实现，具体的逻辑如下： </p><p>A. 获取当前登录用户，为购物车对象赋值</p><p>B. 根据当前登录用户ID 及 本次添加的菜品ID&#x2F;套餐ID，查询购物车数据是否存在</p><p>C. 如果已经存在，就在原来数量基础上加1</p><p>D. 如果不存在，则添加到购物车，数量默认就是1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加购物车</span><br><span class="line"> * @param shoppingCart</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;/add&quot;)</span><br><span class="line">public R&lt;ShoppingCart&gt; add(@RequestBody ShoppingCart shoppingCart)&#123;</span><br><span class="line">    </span><br><span class="line">    log.info(&quot;购物车数据:&#123;&#125;&quot;,shoppingCart);</span><br><span class="line">   </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212052191.png" alt="image-20230621131038055"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212052254.png" alt="image-20230621131703411"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212052990.png" alt="image-20230621131721883"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212053023.png" alt="image-20230621131744479"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212053303.png" alt="image-20230621131843997"></p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加购物车</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> shoppingCart</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;ShoppingCart&gt; <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;购物车数据:&#123;&#125;&quot;</span>,shoppingCart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置用户id，指定当前是哪个用户的购物车数据</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line">    shoppingCart.setUserId(currentId);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> shoppingCart.getDishId();</span><br><span class="line"></span><br><span class="line">    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(ShoppingCart::getUserId,currentId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dishId != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//添加到购物车的是菜品</span></span><br><span class="line">        queryWrapper.eq(ShoppingCart::getDishId,dishId);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//添加到购物车的是套餐</span></span><br><span class="line">        queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前菜品或者套餐是否在购物车中</span></span><br><span class="line">    <span class="comment">//SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ?</span></span><br><span class="line">    <span class="type">ShoppingCart</span> <span class="variable">cartServiceOne</span> <span class="operator">=</span> shoppingCartService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cartServiceOne != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果已经存在，就在原来数量基础上加一</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> cartServiceOne.getNumber();</span><br><span class="line">        cartServiceOne.setNumber(number + <span class="number">1</span>);</span><br><span class="line">        shoppingCartService.updateById(cartServiceOne);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果不存在，则添加到购物车，数量默认就是一</span></span><br><span class="line">        shoppingCart.setNumber(<span class="number">1</span>);</span><br><span class="line">        shoppingCart.setCreateTime(LocalDateTime.now());</span><br><span class="line">        shoppingCartService.save(shoppingCart);</span><br><span class="line">        cartServiceOne = shoppingCart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R.success(cartServiceOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212053895.png" alt="image-20230621132905213"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212053031.png" alt="image-20230621133036725"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212053367.png" alt="image-20230621133058564"></p><p>8次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212053039.png" alt="image-20230621133440359"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212053903.png" alt="image-20230621133531383"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212054447.png" alt="image-20230621133726148"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212054662.png" alt="image-20230621133910329"></p><p>原来是空的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212054926.png" alt="image-20230621133327027"></p><p>现在加了购物车后</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212054063.png" alt="image-20230621133620692"></p><p>在添加一个</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212054127.png" alt="image-20230621135044279"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212054223.png" alt="image-20230621135114587"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212054862.png" alt="image-20230621135206247"></p><p>在添加一个套餐</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212055311.png" alt="image-20230621135339389"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212055383.png" alt="image-20230621135421482"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212108870.png" alt="image-20230621135458024"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212055662.png" alt="image-20230621135516344"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212055103.png" alt="image-20230621135632156"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212055558.png" alt="image-20230621135657827"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212055518.png" alt="image-20230621135717182"></p><h4 id="3-5-2-查询购物车"><a href="#3-5-2-查询购物车" class="headerlink" title="3.5.2 查询购物车"></a>3.5.2 查询购物车</h4><p>在ShoppingCartController中创建list方法，根据当前登录用户ID查询购物车列表，并对查询的结果进行创建时间的倒序排序。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212055615.png" alt="image-20230621140048573"></p><p>代码实现如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查看购物车</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;List&lt;ShoppingCart&gt;&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;查看购物车...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line">    queryWrapper.orderByAsc(ShoppingCart::getCreateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;ShoppingCart&gt; list = shoppingCartService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212056447.png" alt="image-20230621143039059"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212108919.png" alt="image-20230621143328883"></p><h4 id="3-5-3-清空购物车"><a href="#3-5-3-清空购物车" class="headerlink" title="3.5.3 清空购物车"></a>3.5.3 清空购物车</h4><p>在ShoppingCartController中创建clean方法，在方法中获取当前登录用户，根据登录用户ID，删除购物车数据。</p><p>代码实现如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 清空购物车</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/clean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">clean</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//SQL:delete from shopping_cart where user_id = ?</span></span><br><span class="line">    LambdaQueryWrapper&lt;ShoppingCart&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId());</span><br><span class="line"></span><br><span class="line">    shoppingCartService.remove(queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;清空购物车成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212056302.png" alt="image-20230621143915005"></p><p>原本</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212056183.png" alt="image-20230621143941568"></p><p>清空后</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212056743.png" alt="image-20230621143956982"></p><h3 id="3-6-功能测试"><a href="#3-6-功能测试" class="headerlink" title="3.6 功能测试"></a>3.6 功能测试</h3><p>按照前面分析的操作流程进行测试，测试功能以及数据库中的数据是否是否正常。</p><p><strong>1). 添加购物车</strong></p><p>当添加的是菜品信息，而这个用户的购物车中当前并没有这个菜品时，添加一条数据，数量为1。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031421755.png" alt="image-20210814070930745" style="zoom:80%;" /> <p>检查数据库数据，由于是菜品保存的是dish_id。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031421707.png" alt="image-20210814071113382"> </p><p>这时在页面上，我们可以继续点击+号，在购物车中增加该菜品，此时，应该是对现有的购物车菜品数量加1，而不应该插入新的记录。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031421243.png" alt="image-20210814071613706" style="zoom:80%;" /> <p>检查数据库数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031429433.png" alt="image-20210814071707767"> </p><p>如果添加的是套餐，该套餐在当前用户的购物车中并不存在，则添加一条数据，数量为1。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031429867.png" alt="image-20210814071742125" style="zoom:80%;" />  <p>检查数据库数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031421354.png" alt="image-20210814071850689"> </p><p><strong>2). 查看购物车</strong></p><p>点击页面下面的购物车边栏，查看购物车数据列表是否正常展示。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031422179.png" alt="image-20210814071956804" style="zoom:80%;" /> <p><strong>3). 清空购物车</strong></p><p>在购物车列表展示页中点击”清空”, 查看购物车是否被清空。</p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031422163.png" alt="image-20210814072159568" style="zoom:80%;" /> <p>并检查数据库中的数据，可以看到数据已经被删除。</p><h2 id="4-下单"><a href="#4-下单" class="headerlink" title="4. 下单"></a>4. 下单</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p>移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的 “去结算” 按钮，页面跳转到订单确认页面，点击 “去支付” 按钮则完成下单操作。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031422766.png" alt="image-20210814072533469" style="zoom:80%;" /> <p>这里，我们需要说明一下，这里并不会去开发支付功能，因为不论是支付宝的支付，还是微信支付，都是需要企业资质的，而我们大家在测试的时候，是没有办法提供企业资质的，所以这一部分支付功能我们就不去实现了。</p><h3 id="4-2-数据模型"><a href="#4-2-数据模型" class="headerlink" title="4.2 数据模型"></a>4.2 数据模型</h3><p>用户下单业务对应的数据表为orders表和order_detail表(一对多关系,一个订单关联多个订单明细)：</p><table><thead><tr><th>表名</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>orders</td><td>订单表</td><td>主要存储订单的基本信息(如: 订单号、状态、金额、支付方式、下单用户、收件地址等)</td></tr><tr><td>order_detail</td><td>订单明细表</td><td>主要存储订单详情信息(如: 该订单关联的套餐及菜品的信息)</td></tr></tbody></table><p>具体的表结构如下: </p><p><strong>A. orders 订单表</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031422443.png" alt="image-20210814095559935">  </p><p><strong>B. order_detail</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031422770.png" alt="image-20210814073544977"> </p><p>数据示例: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031422684.png" alt="image-20210815224918077"> </p><p>用户提交订单时，需要往订单表orders中插入一条记录，并且需要往order_detail中插入一条或多条记录。</p><h3 id="4-3-前端页面分析"><a href="#4-3-前端页面分析" class="headerlink" title="4.3 前端页面分析"></a>4.3 前端页面分析</h3><p>在开发代码之前，需要梳理一下用户下单操作时前端页面和服务端的交互过程：</p><p><strong>1). 在购物车中点击<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031422130.png" alt="image-20210814073907767" style="zoom: 67%;" />按钮，页面跳转到订单确认页面</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031423506.png" alt="image-20210814075105094" style="zoom:67%;" /> <p>页面跳转前端已经完成，我们无需操作。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212057007.png" alt="image-20230621161254484"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212057143.png" alt="image-20230621161339884"></p><p>注意：如果没有添加地址 会优先添加地址</p><p>返回</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212057655.png" alt="image-20230621161623797"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212057151.png" alt="image-20230621161509926"></p><p><strong>2). 在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的默认地址</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031423946.png" alt="image-20210814075454329" style="zoom:80%;" /> <p>该功能在用户地址簿管理功能开发时，已经实现(导入)，我们无需操作。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212057654.png" alt="image-20230621161857501"></p><p><strong>3). 在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的购物车数据</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031423738.png" alt="image-20210814075635880" style="zoom:80%;" /> <p>该功能已经实现，我们无需操作。</p><p><strong>4). 在订单确认页面点击<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031423098.png" alt="image-20210814075722616" style="zoom:67%;" />按钮，发送ajax请求，请求服务端完成下单操作</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212057376.png" alt="image-20230621162307323"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212058216.png" alt="image-20230621162339304"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031423770.png" alt="image-20210814080254623" style="zoom:80%;" /> <p>经过上述的分析，我们看到前三步的功能我们都已经实现了，我们主要需要实现最后一步的下单功能，该功能具体的请求信息如下： </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;order&#x2F;submit</td></tr><tr><td>请求参数</td><td>{“remark”:”老板,记得带一次性筷子”,”payMethod”:1,”addressBookId”:”1425792459560005634”}</td></tr></tbody></table><h3 id="4-4-准备工作"><a href="#4-4-准备工作" class="headerlink" title="4.4 准备工作"></a>4.4 准备工作</h3><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好：</p><p><strong>1). 实体类 Orders、OrderDetail（直接从课程资料中导入即可）</strong></p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//订单号</span></span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">    <span class="comment">//订单状态 1待付款，2待派送，3已派送，4已完成，5已取消</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下单用户id</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地址id</span></span><br><span class="line">    <span class="keyword">private</span> Long addressBookId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下单时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime orderTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结账时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime checkoutTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支付方式 1微信，2支付宝</span></span><br><span class="line">    <span class="keyword">private</span> Integer payMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实收金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备注</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String consignee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDetail</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订单id</span></span><br><span class="line">    <span class="keyword">private</span> Long orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品id</span></span><br><span class="line">    <span class="keyword">private</span> Long dishId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//套餐id</span></span><br><span class="line">    <span class="keyword">private</span> Long setmealId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//口味</span></span><br><span class="line">    <span class="keyword">private</span> String dishFlavor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). Mapper接口 OrderMapper、OrderDetailMapper</strong></p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Orders;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Orders&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.OrderDetail;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDetailMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;OrderDetail&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3). 业务层接口 OrderService、OrderDetailService</strong></p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Orders&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.OrderDetail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDetailService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;OrderDetail&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4). 业务层实现类 OrderServiceImpl、OrderDetailServiceImpl</strong></p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.*;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.OrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.*;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderMapper, Orders&gt; <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.OrderDetail;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.OrderDetailMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.OrderDetailService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDetailServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OrderDetailMapper, OrderDetail&gt; <span class="keyword">implements</span> <span class="title class_">OrderDetailService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 控制层 OrderController、OrderDetailController</strong></p><p>所属包: com.itheima.reggie.controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.OrderDetailService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单明细</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orderDetail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDetailController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDetailService orderDetailService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-代码开发"><a href="#4-5-代码开发" class="headerlink" title="4.5 代码开发"></a>4.5 代码开发</h3><p>在OrderController中创建submit方法，处理用户下单的逻辑 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户下单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orders</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">submit</span><span class="params">(<span class="meta">@RequestBody</span> Orders orders)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;订单数据：&#123;&#125;&quot;</span>,orders);</span><br><span class="line">    orderService.submit(orders);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;下单成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于下单的逻辑相对复杂，我们可以在OrderService中定义submit方法，来处理下单的具体逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户下单</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> orders</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Orders ordrs)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212058678.png" alt="image-20230621163624357"></p><p>然后在OrderServiceImpl中完成下单功能的具体实现，下单功能的具体逻辑如下： </p><p>A. 获得当前用户id, 查询当前用户的购物车数据</p><p>B. 根据当前登录用户id, 查询用户数据</p><p>C. 根据地址ID, 查询地址数据</p><p>D. 组装订单明细数据, 批量保存订单明细 </p><p>E. 组装订单数据, 批量保存订单数据</p><p>F. 删除当前用户的购物车列表数据</p><p>具体代码实现如下: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ShoppingCartService shoppingCartService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AddressBookService addressBookService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderDetailService orderDetailService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户下单</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> orders</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Orders orders)</span> &#123;</span><br><span class="line">    <span class="comment">//获得当前用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前用户的购物车数据</span></span><br><span class="line">    LambdaQueryWrapper&lt;ShoppingCart&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.eq(ShoppingCart::getUserId,userId);</span><br><span class="line">    List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(wrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(shoppingCarts == <span class="literal">null</span> || shoppingCarts.size() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;购物车为空，不能下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询用户数据</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询地址数据</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">addressBookId</span> <span class="operator">=</span> orders.getAddressBookId();</span><br><span class="line">    <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span> addressBookService.getById(addressBookId);</span><br><span class="line">    <span class="keyword">if</span>(addressBook == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;用户地址信息有误，不能下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> IdWorker.getId();<span class="comment">//订单号</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装订单明细信息</span></span><br><span class="line">    List&lt;OrderDetail&gt; orderDetails = shoppingCarts.stream().map((item) -&gt; &#123;</span><br><span class="line">        <span class="type">OrderDetail</span> <span class="variable">orderDetail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderDetail</span>();</span><br><span class="line">        orderDetail.setOrderId(orderId);</span><br><span class="line">        orderDetail.setNumber(item.getNumber());</span><br><span class="line">        orderDetail.setDishFlavor(item.getDishFlavor());</span><br><span class="line">        orderDetail.setDishId(item.getDishId());</span><br><span class="line">        orderDetail.setSetmealId(item.getSetmealId());</span><br><span class="line">        orderDetail.setName(item.getName());</span><br><span class="line">        orderDetail.setImage(item.getImage());</span><br><span class="line">        orderDetail.setAmount(item.getAmount());</span><br><span class="line">        amount.addAndGet(item.getAmount().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getNumber())).intValue());</span><br><span class="line">        <span class="keyword">return</span> orderDetail;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组装订单数据</span></span><br><span class="line">    orders.setId(orderId);</span><br><span class="line">    orders.setOrderTime(LocalDateTime.now());</span><br><span class="line">    orders.setCheckoutTime(LocalDateTime.now());</span><br><span class="line">    orders.setStatus(<span class="number">2</span>);</span><br><span class="line">    orders.setAmount(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(amount.get()));<span class="comment">//总金额</span></span><br><span class="line">    orders.setUserId(userId);</span><br><span class="line">    orders.setNumber(String.valueOf(orderId));</span><br><span class="line">    orders.setUserName(user.getName());</span><br><span class="line">    orders.setConsignee(addressBook.getConsignee());</span><br><span class="line">    orders.setPhone(addressBook.getPhone());</span><br><span class="line">    orders.setAddress((addressBook.getProvinceName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getProvinceName())</span><br><span class="line">        + (addressBook.getCityName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getCityName())</span><br><span class="line">        + (addressBook.getDistrictName() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDistrictName())</span><br><span class="line">        + (addressBook.getDetail() == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : addressBook.getDetail()));</span><br><span class="line">    <span class="comment">//向订单表插入数据，一条数据</span></span><br><span class="line">    <span class="built_in">this</span>.save(orders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向订单明细表插入数据，多条数据</span></span><br><span class="line">    orderDetailService.saveBatch(orderDetails);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空购物车数据</span></span><br><span class="line">    shoppingCartService.remove(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注: </p><p>​上述逻辑处理中，计算购物车商品的总金额时，为保证我们每一次执行的累加计算是一个原子操作，我们这里用到了JDK中提供的一个原子类 AtomicInteger</p></blockquote><h3 id="4-6-功能测试"><a href="#4-6-功能测试" class="headerlink" title="4.6 功能测试"></a>4.6 功能测试</h3><p>代码编写完成，我们重新启动服务，按照前面分析的操作流程进行测试，查看数据是否正常即可。在测试过程中，我们可以通过debug的形式来跟踪代码的正常执行。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031423595.png" alt="image-20210814084822573" style="zoom: 67%;" /> <p>视频分析测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212058318.png" alt="image-20230621202150090"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212058438.png" alt="image-20230621202431768"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212058775.png" alt="image-20230621202611670"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212058958.png" alt="image-20230621202636630"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059422.png" alt="image-20230621202734770"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059608.png" alt="image-20230621202750473"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059575.png" alt="image-20230621202857765"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059240.png" alt="image-20230621202949941"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059918.png" alt="image-20230621203320485"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059078.png" alt="image-20230621203520154"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059416.png" alt="image-20230621203840079"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212059663.png" alt="image-20230621203957880"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212100615.png" alt="image-20230621204015041"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212100055.png" alt="image-20230621204304407"></p><p><strong>检查数据库数据</strong></p><p>订单表插入一条记录： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031423050.png" alt="image-20210814084925524"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212100687.png" alt="image-20230621204356913"></p><p>订单明细表插入四条记录()： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031424746.png" alt="image-20210814085019401"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202306212100223.png" alt="image-20230621204435440"></p><p>同时，购物车的数据被删除： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day06/202304031424155.png" alt="image-20210814085058814">  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖-Day05</title>
      <link href="/archives/4.html"/>
      <url>/archives/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖-Day05"><a href="#瑞吉外卖-Day05" class="headerlink" title="瑞吉外卖-Day05"></a>瑞吉外卖-Day05</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li><p>新增套餐</p></li><li><p>套餐分页查询</p></li><li><p>删除套餐</p></li><li><p>短信发送</p></li><li><p>手机验证码登录</p></li></ul><h2 id="1-新增套餐"><a href="#1-新增套餐" class="headerlink" title="1. 新增套餐"></a>1. 新增套餐</h2><h3 id="1-1-需求分析"><a href="#1-1-需求分析" class="headerlink" title="1.1 需求分析"></a>1.1 需求分析</h3><p>套餐就是菜品的集合。</p><p>后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022207240.png" alt="image-20210805232711418" style="zoom:80%;" /> <h3 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h3><p>新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表，还需要向setmeal_dish表插入套餐和菜品关联数据。所以在新增套餐时，涉及到两个表：</p><table><thead><tr><th>表</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>setmeal</td><td>套餐表</td><td>存储套餐的基本信息</td></tr><tr><td>setmeal_dish</td><td>套餐菜品关系表</td><td>存储套餐关联的菜品的信息(一个套餐可以关联多个菜品)</td></tr></tbody></table><p>两张表具体的表结构如下: </p><p><strong>1). 套餐表setmeal</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022207919.png" alt="image-20210805233615067"> </p><p>在该表中，套餐名称name字段是不允许重复的，在建表时，已经创建了唯一索引。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022207670.png" alt="image-20210805234059563"> </p><p><strong>2). 套餐菜品关系表setmeal_dish</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022207110.png" alt="image-20210805233807009"> </p><p>在该表中，菜品的名称name,菜品的原价price 实际上都是冗余字段,因为我们在这张表中存储了菜品的ID(dish_id),根据该ID我们就可以查询出name,price的数据信息,而这里我们又存储了name,price,这样的话,我们在后续的查询展示操作中,就不需要再去查询数据库获取菜品名称和原价了,这样可以简化我们的操作。</p><h3 id="1-3-准备工作"><a href="#1-3-准备工作" class="headerlink" title="1.3 准备工作"></a>1.3 准备工作</h3><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好，在做这一块儿的准备工作时，我们无需准备Setmeal的相关实体类、Mapper接口、Service接口及实现，因为之前在做分类管理的时候，我们已经引入了Setmeal的相关基础代码。 接下来，我们就来完成以下的几步准备工作： </p><p><strong>1). 实体类 SetmealDish</strong></p><p>ps.直接从课程资料中导入即可，Setmeal实体前面课程中已经导入过了。</p><p>所属包： com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 套餐菜品关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetmealDish</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//套餐id</span></span><br><span class="line">    <span class="keyword">private</span> Long setmealId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品id</span></span><br><span class="line">    <span class="keyword">private</span> Long dishId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品名称 （冗余字段）</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//菜品原价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//份数</span></span><br><span class="line">    <span class="keyword">private</span> Integer copies;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否删除</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). DTO SetmealDto</strong></p><p>该数据传输对象DTO,主要用于封装页面在新增套餐时传递过来的json格式的数据,其中包含套餐的基本信息,还包含套餐关联的菜品集合。直接从课程资料中导入即可。</p><p>所属包： com.itheima.reggie.dto</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Setmeal;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.SetmealDish;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetmealDto</span> <span class="keyword">extends</span> <span class="title class_">Setmeal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SetmealDish&gt; setmealDishes;<span class="comment">//套餐关联的菜品集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String categoryName;<span class="comment">//分类名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3). Mapper接口 SetmealDishMapper</strong></p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.SetmealDish;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetmealDishMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;SetmealDish&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4). 业务层接口 SetmealDishService</strong></p><p>所属包： com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.SetmealDish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetmealDishService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;SetmealDish&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 业务层实现类 SetmealDishServiceImpl</strong></p><p>所属包： com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.SetmealDish;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.SetmealDishMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.SetmealDishService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetmealDishServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SetmealDishMapper,SetmealDish&gt; <span class="keyword">implements</span> <span class="title class_">SetmealDishService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6). 控制层 SetmealController</strong></p><p>套餐管理的相关业务，我们都统一在 SetmealController 中进行统一处理操作。</p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.SetmealDishService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.SetmealService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 套餐管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/setmeal&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetmealController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SetmealService setmealService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SetmealDishService setmealDishService;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="1-4-前端页面分析"><a href="#1-4-前端页面分析" class="headerlink" title="1.4 前端页面分析"></a>1.4 前端页面分析</h3><p>服务端的基础准备工作我们准备完毕之后，在进行代码开发之前，需要梳理一下新增套餐时前端页面和服务端的交互过程：</p><p>1). 点击新建套餐按钮，访问页面(backend&#x2F;page&#x2F;combo&#x2F;add.html)，页面加载发送ajax请求，请求服务端获取<strong>套餐分类</strong>数据并展示到下拉框中(&#x3D;&#x3D;已实现&#x3D;&#x3D;)</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022208463.png" alt="image-20210806002144537"> </p><p>获取套餐分类列表的功能我们不用开发，之前已经开发完成了，之前查询时type传递的是1，查询菜品分类; 本次查询时，传递的type为2，查询套餐分类列表。</p><p>2). 访问页面(backend&#x2F;page&#x2F;combo&#x2F;add.html)，页面加载时发送ajax请求，请求服务端获取<strong>菜品分类</strong>数据并展示到添加菜品窗口中(&#x3D;&#x3D;已实现&#x3D;&#x3D;)</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022208951.png" alt="image-20210806002730820"> </p><p>本次查询分类列表，传递的type为1，表示需要查询的是菜品的分类。查询菜品分类的目的，是添加套餐关联的菜品时，我们需要根据菜品分类，来过滤查询菜品信息。查询菜品分类列表的代码已经实现， 具体展示效果如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022209142.png" alt="image-20210806003318531">  </p><p>3). 当点击添加菜品窗口左侧菜单的某一个分类, 页面发送ajax请求，请求服务端，根据菜品分类查询对应的<strong>菜品</strong>数据并展示到添加菜品窗口中</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022209063.png" alt="image-20210806004116496"> </p><p>4). 页面发送请求进行<strong>图片上传</strong>，请求服务端将图片保存到服务器(&#x3D;&#x3D;已实现&#x3D;&#x3D;)</p><p>5). 页面发送请求进行<strong>图片下载</strong>，将上传的图片进行回显(&#x3D;&#x3D;已实现&#x3D;&#x3D;)</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022209350.png" alt="image-20210806004434277"> </p><p>6). 点击保存按钮，发送ajax请求，将<strong>套餐</strong>相关数据以json形式提交到服务端</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022210711.png" alt="image-20210806005028874"> </p><p>经过上述的页面解析及流程分析，我们发送这里需要发送的请求有5个，分别是 ：</p><p>A. 根据传递的参数,查询套餐分类列表</p><p>B. 根据传递的参数,查询菜品分类列表</p><p>C. 图片上传</p><p>D. 图片下载展示</p><p>E. 根据菜品分类ID,查询菜品列表</p><p>F. 保存套餐信息</p><p>而对于以上的前4个功能我们都已经实现, 所以我们接下来需要开发的功能主要是最后两项, 具体的请求信息如下:</p><p><strong>1). 根据分类ID查询菜品列表</strong></p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;dish&#x2F;list</td></tr><tr><td>请求参数</td><td>?categoryId&#x3D;1397844263642378242</td></tr></tbody></table><p><strong>2). 保存套餐信息</strong></p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;setmeal</td></tr><tr><td>请求参数</td><td>json格式数据</td></tr></tbody></table><p>传递的json格式数据如下: </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;营养超值工作餐&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;categoryId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1399923597874081794&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="number">3800</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="string">&quot;9cd7a80a-da54-4f46-bf33-af3576514cec.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;营养超值工作餐&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dishList&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;idType&quot;</span><span class="punctuation">:</span><span class="string">&quot;1399923597874081794&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;setmealDishes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;copies&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span><span class="attr">&quot;dishId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1423329009705463809&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;米饭&quot;</span><span class="punctuation">,</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;copies&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;dishId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1423328152549109762&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;可乐&quot;</span><span class="punctuation">,</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="number">500</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;copies&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;dishId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1397853890262118402&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;鱼香肉丝&quot;</span><span class="punctuation">,</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="number">3800</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202100015.png" alt="image-20230619162412794"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202101420.png" alt="image-20230619162922980"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202101276.png" alt="image-20230619163032247"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202103532.png" alt="image-20230619163210820"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202103900.png" alt="image-20230619163835680"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104499.png" alt="image-20230619163900932"></p><h3 id="1-5-代码开发"><a href="#1-5-代码开发" class="headerlink" title="1.5 代码开发"></a>1.5 代码开发</h3><p>上面我们已经分析了接下来我们需要实现的两个功能，接下来我们就需要根据上述的分析，来完成具体的功能实现。</p><h4 id="1-5-1-根据分类查询菜品"><a href="#1-5-1-根据分类查询菜品" class="headerlink" title="1.5.1 根据分类查询菜品"></a>1.5.1 根据分类查询菜品</h4><h5 id="1-5-1-1-功能实现"><a href="#1-5-1-1-功能实现" class="headerlink" title="1.5.1.1 功能实现"></a>1.5.1.1 功能实现</h5><p>在当前的需求中，我们只需要根据页面传递的菜品分类的ID(categoryId)来查询菜品列表即可，我们可以直接定义一个DishController的方法，声明一个Long类型的categoryId，这样做是没问题的。但是考虑到该方法的拓展性，我们在这里定义方法时，通过Dish这个实体来接收参数。</p><p>在DishController中定义方法list，接收Dish类型的参数：</p><p>在查询时，需要根据菜品分类categoryId进行查询，并且还要限定菜品的状态为起售状态(status为1)，然后对查询的结果进行排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据条件查询对应的菜品数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dish</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;List&lt;Dish&gt;&gt; <span class="title function_">list</span><span class="params">(Dish dish)</span>&#123;</span><br><span class="line">    <span class="comment">//构造查询条件</span></span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(dish.getCategoryId() != <span class="literal">null</span> ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">    <span class="comment">//添加条件，查询状态为1（起售状态）的菜品</span></span><br><span class="line">    queryWrapper.eq(Dish::getStatus,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//添加排序条件</span></span><br><span class="line">    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视频分析</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 根据条件查询对应的菜品数据</span><br><span class="line">    * @param dish</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @GetMapping(&quot;/list&quot;)</span><br><span class="line">   public R&lt;List&lt;Dish&gt;&gt; list(Dish dish)&#123;</span><br><span class="line">       //构造查询条件</span><br><span class="line">       LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">       queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());</span><br><span class="line">       //添加排序条件</span><br><span class="line">       queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">       List&lt;Dish&gt; list = dishService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">       return R.success(list);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104316.png" alt="image-20230619164623633"></p><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104444.png" alt="image-20230619164728867"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104190.png" alt="image-20230619164809510"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104244.png" alt="image-20230619164835860"></p><p>4次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104764.png" alt="image-20230619164929956"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104621.png" alt="image-20230619165138363"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202104644.png" alt="image-20230619165201177"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202105653.png" alt="image-20230619165252518"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202105069.png" alt="image-20230619165342137"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202105468.png" alt="image-20230619165400238"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202105604.png" alt="image-20230619165431220"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202105716.png" alt="image-20230619165413651"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加条件，查询状态为1（起售状态）的菜品</span><br><span class="line">queryWrapper.eq(Dish::getStatus,1);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202105180.png" alt="image-20230619170347124"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202106564.png" alt="image-20230619170435911"></p><h5 id="1-5-1-2-功能测试"><a href="#1-5-1-2-功能测试" class="headerlink" title="1.5.1.2 功能测试"></a>1.5.1.2 功能测试</h5><p>代码编写完毕，我们重新启动服务器，进行测试，可以通过debug断点跟踪的形式查看页面传递的参数封装情况，及响应给页面的数据信息。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022210102.png" alt="image-20210806012153982"> </p><h4 id="1-5-2-保存套餐"><a href="#1-5-2-保存套餐" class="headerlink" title="1.5.2 保存套餐"></a>1.5.2 保存套餐</h4><h5 id="1-5-2-1-功能实现"><a href="#1-5-2-1-功能实现" class="headerlink" title="1.5.2.1 功能实现"></a>1.5.2.1 功能实现</h5><p>在进行套餐信息保存时，前端提交的数据，不仅包含套餐的基本信息，还包含套餐关联的菜品列表数据 setmealDishes。所以这个时候我们使用Setmeal就不能完成参数的封装了，我们需要在Setmeal的基本属性的基础上，再扩充一个属性 setmealDishes 来接收页面传递的套餐关联的菜品列表，而我们在准备工作中，导入进来的SetmealDto能够满足这个需求。</p><p>1). SetmealController中定义方法save，新增套餐</p><p>在该Controller的方法中,我们不仅需要保存套餐的基本信息，还需要保存套餐关联的菜品数据，所以我们需要再该方法中调用业务层方法,完成两块数据的保存。</p><p>页面传递的数据是json格式，需要在方法形参前面加上@RequestBody注解, 完成参数封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> SetmealDto setmealDto)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;套餐信息：&#123;&#125;&quot;</span>,setmealDto);</span><br><span class="line"></span><br><span class="line">    setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;新增套餐成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202106228.png" alt="image-20230619174247614"></p><p>2). SetmealService中定义方法saveWithDish</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增套餐，同时需要保存套餐和菜品的关联关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> setmealDto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithDish</span><span class="params">(SetmealDto setmealDto)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202106068.png" alt="image-20230619174318696"></p><p>3). SetmealServiceImpl实现方法saveWithDish</p><p>具体逻辑: </p><p>A. 保存套餐基本信息</p><p>B. 获取套餐关联的菜品集合，并为集合中的每一个元素赋值套餐ID(setmealId)</p><p>C. 批量保存套餐关联的菜品集合</p><p>代码实现: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SetmealDishService setmealDishService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增套餐，同时需要保存套餐和菜品的关联关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> setmealDto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithDish</span><span class="params">(SetmealDto setmealDto)</span> &#123;</span><br><span class="line">    <span class="comment">//保存套餐的基本信息，操作setmeal，执行insert操作</span></span><br><span class="line">    <span class="built_in">this</span>.save(setmealDto);</span><br><span class="line"></span><br><span class="line">    List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();</span><br><span class="line">    setmealDishes.stream().map((item) -&gt; &#123;</span><br><span class="line">        item.setSetmealId(setmealDto.getId());</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存套餐和菜品的关联信息，操作setmeal_dish,执行insert操作</span></span><br><span class="line">    setmealDishService.saveBatch(setmealDishes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202106324.png" alt="image-20230619174427316"></p><h5 id="1-5-2-2-功能测试"><a href="#1-5-2-2-功能测试" class="headerlink" title="1.5.2.2 功能测试"></a>1.5.2.2 功能测试</h5><p>代码编写完毕，我们重新启动服务器，进行测试，可以通过debug断点跟踪的形式查看页面传递的参数封装情况，及套餐相关数据的保存情况。</p><p>录入表单数据: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022210215.png" alt="image-20210806014328575"> </p><p>debug跟踪数据封装:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022210407.png" alt="image-20210806014508310"> </p><p>跟踪数据库保存的数据:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022210974.png" alt="image-20210806014807017"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202106387.png" alt="image-20230619171343906"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202106251.png" alt="image-20230619171415235"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107029.png" alt="image-20230619171451409"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107756.png" alt="image-20230619171547743"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*新增套餐*/</span><br><span class="line"></span><br><span class="line">@PostMapping</span><br><span class="line">public R&lt;String&gt; save(@RequestBody SetmealDto setmealDto)&#123;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;套餐信息：&#123;&#125;&quot;,setmealDto);</span><br><span class="line"></span><br><span class="line">        return  null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107165.png" alt="image-20230619172525047"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107804.png" alt="image-20230619172646760"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107733.png" alt="image-20230619172908175"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107576.png" alt="image-20230619173041213"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107133.png" alt="image-20230619173101886"></p><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202107619.png" alt="image-20230619174905080"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202108428.png" alt="image-20230619174840641"></p><p>2次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202108067.png" alt="image-20230619174957327"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202108532.png" alt="image-20230619175140252"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202108188.png" alt="image-20230619175243548"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202108700.png" alt="image-20230619175258049"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202108540.png" alt="image-20230619175400721"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202108692.png" alt="image-20230619175452721"></p><h2 id="2-套餐分页查询"><a href="#2-套餐分页查询" class="headerlink" title="2. 套餐分页查询"></a>2. 套餐分页查询</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022210766.png" alt="image-20210806073710653"> </p><p>在进行套餐数据的分页查询时，除了传递分页参数以外，还可以传递一个可选的条件(套餐名称)。查询返回的字段中，包含套餐的基本信息之外，还有一个套餐的分类名称，在查询时，需要关联查询这个字段。</p><h3 id="2-2-前端页面分析"><a href="#2-2-前端页面分析" class="headerlink" title="2.2 前端页面分析"></a>2.2 前端页面分析</h3><p>在开发代码之前，需要梳理一下套餐分页查询时前端页面和服务端的交互过程：</p><p>1). 访问页面(backend&#x2F;page&#x2F;combo&#x2F;list.html)，页面加载时，会自动发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022211862.png" alt="image-20210806074846550" style="zoom:80%;" /> <p>2). 在列表渲染展示时，页面发送请求，请求服务端进行图片下载，用于页面图片展示(<strong>已实现</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022211486.png" alt="image-20210806075231072"> </p><p>而对于以上的流程中涉及到2个功能,文件下载功能我们已经实现,本小节我们主要实现列表分页查询功能, 具体的请求信息如下:</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;setmeal&#x2F;page</td></tr><tr><td>请求参数</td><td>?page&#x3D;1&amp;pageSize&#x3D;10&amp;name&#x3D;xxx</td></tr></tbody></table><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202109964.png" alt="image-20230619181000177"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202109388.png" alt="image-20230619181106258"></p><h3 id="2-3-代码开发"><a href="#2-3-代码开发" class="headerlink" title="2.3 代码开发"></a>2.3 代码开发</h3><h4 id="2-3-1-基本信息查询"><a href="#2-3-1-基本信息查询" class="headerlink" title="2.3.1 基本信息查询"></a>2.3.1 基本信息查询</h4><p>上述我们已经分析列表分页查询功能的请求信息，接下来我们就在SetmealController中创建套餐分页查询方法。</p><p>该方法的逻辑如下： </p><p>1). 构建分页条件对象</p><p>2). 构建查询条件对象，如果传递了套餐名称，根据套餐名称模糊查询， 并对结果按修改时间降序排序</p><p>3). 执行分页查询</p><p>4). 组装数据并返回</p><p>代码实现 : </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 套餐分页查询</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span>&#123;</span><br><span class="line">    <span class="comment">//分页构造器对象</span></span><br><span class="line">    Page&lt;Setmeal&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line"></span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加查询条件，根据name进行like模糊查询</span></span><br><span class="line">    queryWrapper.like(name != <span class="literal">null</span>,Setmeal::getName,name);</span><br><span class="line">    <span class="comment">//添加排序条件，根据更新时间降序排列</span></span><br><span class="line">    queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    setmealService.page(pageInfo,queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-问题分析"><a href="#2-3-2-问题分析" class="headerlink" title="2.3.2 问题分析"></a>2.3.2 问题分析</h4><p>基本分页查询代码编写完毕后，重启服务，测试列表查询，我们发现, 列表页面的数据可以展示出来, 但是套餐分类名称没有展示出来。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022211487.png" alt="image-20210806082542473"> </p><p>这是因为在服务端仅返回分类ID(categoryId), 而页面展示需要的是categoryName属性。 </p><h4 id="2-3-3-功能完善"><a href="#2-3-3-功能完善" class="headerlink" title="2.3.3 功能完善"></a>2.3.3 功能完善</h4><p>在查询套餐信息时, 只包含套餐的基本信息, 并不包含套餐的分类名称, 所以在这里查询到套餐的基本信息后, 还需要根据分类ID(categoryId), 查询套餐分类名称(categoryName)，并最终将套餐的基本信息及分类名称信息封装到SetmealDto(在第一小节已经导入)中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetmealDto</span> <span class="keyword">extends</span> <span class="title class_">Setmeal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SetmealDish&gt; setmealDishes; <span class="comment">//套餐关联菜品列表</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;<span class="comment">//套餐分类名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完善后代码: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 套餐分页查询</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span>&#123;</span><br><span class="line">    <span class="comment">//分页构造器对象</span></span><br><span class="line">    Page&lt;Setmeal&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">    Page&lt;SetmealDto&gt; dtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加查询条件，根据name进行like模糊查询</span></span><br><span class="line">    queryWrapper.like(name != <span class="literal">null</span>,Setmeal::getName,name);</span><br><span class="line">    <span class="comment">//添加排序条件，根据更新时间降序排列</span></span><br><span class="line">    queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    setmealService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象拷贝</span></span><br><span class="line">    BeanUtils.copyProperties(pageInfo,dtoPage,<span class="string">&quot;records&quot;</span>);</span><br><span class="line">    List&lt;Setmeal&gt; records = pageInfo.getRecords();</span><br><span class="line"></span><br><span class="line">    List&lt;SetmealDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">        <span class="type">SetmealDto</span> <span class="variable">setmealDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetmealDto</span>();</span><br><span class="line">        <span class="comment">//对象拷贝</span></span><br><span class="line">        BeanUtils.copyProperties(item,setmealDto);</span><br><span class="line">        <span class="comment">//分类id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();</span><br><span class="line">        <span class="comment">//根据分类id查询分类对象</span></span><br><span class="line">        <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line">        <span class="keyword">if</span>(category != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//分类名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">            setmealDto.setCategoryName(categoryName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setmealDto;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    dtoPage.setRecords(list);</span><br><span class="line">    <span class="keyword">return</span> R.success(dtoPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-功能测试"><a href="#2-4-功能测试" class="headerlink" title="2.4 功能测试"></a>2.4 功能测试</h3><p>代码完善后，重启服务，测试列表查询，我们发现, 抓取浏览器的请求响应数据，我们可以获取到套餐分类名称categoryName，也可以在列表页面展示出来 。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022211855.png" alt="image-20210806083346578"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202109499.png" alt="image-20230619182712665"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110636.png" alt="image-20230619182738181"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110795.png" alt="image-20230619182809946"></p><p>2次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202125922.png" alt="image-20230619182853661"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110667.png" alt="image-20230619183027448"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202125961.png" alt="image-20230619183045861"></p><p>4次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110507.png" alt="image-20230619183214188"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110627.png" alt="image-20230619183233374"></p><p>拷贝之前</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110691.png" alt="image-20230619183302193"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110252.png" alt="image-20230619183344845"></p><p>拷贝之后</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110355.png" alt="image-20230619183418833"></p><p>4次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202110788.png" alt="image-20230619183534070"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202111434.png" alt="image-20230619183643456"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202111466.png" alt="image-20230619183743151"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202111850.png" alt="image-20230619183758017"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202111202.png" alt="image-20230619183829216"></p><h2 id="3-删除套餐"><a href="#3-删除套餐" class="headerlink" title="3. 删除套餐"></a>3. 删除套餐</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>在套餐管理列表页面,点击删除按钮，可以删除对应的套餐信息。也可以通过复选框选择多个套餐，点击批量删除按钮一次删除多个套餐。注意，对于状态为售卖中的套餐不能删除，需要先停售，然后才能删除。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022211422.png" alt="image-20210806214443507"> </p><h3 id="3-2-前端页面分析"><a href="#3-2-前端页面分析" class="headerlink" title="3.2 前端页面分析"></a>3.2 前端页面分析</h3><p>在开发代码之前，需要梳理一下删除套餐时前端页面和服务端的交互过程：</p><p>1). 点击删除, 删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022211366.png" alt="image-20210806215911878"> </p><p>2). 删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022212654.png" alt="image-20210806220406587"> </p><p>开发删除套餐功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可，一次请求为根据ID删除，一次请求为根据ID批量删除。</p><p>观察删除单个套餐和批量删除套餐的请求信息可以发现，两种请求的<strong>地址</strong>和<strong>请求方式</strong>都是相同的，不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理。</p><p>具体的请求信息如下： </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>DELETE</td></tr><tr><td>请求路径</td><td>&#x2F;setmeal</td></tr><tr><td>请求参数</td><td>?ids&#x3D;1423640210125656065,1423338765002256385</td></tr></tbody></table><h3 id="3-3-代码开发"><a href="#3-3-代码开发" class="headerlink" title="3.3 代码开发"></a>3.3 代码开发</h3><p>删除套餐的流程及请求信息，我们分析完毕之后，就来完成服务端的逻辑开发。在服务端的逻辑中, 删除套餐时, 我们不仅要删除套餐, 还要删除套餐与菜品的关联关系。</p><p><strong>1). 在SetmealController中创建delete方法</strong></p><p>我们可以先测试在delete方法中接收页面提交的参数，具体逻辑后续再完善：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除套餐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;ids:&#123;&#125;&quot;</span>,ids);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;套餐数据删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202111803.png" alt="image-20230619185418284"></p><p>编写完代码，我们重启服务之后，访问套餐列表页面，勾选复选框，然后点击”批量删除”,我们可以看到服务端可以接收到集合参数ids，并且在控制台也可以输出对应的数据 。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022212246.png" alt="image-20210806221603303"> </p><p>先删除单个</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202112219.png" alt="image-20230619185622525"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202126481.png" alt="image-20230619185711570"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202112731.png" alt="image-20230619185825819"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202112851.png" alt="image-20230619185753153"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202112683.png" alt="image-20230619185918260"></p><p>批量删除</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202112659.png" alt="image-20230619185950260"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202112187.png" alt="image-20230619190050196"></p><p><strong>2). SetmealService接口定义方法removeWithDish</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除套餐，同时需要删除套餐和菜品的关联数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeWithDish</span><span class="params">(List&lt;Long&gt; ids)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202112844.png" alt="image-20230619190234731"></p><p><strong>3). SetmealServiceImpl中实现方法removeWithDish</strong></p><p>该业务层方法具体的逻辑为: </p><p>A. 查询该批次套餐中是否存在售卖中的套餐, 如果存在, 不允许删除</p><p>B. 删除套餐数据</p><p>C. 删除套餐关联的菜品数据</p><p>代码实现为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除套餐，同时需要删除套餐和菜品的关联数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeWithDish</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    <span class="comment">//select count(*) from setmeal where id in (1,2,3) and status = 1</span></span><br><span class="line">    <span class="comment">//查询套餐状态，确定是否可用删除</span></span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>();</span><br><span class="line">    queryWrapper.in(Setmeal::getId,ids);</span><br><span class="line">    queryWrapper.eq(Setmeal::getStatus,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count(queryWrapper);</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//如果不能删除，抛出一个业务异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;套餐正在售卖中，不能删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果可以删除，先删除套餐表中的数据---setmeal</span></span><br><span class="line">    <span class="built_in">this</span>.removeByIds(ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete from setmeal_dish where setmeal_id in (1,2,3)</span></span><br><span class="line">    LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids);</span><br><span class="line">    <span class="comment">//删除关系表中的数据----setmeal_dish</span></span><br><span class="line">    setmealDishService.remove(lambdaQueryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113027.png" alt="image-20230619191135978"></p><p>由于当前的业务方法中存在多次数据库操作，为了保证事务的完整性，需要在方法上加注解 @Transactional 来控制事务。</p><p><strong>4). 完善SetmealController代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除套餐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;ids:&#123;&#125;&quot;</span>,ids);</span><br><span class="line">    setmealService.removeWithDish(ids);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;套餐数据删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113322.png" alt="image-20230619191230593"></p><h3 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h3><p>代码完善后，重启服务，测试套餐的删除功能，主要测试以下几种情况。</p><p>1). 删除正在启用的套餐</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022212422.png" alt="image-20210806224121877"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113258.png" alt="image-20230619191442387"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113522.png" alt="image-20230619191544300"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113770.png" alt="image-20230619191611574"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113202.png" alt="image-20230619191814098"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113146.png" alt="image-20230619191836199"></p><p>4次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202113386.png" alt="image-20230619191934240"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114002.png" alt="image-20230619192037573"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114258.png" alt="image-20230619192105888"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114562.png" alt="image-20230619192122662"></p><p>因为没有开发停售功能  所以我们手动修改数据库  把status修改成0</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114050.png" alt="image-20230619192316391"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114098.png" alt="image-20230619192426329"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202126201.png" alt="image-20230619192451296"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114267.png" alt="image-20230619192514507"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114778.png" alt="image-20230619192527783"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114767.png" alt="image-20230619193535636"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202114675.png" alt="image-20230619193559792"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115858.png" alt="image-20230619193634038"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115011.png" alt="image-20230619193659234"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115946.png" alt="image-20230619193737274"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115874.png" alt="image-20230619193751648"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115794.png" alt="image-20230619193833376"></p><p>2). 执行批量操作, 删除两条记录, 一个启售的, 一个停售的</p><p>由于当前我们并未实现启售&#x2F;停售功能，所以我们需要手动修改数据库表结构的status状态，将其中的一条记录status修改为0。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022212135.png" alt="image-20210806224603405"> </p><p>3). 删除已经停售的套餐信息，执行删除之后， 检查数据库表结构 setmeal ， setmeal_dish表中的数据</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022212006.png" alt="image-20210806224807108"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115122.png" alt="image-20230619194028481"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115402.png" alt="image-20230619194150519"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202127449.png" alt="image-20230619194236844"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115850.png" alt="image-20230619194410275"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202115746.png" alt="image-20230619194328367"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202116142.png" alt="image-20230619194452634"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202116994.png" alt="image-20230619194536848"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202116650.png" alt="image-20230619194555314"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202116898.png" alt="image-20230619194625095"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202116330.png" alt="image-20230619194705174"></p><h2 id="4-短信发送"><a href="#4-短信发送" class="headerlink" title="4. 短信发送"></a>4. 短信发送</h2><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022212502.png" alt="image-20210806225505074" style="zoom:80%;" /> <p>在我们接下来要实现的移动端的业务开发中，第一块儿我们需要开发的功能就是移动端的登录功能，而移动端的登录功能，比较流行的方式就是基于短信验证码进行登录，那么这里涉及到了短信发送的知识，所以本章节，我们就来讲解，在项目开发中，我们如何发送短信。</p><h3 id="4-1-短信服务介绍"><a href="#4-1-短信服务介绍" class="headerlink" title="4.1 短信服务介绍"></a>4.1 短信服务介绍</h3><p>在项目中，如果我们要实现短信发送功能，我们无需自己实现，也无需和运营商直接对接，只需要调用第三方提供的短信服务即可。目前市面上有很多第三方提供的短信服务，这些第三方短信服务会和各个运营商（移动、联通、电信）对接，我们只需要注册成为会员，并且按照提供的开发文档进行调用就可以发送短信。需要说明的是，这些短信服务一般都是收费服务。</p><p>常用短信服务：</p><ul><li><p>阿里云</p></li><li><p>华为云</p></li><li><p>腾讯云</p></li><li><p>京东</p></li><li><p>梦网</p></li><li><p>乐信</p></li></ul><p>本项目在选择短信服务的第三方服务提供商时，选择的是阿里云短信服务。</p><h3 id="4-2-阿里云短信服务介绍"><a href="#4-2-阿里云短信服务介绍" class="headerlink" title="4.2 阿里云短信服务介绍"></a>4.2 阿里云短信服务介绍</h3><p>阿里云短信服务（Short Message Service）是广大企业客户快速触达手机用户所优选使用的通信能力。调用API或用群发助手，即可发送验证码、通知类和营销类短信；国内验证短信秒级触达，到达率最高可达99%；国际&#x2F;港澳台短信覆盖200多个国家和地区，安全稳定，广受出海企业选用。</p><p>应用场景： </p><table><thead><tr><th>场景</th><th>案例</th></tr></thead><tbody><tr><td>验证码</td><td>APP、网站注册账号，向手机下发验证码； 登录账户、异地登录时的安全提醒； 找回密码时的安全验证； 支付认证、身份校验、手机绑定等。</td></tr><tr><td>短信通知</td><td>向注册用户下发系统相关信息，包括： 升级或维护、服务开通、价格调整、 订单确认、物流动态、消费确认、 支付通知等普通通知短信。</td></tr><tr><td>推广短信</td><td>向注册用户和潜在客户发送通知和推广信息，包括促销活动通知、业务推广等商品与活动的推广信息。增加企业产品曝光率、提高产品的知名度。</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022213815.png" alt="image-20210806231422923"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202116907.png" alt="image-20230620104059041"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202116290.png" alt="image-20230620104129345"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202135753.png" alt="image-20230620104149190"></p><p>阿里云短信服务官方网站： <a href="https://www.aliyun.com/product/sms?spm=5176.19720258.J_8058803260.52.5c432c4a11Dcwf">https://www.aliyun.com/product/sms?spm=5176.19720258.J_8058803260.52.5c432c4a11Dcwf</a></p><p>可以访问官网，熟悉一下短信服务： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022213974.png" alt="image-20210806231821334">  </p><h3 id="4-3-阿里云短信服务准备"><a href="#4-3-阿里云短信服务准备" class="headerlink" title="4.3 阿里云短信服务准备"></a>4.3 阿里云短信服务准备</h3><h4 id="4-3-1-注册账号"><a href="#4-3-1-注册账号" class="headerlink" title="4.3.1 注册账号"></a>4.3.1 注册账号</h4><p>阿里云官网：<a href="https://www.aliyun.com/">https://www.aliyun.com/</a></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022213918.png" alt="image-20210807074911618" style="zoom:80%;" /> <p>点击官网首页注册按钮，跳转到如下注册页面：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022213574.png" alt="image-20210807074934251" style="zoom:80%;" /> <p>当我们把账号注册完毕之后，我们就可以登录到阿里云系统控制台。</p><h4 id="4-3-2-开通短信服务"><a href="#4-3-2-开通短信服务" class="headerlink" title="4.3.2 开通短信服务"></a>4.3.2 开通短信服务</h4><p>注册成功后，点击登录按钮进行登录。登录后进入控制台, 在左上角的菜单栏中搜索短信服务。第一次使用，需要点击，并开通短信服务。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022213078.png" alt="image-20210807075321250"> </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022214910.png" alt="image-20210807075620990" style="zoom:80%;" /> <h4 id="4-3-3-设置短信签名"><a href="#4-3-3-设置短信签名" class="headerlink" title="4.3.3 设置短信签名"></a>4.3.3 设置短信签名</h4><p>开通短信服务之后，进入短信服务管理页面，选择国内消息菜单，我们需要在这里添加短信签名。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202117443.png" alt="image-20230620104930973"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022214046.png" alt="image-20210807080406104"> </p><p><strong>那么什么是短信签名呢?</strong></p><p>短信签名是短信发送者的署名，表示发送方的身份。我们要调用阿里云短信服务发送短信，签名是比不可少的部分。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022214254.png" alt="image-20210807080659337" style="zoom:80%;" /> <p>那么接下来，我们就需要来添加短信签名。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022214854.png" alt="image-20210807081839908"> </p><blockquote><p><font color='red'>注意：</font> </p><p>​<font color='red'>目前，阿里云短信服务申请签名主要针对企业开发，个人申请时有一定难度的，在审核时，会审核资质，需要上传营业执照 ；</font> </p><p>​<font color='red'>所以，我们课程中，主要是演示一下短信验证码如何发送，大家只需要学习这块儿的开发流程、实现方式即可，无需真正的发送短信。如果以后在企业中做项目，需要发送短信，我们会以公司的资质去申请对应的签名。</font> </p></blockquote><h4 id="4-3-4-设置短信模板"><a href="#4-3-4-设置短信模板" class="headerlink" title="4.3.4 设置短信模板"></a>4.3.4 设置短信模板</h4><p>切换到【模板管理】标签页：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022214742.png" alt="image-20210807082453655"> </p><p><strong>那么什么是模板呢?</strong></p><p>短信模板包含短信发送内容、场景、变量信息。模板的详情如下:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022217894.png" alt="image-20230402221643248"></p><p>最终我们，给用户发送的短信中，具体的短信内容，就是上面配置的这个模板内容，将${code}占位符替换成对应的验证码数据即可。如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【xxxxx】您好,您的验证码为173822,5分钟之内有效,不要泄露给他人!</span><br></pre></td></tr></table></figure><p>我们可以点击右上角的按钮,添加模板,然后填写模板的基本信息及设置的模板内容:</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022217254.png" alt="image-20210807083306928" style="zoom:80%;" /> <p><font color='red'>添加的短信模板，也是需要进行审核的只有审核通过，才可以正常使用。</font></p><h4 id="4-3-5-设置AccessKey"><a href="#4-3-5-设置AccessKey" class="headerlink" title="4.3.5 设置AccessKey"></a>4.3.5 设置AccessKey</h4><p>AccessKey 是访问阿里云 API 的密钥，具有账户的完全权限，我们要想在后面通过API调用阿里云短信服务的接口发送短信，那么就必须要设置AccessKey。</p><p>我们点击右上角的用户头像，选择”AccessKey管理”，这时就可以进入到AccessKey的管理界面。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022218678.png" alt="image-20210807130218414"></p><p>进入到AccessKey的管理界面之后，提示两个选项 “继续使用AccessKey” 和 “开始使用子用户AccessKey”，两个区别如下:</p><p><strong>1). 继续使用AccessKey</strong></p><p>如果选择的是该选项，我们创建的是阿里云账号的AccessKey，是具有账户的完全权限，有了这个AccessKey以后，我们就可以通过API调用阿里云的服务，不仅是短信服务，其他服务(OSS，语音服务，内容安全服务，视频点播服务…等)也可以调用。 相对来说，并不安全，当前的AccessKey泄露，会影响到我当前账户的其他云服务。</p><p><strong>2). 开始使用子用户AccessKey</strong></p><p>可以创建一个子用户,这个子用户我们可以分配比较低的权限,比如仅分配短信发送的权限，不具备操作其他的服务的权限，即使这个AccessKey泄漏了,也不会影响其他的云服务, 相对安全。</p><p>接下来就来演示一下，如何创建子用户AccessKey。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022218407.png" alt="image-20210807131340003"> </p><h4 id="4-3-6-配置权限"><a href="#4-3-6-配置权限" class="headerlink" title="4.3.6 配置权限"></a>4.3.6 配置权限</h4><p>上述我们已经创建了子用户, 但是这个子用户,目前没有任何权限,接下来,我们需要为创建的这个用户来分配权限。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022218318.png" alt="image-20210807183735533"> </p><p><font color='red'>经过上述的权限配置之后，那么新创建的这个 reggie 用户，仅有短信服务操作的权限，不具备别的权限，即使当前的AccessKey泄漏了，也只会影响短信服务，其他服务是不受影响的。</font></p><h4 id="4-3-7-禁用-x2F-删除AccessKey"><a href="#4-3-7-禁用-x2F-删除AccessKey" class="headerlink" title="4.3.7 禁用&#x2F;删除AccessKey"></a>4.3.7 禁用&#x2F;删除AccessKey</h4><p>如果在使用的过程中 AccessKey 不小心泄漏了,我们可以在阿里云控制台中, 禁用或者删除该AccessKey。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022218517.png" alt="image-20210807190005367"> </p><p>然后再创建一个新的AccessKey, 保存好AccessKeyId和AccessKeySecret。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022218575.png" alt="image-20210807190304136"> </p><p>&#x3D;&#x3D;注意： 创建好了AccessKey后，请及时保存AccessKeyId 和 AccessKeySecret ，弹窗关闭后将无法再次获取该信息，但您可以随时创建新的 AccessKey。&#x3D;&#x3D;</p><h3 id="4-4-代码开发"><a href="#4-4-代码开发" class="headerlink" title="4.4 代码开发"></a>4.4 代码开发</h3><p>使用阿里云短信服务发送短信，可以参照官方提供的文档即可。</p><p>官方文档: <a href="https://help.aliyun.com/product/44282.html?spm=5176.12212571.help.dexternal.57a91cbewHHjKq">https://help.aliyun.com/product/44282.html?spm=5176.12212571.help.dexternal.57a91cbewHHjKq</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022218814.png" alt="image-20210807193047220"> </p><p>我们根据官方文档的提示，引入对应的依赖，然后再引入对应的java代码，就可以发送消息了。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022219207.png" alt="image-20210807193829131"> </p><blockquote><p>SDK : SDK 就是 Software Development Kit 的缩写，翻译过来——软件开发工具包，辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK。在我们与第三方接口相互时， 一般都会提供对应的SDK，来简化我们的开发。</p></blockquote><p><strong>具体实现：</strong></p><p>1). pom.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-dysmsapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2). 将官方提供的main方法封装为一个工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.aliyuncs.DefaultAcsClient;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.IAcsClient;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.exceptions.ClientException;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.profile.DefaultProfile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 短信发送工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSUtils</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送短信</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> signName 签名</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> templateCode 模板</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> phoneNumbers 手机号</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String signName, String templateCode,String phoneNumbers,String param)</span>&#123;</span><br><span class="line">      <span class="type">DefaultProfile</span> <span class="variable">profile</span> <span class="operator">=</span> DefaultProfile.getProfile(<span class="string">&quot;cn-hangzhou&quot;</span>, <span class="string">&quot;xxxxxxxxxxxxxxxx&quot;</span>, <span class="string">&quot;xxxxxxxxxxxxxx&quot;</span>);</span><br><span class="line">      <span class="type">IAcsClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAcsClient</span>(profile);</span><br><span class="line"></span><br><span class="line">      <span class="type">SendSmsRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendSmsRequest</span>();</span><br><span class="line">      request.setSysRegionId(<span class="string">&quot;cn-hangzhou&quot;</span>);</span><br><span class="line">      request.setPhoneNumbers(phoneNumbers);</span><br><span class="line">      request.setSignName(signName);</span><br><span class="line">      request.setTemplateCode(templateCode);</span><br><span class="line">      request.setTemplateParam(<span class="string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+param+<span class="string">&quot;\&quot;&#125;&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">SendSmsResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.getAcsResponse(request);</span><br><span class="line">         System.out.println(<span class="string">&quot;短信发送成功&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注 : 由于我们个人目前无法申请阿里云短信服务，所以这里我们只需要把流程跑通，具体的短信发送可以实现。</p></blockquote><h2 id="5-手机验证码登录"><a href="#5-手机验证码登录" class="headerlink" title="5. 手机验证码登录"></a>5. 手机验证码登录</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><p>为了方便用户登录，移动端通常都会提供通过手机验证码登录的功能。手机验证码登录有如下优点：</p><p>1). 方便快捷，无需注册，直接登录</p><p>2). 使用短信验证码作为登录凭证，无需记忆密码</p><p>3). 安全</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022219823.png" alt="image-20210807232653592" style="zoom:80%;" />  <p><strong>登录流程：</strong></p><p>输入手机号 &gt; 获取验证码 &gt; 输入验证码 &gt; 点击登录 &gt; 登录成功</p><blockquote><p>注意：通过手机验证码登录，手机号是区分不同用户的标识。</p></blockquote><h3 id="5-2-数据模型"><a href="#5-2-数据模型" class="headerlink" title="5.2 数据模型"></a>5.2 数据模型</h3><p>通过手机验证码登录时，涉及的表为user表，即用户表。结构如下:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022219990.png" alt="image-20210807231948412"> </p><h3 id="5-3-前端页面分析"><a href="#5-3-前端页面分析" class="headerlink" title="5.3 前端页面分析"></a>5.3 前端页面分析</h3><p>在开发代码之前，需要梳理一下登录时前端页面和服务端的交互过程：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202117586.png" alt="image-20230620115713378"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">           getCode()&#123;</span><br><span class="line">               this.form.code = &#x27;&#x27;</span><br><span class="line">               const regex = /^(13[0-9]&#123;9&#125;)|(15[0-9]&#123;9&#125;)|(17[0-9]&#123;9&#125;)|(18[0-9]&#123;9&#125;)|(19[0-9]&#123;9&#125;)$/;</span><br><span class="line">               if (regex.test(this.form.phone)) &#123;   //校验手机号是否正确</span><br><span class="line">                   this.msgFlag = false</span><br><span class="line">                   //this.form.code = (Math.random()*1000000).toFixed(0)</span><br><span class="line">                   sendMsgApi(&#123;phone:this.form.phone&#125;)</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   this.msgFlag = true</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           async btnLogin()&#123;</span><br><span class="line">               if(this.form.phone &amp;&amp; this.form.code)&#123;</span><br><span class="line">                   this.loading = true</span><br><span class="line">                   const res = await loginApi(&#123;phone:this.form.phone&#125;)</span><br><span class="line">                   this.loading = false</span><br><span class="line">                   if(res.code === 1)&#123;</span><br><span class="line">                       sessionStorage.setItem(&quot;userPhone&quot;,this.form.phone)</span><br><span class="line">                       window.requestAnimationFrame(()=&gt;&#123;</span><br><span class="line">                           window.location.href= &#x27;/front/index.html&#x27;</span><br><span class="line">                       &#125;)                           </span><br><span class="line">                   &#125;else&#123;</span><br><span class="line">                       this.$notify(&#123; type:&#x27;warning&#x27;, message:res.msg&#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   this.$notify(&#123; type:&#x27;warning&#x27;, message:&#x27;请输入手机号码&#x27;&#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202117786.png" alt="image-20230620120410546"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202117274.png" alt="image-20230620120432811"></p><p>1). 在登录页面(front&#x2F;page&#x2F;login.html)输入手机号，点击【获取验证码】按钮，页面发送ajax请求，在服务端调用短信服务API给指定手机号发送验证码短信。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022219557.png" alt="image-20210807233018171" style="zoom:80%;" /> <p>2). 在登录页面输入验证码，点击【登录】按钮，发送ajax请求，在服务端处理登录请求。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118722.png" alt="image-20230620142428683"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118113.png" alt="image-20230620142601130"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202136592.png" alt="image-20230620142830237"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const res = await loginApi(&#123;phone:this.form.phone,code:this.form.code&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118417.png" alt="image-20230620204538628"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202128105.png" alt="image-20230620142858407"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022219429.png" alt="image-20210807233336029" style="zoom:80%;" /> <p>如果服务端返回的登录成功，页面将会把当前登录用户的手机号存储在sessionStorage中，并跳转到移动的首页页面。</p><p>开发手机验证码登录功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可，分别是获取短信验证码 和 登录请求，具体的请求信息如下： </p><p>1). 获取短信验证码</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;user&#x2F;sendMsg</td></tr><tr><td>请求参数</td><td>{“phone”:”13100001111”}</td></tr></tbody></table><p>2). 登录</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;user&#x2F;login</td></tr><tr><td>请求参数</td><td>{“phone”:”13100001111”, “code”:”1111”}</td></tr></tbody></table><h3 id="5-4-代码开发"><a href="#5-4-代码开发" class="headerlink" title="5.4 代码开发"></a>5.4 代码开发</h3><h4 id="5-4-1-准备工作"><a href="#5-4-1-准备工作" class="headerlink" title="5.4.1 准备工作"></a>5.4.1 准备工作</h4><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好：</p><p>1). 实体类 User（直接从课程资料中导入即可）</p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性别 0 女 1 男</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//身份证号</span></span><br><span class="line">    <span class="keyword">private</span> String idNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头像</span></span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态 0:禁用，1:正常</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2). Mapper接口 UserMapper</p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3). 业务层接口 UserService</p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4). 业务层实现类 UserServiceImpl</p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5). 控制层 UserController</p><p>所属包: com.itheima.reggie.controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6). 工具类SMSUtils、ValidateCodeUtils（直接从课程资料中导入即可）</p><p>所属包: com.itheima.reggie.utils</p><p>SMSUtils : 是我们上面改造的阿里云短信发送的工具类 ;</p><p>ValidateCodeUtils : 是验证码生成的工具类 ;</p><h4 id="5-4-2-功能实现"><a href="#5-4-2-功能实现" class="headerlink" title="5.4.2 功能实现"></a>5.4.2 功能实现</h4><h5 id="5-4-2-1-修改LoginCheckFilter"><a href="#5-4-2-1-修改LoginCheckFilter" class="headerlink" title="5.4.2.1 修改LoginCheckFilter"></a>5.4.2.1 修改LoginCheckFilter</h5><p>前面我们已经完成了LoginCheckFilter过滤器的开发，此过滤器用于检查用户的登录状态。我们在进行手机验证码登录时，发送的两个请求(获取验证码和登录)需要在此过滤器处理时直接放行。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022220289.png" alt="image-20210807235349089"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义不需要处理的请求路径</span><br><span class="line">String[] urls = new String[]&#123;</span><br><span class="line">        &quot;/employee/login&quot;,</span><br><span class="line">        &quot;/employee/logout&quot;,</span><br><span class="line">        &quot;/backend/**&quot;,</span><br><span class="line">        &quot;/front/**&quot;,</span><br><span class="line">        &quot;/common/**&quot;,</span><br><span class="line">        &quot;/user/sendMsg&quot;,   //移动端发送短信</span><br><span class="line">        &quot;/user/login&quot;     //移动端登录 </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118402.png" alt="image-20230620114551275"></p><p>F12</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118553.png" alt="image-20230620114653512"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202128345.png" alt="image-20230620114708640"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118561.png" alt="image-20230620135037375"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118593.png" alt="image-20230620135010733"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202128136.png" alt="image-20230620135152356"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118434.png" alt="image-20230620135220186"></p><p>4次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202119059.png" alt="image-20230620135305978"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202118619.png" alt="image-20230620135342419"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121346.png" alt="image-20230620135420111"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121370.png" alt="image-20230620135441174"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121145.png" alt="image-20230620135537976"></p><p>对于移动的端的页面，也是用户登录之后，才可以访问的，那么这个时候就需要在 LoginCheckFilter 中进行判定，如果移动端用户已登录，我们获取到用户登录信息，存入ThreadLocal中(在后续的业务处理中，如果需要获取当前登录用户ID，直接从ThreadLocal中获取)，然后放行。</p><p>增加如下逻辑: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4-2、判断登录状态，如果已登录，则直接放行</span></span><br><span class="line"><span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">    log.info(<span class="string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    BaseContext.setCurrentId(userId);</span><br><span class="line"></span><br><span class="line">    filterChain.doFilter(request,response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-4-2-2-发送短信验证码"><a href="#5-4-2-2-发送短信验证码" class="headerlink" title="5.4.2.2 发送短信验证码"></a>5.4.2.2 发送短信验证码</h5><p>在UserController中创建方法，处理登录页面的请求，为指定手机号发送短信验证码，同时需要将手机号对应的验证码保存到Session，方便后续登录时进行比对。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送手机短信验证码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/sendMsg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">//获取手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> user.getPhone();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(phone))&#123;</span><br><span class="line">        <span class="comment">//生成随机的4位验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> ValidateCodeUtils.generateValidateCode(<span class="number">4</span>).toString();</span><br><span class="line">        log.info(<span class="string">&quot;code=&#123;&#125;&quot;</span>,code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用阿里云提供的短信服务API完成发送短信</span></span><br><span class="line">        <span class="comment">//SMSUtils.sendMessage(&quot;瑞吉外卖&quot;,&quot;&quot;,phone,code);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要将生成的验证码保存到Session</span></span><br><span class="line">        session.setAttribute(phone,code);</span><br><span class="line">        <span class="keyword">return</span> R.success(<span class="string">&quot;手机验证码短信发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R.error(<span class="string">&quot;短信发送失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red'>备注: </font></p><p>​<font color='red'>这里发送短信我们只需要调用封装的工具类中的方法即可，我们这个功能流程跑通，在测试中我们不用真正的发送短信，只需要将验证码信息，通过日志输出，登录时，我们直接从控制台就可以看到生成的验证码(实际上也就是发送到我们手机上的验证码)</font></p></blockquote><h5 id="5-4-2-3-验证码登录"><a href="#5-4-2-3-验证码登录" class="headerlink" title="5.4.2.3 验证码登录"></a>5.4.2.3 验证码登录</h5><p>在UserController中增加登录的方法 login，该方法的具体逻辑为： </p><p>1). 获取前端传递的手机号和验证码</p><p>2). 从Session中获取到手机号对应的正确的验证码</p><p>3). 进行验证码的比对 , 如果比对失败, 直接返回错误信息</p><p>4). 如果比对成功, 需要根据手机号查询当前用户, 如果用户不存在, 则自动注册一个新用户</p><p>5). 将登录用户的ID存储Session中</p><p>@RestController<br>@RequestMapping(“&#x2F;user”)<br>@Slf4j<br>public class UserController {</p><pre><code>@Autowiredprivate UserService userService;/** * 移动端用户登录 * @param map * @param session * @return */@PostMapping(&quot;/login&quot;)public R&lt;User&gt; login(@RequestBody Map map, HttpSession session)&#123;    log.info(map.toString());    return R.error(&quot;登录失败&quot;);&#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121666.png" alt="image-20230620140135154"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121554.png" alt="image-20230620140326192"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121265.png" alt="image-20230620140405500"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121001.png" alt="image-20230620201728964"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202121738.png" alt="image-20230620201754467"></p><p>完整的具体代码实现: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移动端用户登录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;User&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> Map map, HttpSession session)</span>&#123;</span><br><span class="line">    log.info(map.toString());</span><br><span class="line">    <span class="comment">//获取手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> map.get(<span class="string">&quot;phone&quot;</span>).toString();</span><br><span class="line">    <span class="comment">//获取验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> map.get(<span class="string">&quot;code&quot;</span>).toString();</span><br><span class="line">    <span class="comment">//从Session中获取保存的验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">codeInSession</span> <span class="operator">=</span> session.getAttribute(phone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行验证码的比对（页面提交的验证码和Session中保存的验证码比对）</span></span><br><span class="line">    <span class="keyword">if</span>(codeInSession != <span class="literal">null</span> &amp;&amp; codeInSession.equals(code))&#123;</span><br><span class="line">        <span class="comment">//如果能够比对成功，说明登录成功</span></span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(User::getPhone,phone);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getOne(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册</span></span><br><span class="line">            user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setPhone(phone);</span><br><span class="line">            user.setStatus(<span class="number">1</span>);</span><br><span class="line">            userService.save(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>,user.getId());</span><br><span class="line">        <span class="keyword">return</span> R.success(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-功能测试"><a href="#5-5-功能测试" class="headerlink" title="5.5 功能测试"></a>5.5 功能测试</h3><p>代码完成后，重启服务，测试短信验证码的发送及登录功能。</p><p>1). 测试错误验证码的情况</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022220974.png" alt="image-20210808001952043" style="zoom:80%;" /> <p>2). 测试正确验证码的情况</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022220525.png" alt="image-20210808002356092"> </p><p>检查user表，用户的数据也插入进来了： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202304022231670.png" alt="image-20210808002501618"> </p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122442.png" alt="image-20230620203006358"></p><p>现在表是空的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202129201.png" alt="image-20230620202839771"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122994.png" alt="image-20230620202939790"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122834.png" alt="image-20230620203043299"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122282.png" alt="image-20230620203058216"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122042.png" alt="image-20230620203122377"></p><p>因为我又验证了一次  所以这里面的手机号和验证码和上图不同 是没错的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122194.png" alt="image-20230620204856792"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122114.png" alt="image-20230620205004372"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202122545.png" alt="image-20230620205032829"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202129001.png" alt="image-20230620205128785"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202123387.png" alt="image-20230620205211373"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202123610.png" alt="image-20230620205235073"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202123177.png" alt="image-20230620205315024"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202123073.png" alt="image-20230620205910888"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day05/202306202123802.png" alt="image-20230620205948162"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖-Day04</title>
      <link href="/archives/3.html"/>
      <url>/archives/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖-Day04"><a href="#瑞吉外卖-Day04" class="headerlink" title="瑞吉外卖-Day04"></a>瑞吉外卖-Day04</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>文件上传下载</li><li>菜品新增</li><li>菜品分页查询</li><li>菜品修改</li></ul><h2 id="1-文件上传下载"><a href="#1-文件上传下载" class="headerlink" title="1. 文件上传下载"></a>1. 文件上传下载</h2><h3 id="1-1-上传介绍"><a href="#1-1-上传介绍" class="headerlink" title="1.1 上传介绍"></a>1.1 上传介绍</h3><h4 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h4><p>文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022137162.png" alt="image-20210803081955246" style="zoom:80%;" /> <p>文件上传时，对页面的form表单有如下要求：</p><table><thead><tr><th>表单属性</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>method</td><td>post</td><td>必须选择post方式提交</td></tr><tr><td>enctype</td><td>multipart&#x2F;form-data</td><td>采用multipart格式上传文件</td></tr><tr><td>type</td><td>file</td><td>使用input的file控件上传</td></tr></tbody></table><h4 id="1-1-2-前端介绍"><a href="#1-1-2-前端介绍" class="headerlink" title="1.1.2 前端介绍"></a>1.1.2 前端介绍</h4><p><strong>1). 简单html页面表单</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/common/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2). ElementUI中提供的upload上传组件</strong></p><p>目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022140476.png" alt="image-20210803084742416"> </p><h4 id="1-1-3-服务端介绍"><a href="#1-1-3-服务端介绍" class="headerlink" title="1.1.3 服务端介绍"></a>1.1.3 服务端介绍</h4><p>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件：</p><ul><li><p>commons-fileupload</p></li><li><p>commons-io</p></li></ul><p>而Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">    <span class="keyword">return</span> R.success(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-下载介绍"><a href="#1-2-下载介绍" class="headerlink" title="1.2 下载介绍"></a>1.2 下载介绍</h3><p>文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程。通过浏览器进行文件下载，通常有两种表现形式：</p><p><strong>1). 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022140330.png" alt="image-20210803123858691"> </p><p><strong>2). 直接在浏览器中打开</strong></p><p>而我们在今天所需要实现的菜品展示，表现形式为在浏览器中直接打开。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022140466.png" alt="image-20210803124220869">  </p><p>通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程。</p><h3 id="1-3-上传代码实现"><a href="#1-3-上传代码实现" class="headerlink" title="1.3 上传代码实现"></a>1.3 上传代码实现</h3><h4 id="1-3-1-前端代码"><a href="#1-3-1-前端代码" class="headerlink" title="1.3.1 前端代码"></a>1.3.1 前端代码</h4><p>文件上传，我们作为服务端工程师，主要关注服务端代码实现。对于前端页面，可以使用ElementUI提供的上传组件。可以直接使用资料中提供的上传页面，位置：资料&#x2F;文件上传下载页面&#x2F;upload.html，将其拷贝到项目的目录(resources&#x2F;backend&#x2F;page&#x2F;demo)下，启动项目，访问上传页面。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/backend/page/demo/upload.html</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182335733.png" alt="image-20230617160907397"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182335112.png" alt="image-20230617160946756"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182337340.png" alt="image-20230617161137316"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;el-upload class=&quot;avatar-uploader&quot; </span><br><span class="line">                action=&quot;/common/upload&quot;    //地址</span><br><span class="line">                :show-file-list=&quot;false&quot;</span><br><span class="line">                :on-success=&quot;handleAvatarSuccess&quot;</span><br><span class="line">                :before-upload=&quot;beforeUpload&quot;</span><br><span class="line">                ref=&quot;upload&quot;&gt;</span><br><span class="line">            &lt;img v-if=&quot;imageUrl&quot; :src=&quot;imageUrl&quot; class=&quot;avatar&quot;&gt;&lt;/img&gt;</span><br><span class="line">            &lt;i v-else class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt;</span><br><span class="line">        &lt;/el-upload&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182335941.png" alt="image-20230617161555194"></p><p><a href="http://localhost:8080/backend/page/demo/upload.html">http://localhost:8080/backend/page/demo/upload.html</a></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022140297.png" alt="image-20210803125619732" style="zoom:80%;" /> <p>在上述的浏览器抓取的网络请求中，上传文件的调用url，在哪里配置的呢，这个时候，我们需要去看一下前端上传组件。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022140595.png" alt="image-20210803125942295" style="zoom:80%;" /> <p>虽然上述是ElementUI封装的代码，但是实际上最终还通过file域上传文件，如果未指定上传文件的参数名，默认为file。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022140793.png" alt="image-20210803130455590" style="zoom:80%;" /> <p>视频分析</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file)&#123;</span><br><span class="line">      //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除</span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182336374.png" alt="image-20230617163730948"></p><p>这里面明明加了断点 可是并没有走到这边过来    这是因为在过滤器这边就已经被打回了</p><p>NOTLOGIN是从哪里来的  </p><p>没有登录的话  要先登录 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182336273.png" alt="image-20230617165035460"></p><p>所以我们有二种方案  第一种方案   就是先登录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182336038.png" alt="image-20230617165728528"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182336654.png" alt="image-20230617165741304"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182336072.png" alt="image-20230617165813442"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182336442.png" alt="image-20230617165836111"></p><p>第二种方案</p><p>定义不需要处理的请求路径</p><p>我们可以在 LoginCheckFilter 的doFilter方法中，在不需要处理的请求路径的数组中再加入请求路径 &#x2F;common&#x2F;** , 如下: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182337366.png" alt="image-20230617165341503"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182338332.png" alt="image-20230617163836113"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file)&#123;</span><br><span class="line"></span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //将临时文件转存到指定位置</span><br><span class="line">            file.transferTo(new File(&quot;D:\\hello.jpg&quot;));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341756.png" alt="image-20230617200248063"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190000401.png" alt="image-20230617200321069"></p><p>现在是没有   </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341819.png" alt="image-20230617200419296"></p><p>现在转存后</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341563.png" alt="image-20230617200445676"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190001566.png" alt="image-20230617200503743"></p><p>动态转存</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341963.png" alt="image-20230617201959823"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">    private String basePath;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file)&#123;</span><br><span class="line"></span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //将临时文件转存到指定位置</span><br><span class="line">            file.transferTo(new File(basePath + &quot;hello.jpg&quot;));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341515.png" alt="image-20230617201225568"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190001506.png" alt="image-20230617201406893"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341579.png" alt="image-20230617202024843"></p><p>动态获取文件名</p><p>方式一</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">    private String basePath;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file)&#123;</span><br><span class="line"></span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        //原始文件名</span><br><span class="line">        String originalFilename = file.getOriginalFilename();//abc.jpg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //将临时文件转存到指定位置</span><br><span class="line">            file.transferTo(new File(basePath + originalFilename));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341067.png" alt="image-20230617202626421"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190010589.png" alt="image-20230617202823013"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190001178.png" alt="image-20230617202836468"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182341747.png" alt="image-20230617202925888"></p><p>方式2</p><p>测试</p><p>截取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.test;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">public class UploadFileTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  void test1()&#123;</span><br><span class="line">        String fileName = &quot;ererewe.jpg&quot;;</span><br><span class="line">        String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));</span><br><span class="line">        System.out.println(suffix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182342635.png" alt="image-20230617204355802"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190011841.png" alt="image-20230617204412599"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">    private String basePath;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file)&#123;</span><br><span class="line"></span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        //原始文件名</span><br><span class="line">        String originalFilename = file.getOriginalFilename();//abc.jpg</span><br><span class="line"></span><br><span class="line">        String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line"></span><br><span class="line">        //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span><br><span class="line">        String fileName = UUID.randomUUID().toString() + suffix;//dfsdfdfd.jpg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //将临时文件转存到指定位置</span><br><span class="line">            file.transferTo(new File(basePath + fileName));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182342043.png" alt="image-20230617204718852"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190001219.png" alt="image-20230617204812872"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190001674.png" alt="image-20230617204826396"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182342331.png" alt="image-20230617204851635"></p><p>把图片放在文件夹里面</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182342835.png" alt="image-20230617205056176"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.controller;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件上传和下载</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CommonController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">    private String basePath;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 文件上传</span><br><span class="line">     * @param file</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file)&#123;</span><br><span class="line"></span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        //原始文件名</span><br><span class="line">        String originalFilename = file.getOriginalFilename();//abc.jpg</span><br><span class="line"></span><br><span class="line">        String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line"></span><br><span class="line">        //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span><br><span class="line">        String fileName = UUID.randomUUID().toString() + suffix;//dfsdfdfd.jpg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //创建一个目录对象</span><br><span class="line">        File dir = new File(basePath);</span><br><span class="line">        //判断当前目录是否存在</span><br><span class="line">        if(!dir.exists())&#123;</span><br><span class="line">            //目录不存在，需要创建</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //将临时文件转存到指定位置</span><br><span class="line">            file.transferTo(new File(basePath + fileName));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182342708.png" alt="image-20230617205415644"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182342451.png" alt="image-20230617205510994"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190002866.png" alt="image-20230617205533747"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182342659.png" alt="image-20230617205552892"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190011322.png" alt="image-20230617205606090"></p><h4 id="1-3-2-服务端实现"><a href="#1-3-2-服务端实现" class="headerlink" title="1.3.2 服务端实现"></a>1.3.2 服务端实现</h4><p><strong>1). application.yml</strong></p><p>需要在application.yml中定义文件存储路径</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reggie:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">D:\img\</span></span><br></pre></td></tr></table></figure><p><strong>2). CommonController</strong></p><p>编写文件上传的方法, 通过MultipartFile类型的参数即可接收上传的文件, 方法形参的名称需要与页面的file域的name属性一致。</p><p>所在包: com.itheima.reggie.controller</p><p>上传逻辑: </p><p>1). 获取文件的原始文件名, 通过原始文件名获取文件后缀</p><p>2). 通过UUID重新声明文件名, 文件名称重复造成文件覆盖</p><p>3). 创建文件存放目录</p><p>4). 将上传的临时文件转存到指定位置</p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.common.R;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传和下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">        <span class="comment">//file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除</span></span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();<span class="comment">//abc.jpg</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;<span class="comment">//dfsdfdfd.jpg</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个目录对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">        <span class="comment">//判断当前目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">            <span class="comment">//目录不存在，需要创建</span></span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将临时文件转存到指定位置</span></span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + fileName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.success(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="1-3-3-测试"><a href="#1-3-3-测试" class="headerlink" title="1.3.3 测试"></a>1.3.3 测试</h4><p>代码编写完成之后，我们重新启动项目，访问上传页面 <a href="http://localhost:8080/backend/page/demo/upload.html%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%8E%B0%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%B8%8A%E4%BC%A0%EF%BC%8C%E8%80%8C%E4%B8%94%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8A%93%E5%8F%96%E5%88%B0%E5%93%8D%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E5%9B%BE%E4%B8%AD%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%88%A4%E6%96%AD%E5%87%BA%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95%E6%89%8D%E5%8F%AF%E4%BB%A5%E6%93%8D%E4%BD%9C%E3%80%82">http://localhost:8080/backend/page/demo/upload.html，然后点击上传图片，选择图片上传时，会发现图片并不能正常的上传，而且在浏览器中可以抓取到响应的数据，从图中我们可以判断出需要登录才可以操作。</a></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022140963.png" alt="image-20210803232054156" style="zoom:80%;" /> <p>而这样的话，就要求我们在测试时，每一次都需要先登录，登录完成后在进行图片上传的测试，为了简化我们的测试，我们可以在 LoginCheckFilter 的doFilter方法中，在不需要处理的请求路径的数组中再加入请求路径 &#x2F;common&#x2F;** , 如下: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022141778.png" alt="image-20210803232433983" style="zoom:80%;" /> <p>然后，我们在测试文件的上传功能时，就不需要登录就可以操作了。 </p><p>我们在测试文件上传时，可以通过debug的形式来跟踪上传的整个过程，验证一下临时文件是否存在，以及上传完成之后，临时文件是否会自动删除。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022141130.png" alt="image-20210805160234154"> </p><h3 id="1-4-下载代码实现"><a href="#1-4-下载代码实现" class="headerlink" title="1.4 下载代码实现"></a>1.4 下载代码实现</h3><h4 id="1-4-1-前端代码"><a href="#1-4-1-前端代码" class="headerlink" title="1.4.1 前端代码"></a>1.4.1 前端代码</h4><p>文件下载，前端页面可以使用<img>标签展示下载的图片。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-if</span>=<span class="string">&quot;imageUrl&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;imageUrl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182343163.png" alt="image-20230617210100925"></p><p>当文件上传完成之后  就会回调handleAvatarSuccess（）方法</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182343795.png" alt="image-20230617210402606"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      new Vue(&#123;</span><br><span class="line">        el: &#x27;#food-add-app&#x27;,</span><br><span class="line">        data() &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            imageUrl: &#x27;&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">          handleAvatarSuccess (response, file, fileList) &#123;</span><br><span class="line">          //拿到返回的文件名称  然后给imageUrl赋值</span><br><span class="line">          //请求路径 把请求name参数带过去  而且这个name就是完成上传之后 动态生成的值fileName</span><br><span class="line">              this.imageUrl = `/common/download?name=$&#123;response.data&#125;` </span><br><span class="line">          &#125;,</span><br><span class="line">          beforeUpload (file) &#123;</span><br><span class="line">            if(file)&#123;</span><br><span class="line">              const suffix = file.name.split(&#x27;.&#x27;)[1]</span><br><span class="line">              const size = file.size / 1024 / 1024 &lt; 2</span><br><span class="line">              if([&#x27;png&#x27;,&#x27;jpeg&#x27;,&#x27;jpg&#x27;].indexOf(suffix) &lt; 0)&#123;</span><br><span class="line">                this.$message.error(&#x27;上传图片只支持 png、jpeg、jpg 格式！&#x27;)</span><br><span class="line">                this.$refs.upload.clearFiles()</span><br><span class="line">                return false</span><br><span class="line">              &#125;</span><br><span class="line">              if(!size)&#123;</span><br><span class="line">                this.$message.error(&#x27;上传文件大小不能超过 2MB!&#x27;)</span><br><span class="line">                return false</span><br><span class="line">              &#125;</span><br><span class="line">              return file</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>那么，通过<img>标签如何展示图片数据呢，接下来我们来解析一下具体的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022141683.png" alt="image-20210803224818828"> </p><p>在文件上传成功后，在 handleAvatarSuccess 方法中获取文件上传成功之后返回的数据(文件名)，然后调用 &#x2F;common&#x2F;download?name&#x3D;xxx 进行文件的下载。在这里，我们想让上传的照片能够在页面展示出来，所以我们就需要在服务端将文件以流的形式写回浏览器。</p><h4 id="1-4-2-服务端代码"><a href="#1-4-2-服务端代码" class="headerlink" title="1.4.2 服务端代码"></a>1.4.2 服务端代码</h4><p>在 CommonController 中定义方法download，并接收页面传递的参数name，然后读取图片文件的数据，然后以流的形式写回浏览器。</p><p>具体逻辑如下： </p><p>1). 定义输入流，通过输入流读取文件内容</p><p>2). 通过response对象，获取到输出流</p><p>3). 通过response对象设置响应数据格式(image&#x2F;jpeg)</p><p>4). 通过输入流读取文件数据，然后通过上述的输出流写回浏览器</p><p>5). 关闭资源</p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件下载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String name, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//输入流，通过输入流读取文件内容</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + name));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出流，通过输出流将文件写回浏览器</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个用于文件下载的方法。该方法接收一个文件名（name）和 HttpServletResponse 对象作为参数。</p><p>在方法中，首先创建一个 FileInputStream 对象，用于读取文件内容。该对象通过传入的文件名和基本路径（basePath）构建文件的完整路径。</p><p>接下来，创建一个 ServletOutputStream 对象，用于将文件内容写回浏览器。这个对象通过调用 HttpServletResponse 对象的 getOutputStream() 方法获取。</p><p>设置响应的内容类型为 “image&#x2F;jpeg”，这表示下载的文件类型为 JPEG 图片，可以根据实际情况修改为其他类型。</p><p>然后，通过循环读取文件内容并写入输出流。循环的条件是每次读取的字节数不等于 -1（即文件还未读取完毕）。读取的内容存储在一个字节数组中，每次写入输出流并刷新。</p><p>最后，在文件读取完成后，关闭输出流和输入流，释放资源。</p><p>如果在执行过程中发生异常，将打印异常堆栈信息（e.printStackTrace()）。</p><p>请注意，以上代码只是一个简单的文件下载示例，可能需要根据具体需求进行修改和完善。例如，可以添加异常处理、文件不存在的判断、设置下载文件的名称等。</p><p>代码解释2</p><p>当你在网页中点击下载按钮时，该方法会被调用，并将指定的文件发送给用户以供下载。下面是对每一行代码的详细解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String name, HttpServletResponse response)</span>&#123;</span><br></pre></td></tr></table></figure><p>这是一个使用@GetMapping注解的方法，它将处理来自”&#x2F;download”路径的GET请求。它接收一个名为”name”的参数，表示要下载的文件名。而”HttpServletResponse”对象则用于向浏览器发送响应。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + name));</span><br></pre></td></tr></table></figure><p>在这里，我们创建了一个FileInputStream对象，它将用于从磁盘读取文件内容。通过将basePath和name连接在一起，我们构建了文件的完整路径。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br></pre></td></tr></table></figure><p>这一行代码创建了一个ServletOutputStream对象，用于将文件内容写回浏览器。我们通过调用response对象的getOutputStream()方法来获取输出流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br></pre></td></tr></table></figure><p>这一行代码设置了响应的内容类型为”image&#x2F;jpeg”，表示要下载的文件类型为JPEG图片。你可以根据实际情况修改这个内容类型，以适应其他文件类型的下载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    outputStream.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">    outputStream.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个循环，用于逐块地从文件输入流读取文件内容，并将每块内容写入输出流。我们首先创建一个长度为1024的字节数组来存储每次读取的文件内容。</p><p>循环的条件是每次读取的字节数不等于-1，这表示文件还没有完全读取。在循环中，我们使用outputStream.write()方法将每次读取的内容写入输出流，并使用outputStream.flush()方法刷新输出流，确保内容被发送给浏览器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outputStream.close();</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure><p>在文件读取和写入完成后，我们关闭了输出流和输入流，释放了与文件相关的资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个catch块中，我们捕获任何可能发生的异常，并打印异常堆栈信息。这有助于调试和发现在文件下载过程中出现的问题。</p><p>请注意，以上代码只是一个简单的文件下载示例，可能需要根据具体需求进行修改和完善。例如，可以添加异常处理、文件不存在的判断、设置下载文件的名称等。</p><p>代码解释3</p><p>以上代码是一个文件下载的控制器方法，定义了一个GetMapping请求映射，用于处理浏览器发起的文件下载请求。方法中包含两个参数：name和response。name是指被下载的文件名，response是指HttpServletResponse对象，用于操作HTTP响应。</p><p>在方法中，首先创建了一个FileInputStream对象，通过该对象读取basePath下的指定文件内容。然后创建了一个ServletOutputStream对象，通过该对象将文件的内容写回浏览器。接着设置了响应的contentType类型为”image&#x2F;jpeg”，以便浏览器可以正确解析文件内容。</p><p>最后，通过while循环读取文件内容，并将其通过输出流写回浏览器，直到文件读取完毕。关闭资源，结束文件下载操作。</p><p>该方法适用于下载图片、PDF、Word文档等类型的文件，并且可以灵活配置basePath参数，以适应多种文件下载需求。</p><h4 id="1-4-3-测试"><a href="#1-4-3-测试" class="headerlink" title="1.4.3 测试"></a>1.4.3 测试</h4><p>访问页面 <a href="http://localhost:8080/backend/page/demo/upload.html">http://localhost:8080/backend/page/demo/upload.html</a> , 点击上传图片 , 选择图片进行上传, 上传完毕之后, 查看图片是否可以展示出来。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022141026.png" alt="image-20210803231134157"  /> <p>通过F12查询页面发起的请求及响应的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022141690.png" alt="image-20210803231302464"> </p><h2 id="2-菜品新增"><a href="#2-菜品新增" class="headerlink" title="2. 菜品新增"></a>2. 菜品新增</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>后台系统中可以管理菜品信息，通过 新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息 。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022142170.png" alt="image-20210803234122966"> </p><h3 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2 数据模型"></a>2.2 数据模型</h3><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022142082.png" alt="image-20210803235329340" style="zoom:80%;" /> <p>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据。所以在新增菜品时，涉及到两个表：</p><table><thead><tr><th>表结构</th><th>说明</th></tr></thead><tbody><tr><td>dish</td><td>菜品表</td></tr><tr><td>dish_flavor</td><td>菜品口味表</td></tr></tbody></table><p><strong>1). 菜品表:dish</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022142171.png" alt="image-20210803235459347" style="zoom:80%;" /> <p><strong>2). 菜品口味表:dish_flavor</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022142042.png" alt="image-20210803235749393" style="zoom:80%;" /> <h3 id="2-3-准备工作"><a href="#2-3-准备工作" class="headerlink" title="2.3 准备工作"></a>2.3 准备工作</h3><p>在开发业务功能前，先将需要用到的类和接口基本结构创建好：</p><p><strong>1). 实体类 DishFlavor</strong></p><p>直接从课程资料中导入即可，Dish实体前面课程中已经导入过了</p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">菜品口味</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishFlavor</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//菜品id</span></span><br><span class="line">    <span class="keyword">private</span> Long dishId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//口味名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//口味数据list</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否删除</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). Mapper接口DishFlavorMapper</strong></p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.DishFlavor;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishFlavorMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;DishFlavor&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个Java接口文件，使用了MyBatis Plus框架的注解和继承关系。</p><ol><li><p><code>import com.baomidou.mybatisplus.core.mapper.BaseMapper;</code> 导入了 MyBatis Plus 框架的 <code>BaseMapper</code> 接口，该接口是 MyBatis Plus 提供的基础映射器接口，提供了常见的数据库操作方法。</p></li><li><p><code>import com.itheima.reggie.entity.DishFlavor;</code> 导入了一个名为 <code>DishFlavor</code> 的实体类，该类可能定义了与数据库表中某个表对应的实体属性。</p></li><li><p><code>import org.apache.ibatis.annotations.Mapper;</code> 导入了 MyBatis 的 <code>Mapper</code> 注解，用于将接口标记为 MyBatis 的映射器接口。</p></li><li><p><code>@Mapper</code> 注解标记在接口上，表示这个接口是 MyBatis 的映射器接口，用于定义数据库操作的方法。</p></li><li><p><code>public interface DishFlavorMapper extends BaseMapper&lt;DishFlavor&gt;</code> 表示 <code>DishFlavorMapper</code> 接口继承了 <code>BaseMapper&lt;DishFlavor&gt;</code> 接口，继承关系意味着 <code>DishFlavorMapper</code> 接口会继承 <code>BaseMapper</code> 接口中定义的数据库操作方法，并且指定了泛型参数为 <code>DishFlavor</code>，表示这个映射器接口处理的实体类是 <code>DishFlavor</code>。</p></li></ol><p>综上所述，以上代码定义了一个 MyBatis Plus 的映射器接口 <code>DishFlavorMapper</code>，该接口继承了 <code>BaseMapper</code> 接口，并使用了 <code>@Mapper</code> 注解标记。这个接口可以用于对数据库中名为 <code>DishFlavor</code> 的表进行增删改查等数据库操作。</p><p>代码解释2</p><p>以上代码是一个Java接口定义，名为<code>DishFlavorMapper</code>，它扩展了一个名为<code>BaseMapper</code>的接口，并指定了泛型参数为<code>DishFlavor</code>。</p><p>这个接口的作用是定义与数据库表”dish_flavor”相关的操作方法，以便在应用程序中进行数据库操作。通过继承<code>BaseMapper</code>接口，<code>DishFlavorMapper</code>接口可以继承和使用<code>BaseMapper</code>中定义的通用数据库操作方法，如插入、更新、删除和查询等。</p><p>通常情况下，<code>BaseMapper</code>接口可能会定义一些基本的CRUD（创建、读取、更新、删除）方法，而<code>DishFlavorMapper</code>接口可以定义特定于”dish_flavor”表的定制方法，以满足具体业务需求。</p><p>在这个接口中并没有提供具体的方法实现，而是只定义了接口的签名。实际的方法实现需要由具体的类来提供，通常是通过使用MyBatis、Hibernate等ORM（对象关系映射）框架来生成具体的实现代码。</p><p>总之，以上代码定义了一个接口<code>DishFlavorMapper</code>，它扩展了<code>BaseMapper</code>接口，并定义了与”dish_flavor”表相关的数据库操作方法的契约。具体的方法实现将由其他类提供。</p><p>@Mapper的解释</p><p>使用<code>@Mapper</code>注解后，MyBatis会自动为该接口生成一个实现类，无需手动编写实现类的代码。</p><p>当使用MyBatis框架时，<code>@Mapper</code>注解用于标识一个接口是一个Mapper接口。Mapper接口定义了与数据库交互的方法。使用<code>@Mapper</code>注解后，MyBatis会自动为该接口生成一个实现类，无需手动编写实现类的代码。</p><p>具体来说，使用<code>@Mapper</code>注解的Mapper接口中的方法会与对应的XML文件中的SQL语句进行映射。XML文件中定义了与数据库交互的SQL语句，而Mapper接口中的方法命名和参数与这些SQL语句对应。当调用Mapper接口中的方法时，MyBatis会根据方法名和参数自动寻找对应的SQL语句并执行，然后返回结果。</p><p>以下是一个示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>UserMapper</code>接口被<code>@Mapper</code>注解标记为一个Mapper接口。它定义了与用户表相关的数据库操作方法，如根据用户ID获取用户信息、插入新用户、更新用户信息和删除用户等。</p><p>MyBatis根据这些方法的命名和参数来映射对应的SQL语句，例如，<code>getUserById</code>方法对应查询某个用户的SQL语句，<code>insertUser</code>方法对应插入用户的SQL语句，以此类推。</p><p>使用<code>@Mapper</code>注解后，还需要在配置类（或者使用<code>@SpringBootApplication</code>注解的主类）上添加<code>@MapperScan</code>注解，指定Mapper接口所在的包路径。这样，Spring会自动扫描并注册这些Mapper接口的实现类。</p><p>总结来说，<code>@Mapper</code>注解用于标识一个接口是MyBatis的Mapper接口。MyBatis根据Mapper接口的方法与XML文件中的SQL语句进行映射，自动生成实现类来执行数据库操作。这样，开发者只需编写Mapper接口的方法，而无需编写具体的实现代码。</p><p><strong>3). 业务层接口 DishFlavorService</strong></p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.DishFlavor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishFlavorService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;DishFlavor&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个Java接口定义，名为<code>DishFlavorService</code>，它扩展了一个名为<code>IService</code>的接口，并指定了泛型参数为<code>DishFlavor</code>。</p><p>这个接口的作用是定义与<code>DishFlavor</code>实体相关的服务方法，用于在应用程序中提供对<code>DishFlavor</code>对象的操作和处理。</p><p><code>IService</code>接口通常用于定义通用的服务层接口，包含了对实体对象的常见操作，如创建、更新、删除和查询等。通过扩展<code>IService</code>接口，<code>DishFlavorService</code>接口可以继承和使用<code>IService</code>中定义的通用服务方法，以便在应用程序中对<code>DishFlavor</code>对象进行操作。</p><p>在这个接口中并没有提供具体的方法实现，而是只定义了接口的签名。实际的方法实现需要由具体的类来提供，通常是通过创建一个实现了<code>DishFlavorService</code>接口的类，并在该类中编写具体的方法实现。</p><p>总之，以上代码定义了一个接口<code>DishFlavorService</code>，它扩展了<code>IService</code>接口，并定义了与<code>DishFlavor</code>实体相关的服务方法的契约。具体的方法实现将由其他类提供。这样的设计模式可以帮助在应用程序中组织和管理对<code>DishFlavor</code>对象的操作和处理逻辑。</p><p><strong>4). 业务层实现类 DishFlavorServiceImpl</strong></p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.DishFlavor;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.DishFlavorMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.DishFlavorService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishFlavorServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;DishFlavorMapper,DishFlavor&gt; <span class="keyword">implements</span> <span class="title class_">DishFlavorService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个Java类的定义，它声明了一个名为”DishFlavorServiceImpl”的类，该类扩展了”ServiceImpl&lt;DishFlavorMapper,DishFlavor&gt;”类，并实现了”DishFlavorService”接口。</p><p>在代码中使用了@Service注解，这是Spring框架中的注解之一，用于将该类标记为一个服务组件。@Service注解的作用是告诉Spring框架该类需要被扫描并注册为一个可用的服务组件，以便其他组件可以通过依赖注入的方式使用它。</p><p>类的定义中还指定了两个泛型参数，即”DishFlavorMapper”和”DishFlavor”。这表明该类在实现业务逻辑时将使用一个名为”DishFlavorMapper”的对象来访问数据库，并操作类型为”DishFlavor”的实体对象。</p><p>通过继承”ServiceImpl&lt;DishFlavorMapper,DishFlavor&gt;”类，该类继承了一些基本的服务实现方法，如增删改查等，这些方法可用于处理与”DishFlavor”实体相关的业务逻辑。</p><p>最后，由于该类实现了”DishFlavorService”接口，它必须提供该接口中定义的所有方法的具体实现。这意味着除了继承的基本服务方法外，开发人员还需要根据接口的要求添加额外的方法实现。</p><p>综上所述，以上代码定义了一个服务组件类”DishFlavorServiceImpl”，该类使用了Spring框架的@Service注解进行标记，并提供了基本的服务实现方法，以及根据”DishFlavorService”接口的要求添加了其他方法的实现。</p><p><strong>5). 控制层 DishController</strong></p><p>菜品及菜品口味的相关操作，我们统一使用这一个controller即可。</p><p>所属包： com.itheima.reggie.controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.DishFlavorService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.DishService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜品管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/dish&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishFlavorService dishFlavorService;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>@RestController的理解 </p><p><code>@RestController</code> 是一个 Spring 框架中的注解，它用于标识一个类是一个 RESTful Web 服务的控制器。</p><p>在 Spring MVC 中，<code>@RestController</code> 注解与 <code>@Controller</code> 注解类似，但有一个关键的区别。<code>@Controller</code> 注解通常用于传统的基于视图的 Web 应用程序，其中控制器处理用户请求并返回视图。而 <code>@RestController</code> 注解则更适用于构建 RESTful Web 服务，其中控制器处理客户端的请求，并直接返回数据作为响应，而不是返回视图。</p><p>当一个类被标记为 <code>@RestController</code> 时，Spring 框架会自动处理 HTTP 请求和响应，并将方法的返回值序列化为 JSON 或 XML 格式的数据。这样，你可以轻松地构建基于 RESTful 架构风格的 Web 服务，并使用各种 HTTP 方法（如 GET、POST、PUT、DELETE）处理不同的请求。</p><p>以下是一个简单的使用 <code>@RestController</code> 的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>@RestController</code> 标记了 <code>MyController</code> 类，表明它是一个 RESTful Web 服务的控制器。<code>@GetMapping(&quot;/hello&quot;)</code> 注解指定了处理 HTTP GET 请求的方法，并返回一个字符串 “Hello, World!” 作为响应。</p><p>总而言之，<code>@RestController</code> 注解简化了构建 RESTful Web 服务的过程，使得处理客户端请求和返回数据变得更加直观和方便。</p><p><code>@RestController</code> 注解也是用于将类交给 Spring 框架进行管理。当使用 <code>@RestController</code> 注解标记一个类时，Spring 会自动将该类实例化并管理其生命周期，使其成为应用程序的一个组件。</p><p>与传统的基于视图的控制器不同，<code>@RestController</code> 注解的类专注于构建基于 RESTful 架构风格的 Web 服务，因此处理的是客户端请求和数据的返回，而不是返回视图。这意味着 <code>@RestController</code> 注解的类中的方法通常会返回数据，例如 JSON 或 XML 格式的数据，而不是渲染视图。</p><p>通过 <code>@RestController</code> 注解，Spring 框架会自动处理 HTTP 请求和响应的细节，包括序列化和反序列化数据、处理异常等。这样，你可以专注于定义处理请求的方法和业务逻辑，而无需关心底层的请求和响应处理细节。</p><p>总结来说，<code>@RestController</code> 注解将一个类声明为基于 RESTful Web 服务的控制器，让 Spring 框架自动管理该类，并处理与 RESTful 服务相关的请求和响应，使开发 RESTful Web 服务变得更加简单和高效。</p><p>代码解释1</p><p>这段代码是一个用于管理菜品的控制器（Controller）类。它使用了Spring框架的@RestController注解，表明这个类是一个RESTful风格的控制器，可以处理HTTP请求。</p><p>@RequestMapping(“&#x2F;dish”)注解指定了处理该控制器下的URL路径，即”&#x2F;dish”。这意味着当客户端发送带有”&#x2F;dish”路径的HTTP请求时，该控制器将处理该请求。</p><p>@Slf4j注解是用于生成日志的注解，它使用了一个名为”log”的日志记录器，可以用来在代码中打印日志信息。</p><p>@Autowired注解是Spring框架的依赖注入注解，用于自动装配依赖。在这段代码中，它将DishService和DishFlavorService注入到了DishController类中。这意味着DishController可以使用这两个服务类中的方法和属性，而不需要手动创建它们的实例。</p><p>综上所述，这段代码定义了一个用于管理菜品的RESTful控制器类，它通过自动装配DishService和DishFlavorService来实现对菜品和菜品口味的管理。</p><p>代码解释2</p><p>这段代码是一个用于管理菜品的控制器类。它的作用就像一个中介，负责接收来自其他程序或客户端的请求，并根据请求的内容进行相应的处理和返回结果。</p><p>@RestController注解告诉框架这个类是一个用于处理网络请求的控制器。它允许我们使用常见的HTTP方法（例如GET、POST、PUT、DELETE）来处理不同的请求。</p><p>@RequestMapping(“&#x2F;dish”)注解指定了这个控制器处理的URL路径，也就是以”&#x2F;dish”开头的路径。例如，如果客户端发送一个请求到”&#x2F;dish&#x2F;add”，那么这个控制器就会被调用来处理这个请求。</p><p>@Slf4j注解是一个日志生成器，它允许我们在代码中打印日志信息。日志是一种记录程序运行过程中重要信息的方式，可以帮助开发人员调试和追踪问题。</p><p>@Autowired注解是Spring框架的一个功能，它能够自动为我们创建对象的实例，并将其注入到需要使用它的地方。在这段代码中，它将DishService和DishFlavorService这两个服务类注入到DishController类中。服务类是用来处理具体的业务逻辑的，通过注入，我们可以直接使用这两个服务类提供的功能，可以使用DishService和DishFlavorService这两个服务类的属性和方法，而不需要手动创建它们的实例。</p><p>总的来说，这段代码定义了一个控制器类，用于管理菜品。它可以接收并处理来自其他程序或客户端的请求，根据请求的内容调用相应的服务类来完成具体的业务逻辑，最后返回处理结果。通过自动注入服务类，我们可以方便地使用它们提供的功能，而无需手动创建实例。日志功能则可以帮助我们记录重要的运行信息，方便调试和追踪问题。</p><h3 id="2-4-前端页面分析"><a href="#2-4-前端页面分析" class="headerlink" title="2.4 前端页面分析"></a>2.4 前端页面分析</h3><p>基本的准备工作我们已经做完了，那么接下来我们就需要来实现新增菜品功能，在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程。</p><p>1). 点击新建菜品按钮, 访问页面(backend&#x2F;page&#x2F;food&#x2F;add.html), 页面加载时发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182343500.png" alt="image-20230618142932844"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190002449.png" alt="image-20230618144727052"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182343907.png" alt="image-20230618144816327"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190012730.png" alt="image-20230618144848150"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182343483.png" alt="image-20230618144939162"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182344539.png" alt="image-20230618145126568"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">params是&#x27;type&#x27;: 1  1是代表菜品分类</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182344035.png" alt="image-20230618145321942"></p><p>查完之后  我们要给他一个响应   响应回来之后  会回调一个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回调这个函数</span><br><span class="line">then(res =&gt; &#123;</span><br><span class="line">              if (res.code === 1) &#123;</span><br><span class="line">                this.dishList = res.data    //给dishList进行赋值 </span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                this.$message.error(res.msg || &#x27;操作失败&#x27;)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>dishList对应的就是我们页面上的下拉框</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182344388.png" alt="image-20230618145840131"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190003577.png" alt="image-20230618145936618"></p><p>就可以通过数据绑定的方式进行显示</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022142586.png" alt="image-20210804003343531"> </p><p>2). 页面发送请求进行图片上传，请求服务端将图片保存到服务器(上传功能已实现)</p><p>3). 页面发送请求进行图片下载，将上传的图片进行回显(下载功能已实现)</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022142187.png" alt="image-20210804003752632" style="zoom:80%;" /> <p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182344043.png" alt="image-20230618152755938"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182344580.png" alt="image-20230618152835803"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182344971.png" alt="image-20230618152907261"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182345371.png" alt="image-20230618153041058"></p><p>4). 点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182345186.png" alt="image-20230618154523528"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182345387.png" alt="image-20230618154613078"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182345075.png" alt="image-20230618154649140"></p><p>我们输入的20是20元  数据库是以分为单位 所以变成了2000</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182345123.png" alt="image-20230618155039756"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190003945.png" alt="image-20230618155133944"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182345818.png" alt="image-20230618155329426"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190003066.png" alt="image-20230618155633822"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182345082.png" alt="image-20230618155650217"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">submitForm(formName, st) &#123;</span><br><span class="line">           this.$refs[formName].validate((valid) =&gt; &#123;   //校验</span><br><span class="line">             if (valid) &#123;</span><br><span class="line">               let params = &#123;...this.ruleForm&#125;    //如果校验通过 把表单的数据收集过来  然后封装到params上面</span><br><span class="line">               // params.flavors = this.dishFlavors</span><br><span class="line">               params.status = this.ruleForm ? 1 : 0</span><br><span class="line">               params.price *= 100</span><br><span class="line">               params.categoryId = this.ruleForm.categoryId</span><br><span class="line">               params.flavors = this.dishFlavors.map(obj =&gt; (&#123; ...obj, value: JSON.stringify(obj.value) &#125;))</span><br><span class="line">               delete params.dishFlavors</span><br><span class="line">               if(!this.imageUrl)&#123;</span><br><span class="line">                 this.$message.error(&#x27;请上传菜品图片&#x27;)</span><br><span class="line">                 return </span><br><span class="line">               &#125;</span><br><span class="line">               if (this.actionType == &#x27;add&#x27;) &#123;</span><br><span class="line">                 delete params.id</span><br><span class="line">                 addDish(params).then(res =&gt; &#123;    //发送请求</span><br><span class="line">                   if (res.code === 1) &#123;</span><br><span class="line">                     this.$message.success(&#x27;菜品添加成功！&#x27;)</span><br><span class="line">                     if (!st) &#123;</span><br><span class="line">                       this.goBack()</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                       this.dishFlavors = []</span><br><span class="line">                       // this.dishFlavorsData = []</span><br><span class="line">                       this.imageUrl = &#x27;&#x27;</span><br><span class="line">                       this.ruleForm = &#123;</span><br><span class="line">                         &#x27;name&#x27;: &#x27;&#x27;,</span><br><span class="line">                         &#x27;id&#x27;: &#x27;&#x27;,</span><br><span class="line">                         &#x27;price&#x27;: &#x27;&#x27;,</span><br><span class="line">                         &#x27;code&#x27;: &#x27;&#x27;,</span><br><span class="line">                         &#x27;image&#x27;: &#x27;&#x27;,</span><br><span class="line">                         &#x27;description&#x27;: &#x27;&#x27;,</span><br><span class="line">                         &#x27;dishFlavors&#x27;: [],</span><br><span class="line">                         &#x27;status&#x27;: true,</span><br><span class="line">                         categoryId: &#x27;&#x27;</span><br><span class="line">                       &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                     this.$message.error(res.msg || &#x27;操作失败&#x27;)</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;).catch(err =&gt; &#123;</span><br><span class="line">                   this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">                 &#125;)</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                 delete params.updateTime</span><br><span class="line">                 editDish(params).then(res =&gt; &#123;</span><br><span class="line">                   if (res.code === 1) &#123;</span><br><span class="line">                     this.$message.success(&#x27;菜品修改成功！&#x27;)</span><br><span class="line">                     this.goBack()</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                     this.$message.error(res.msg || &#x27;操作失败&#x27;)</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;).catch(err =&gt; &#123;</span><br><span class="line">                   this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">                 &#125;)</span><br><span class="line">               &#125;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">               return false</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;,</span><br></pre></td></tr></table></figure><p>页面代码:</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022143338.png" alt="image-20210804004529310" style="zoom:80%;" /> <p>浏览器抓取请求:</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022143178.png" alt="image-20210804005030527" style="zoom:80%;" /> <p>开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求(上传、下载已实现)即可。经过上述的分析，我们还需要在服务端实现两块功能：</p><p>A. 菜品分类数据列表查询, 具体请求信息整理如下 : </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;category&#x2F;list</td></tr><tr><td>请求参数</td><td>?type&#x3D;1</td></tr></tbody></table><p>B. 保存菜品信息, 具体请求信息整理如下 : </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;dish</td></tr><tr><td>请求参数</td><td>json格式</td></tr></tbody></table><p>下面呢,我们就需要根据这里分析的结果,分别来实现菜品分类列表的展示功能、保存菜品的功能 。</p><h3 id="2-5-代码实现"><a href="#2-5-代码实现" class="headerlink" title="2.5 代码实现"></a>2.5 代码实现</h3><h4 id="2-5-1-菜品分类查询"><a href="#2-5-1-菜品分类查询" class="headerlink" title="2.5.1 菜品分类查询"></a>2.5.1 菜品分类查询</h4><p>在CategoryController中增加方法实现菜品分类查询，根据分类进行查询，并对查询的结果按照sort排序字段进行升序排序，如果sort相同，再按照修改时间倒序排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据条件查询分类数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;List&lt;Category&gt;&gt; <span class="title function_">list</span><span class="params">(Category category)</span>&#123;</span><br><span class="line">    <span class="comment">//条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加条件</span></span><br><span class="line">    queryWrapper.eq(category.getType() != <span class="literal">null</span>,Category::getType,category.getType());</span><br><span class="line">    <span class="comment">//添加排序条件</span></span><br><span class="line">    queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>这段代码是一个Java Spring Boot框架中的控制器方法，用于根据条件查询分类数据并返回结果。以下是对每一行代码的详细解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据条件查询分类数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这是一个方法的注释，用于描述方法的功能。它指示该方法根据给定的条件查询分类数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br></pre></td></tr></table></figure><p>这是一个注解，表示该方法处理HTTP GET请求，并将其映射到路径”&#x2F;list”。当用户访问”&#x2F;list”时，该方法将被调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> R&lt;List&lt;Category&gt;&gt; <span class="title function_">list</span><span class="params">(Category category)</span>&#123;</span><br></pre></td></tr></table></figure><p>这是方法的签名，指定了方法名、返回类型和参数。方法名是<code>list</code>，返回类型是<code>R&lt;List&lt;Category&gt;&gt;</code>，表示返回一个带有泛型参数<code>List&lt;Category&gt;</code>的<code>R</code>对象。<code>R</code>对象可能是一个自定义的响应类，用于封装响应数据。</p><p>这个方法接受一个<code>Category</code>对象作为参数，用于指定查询条件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Category&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这行代码创建了一个<code>LambdaQueryWrapper</code>对象，用于构建查询条件。<code>LambdaQueryWrapper</code>是MyBatis-Plus库提供的一个查询条件构造器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryWrapper.eq(category.getType() != <span class="literal">null</span>, Category::getType, category.getType());</span><br></pre></td></tr></table></figure><p>这行代码添加了一个条件到查询条件构造器中。它检查<code>category.getType()</code>是否不为<code>null</code>，如果是，则添加一个等于条件，比较的字段是<code>Category</code>对象的<code>type</code>属性，比较的值是<code>category.getType()</code>的返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br></pre></td></tr></table></figure><p>这行代码添加了排序条件到查询条件构造器中。它指定了两个排序条件，首先按照<code>Category</code>对象的<code>sort</code>属性进行升序排序，然后按照<code>Category</code>对象的<code>updateTime</code>属性进行降序排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Category&gt; list = categoryService.list(queryWrapper);</span><br></pre></td></tr></table></figure><p>这行代码使用查询条件构造器执行查询操作，并将查询结果存储在名为<code>list</code>的<code>List&lt;Category&gt;</code>对象中。<code>categoryService</code>是一个服务类，执行实际的查询操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> R.success(list);</span><br></pre></td></tr></table></figure><p>这行代码将查询结果包装在一个<code>R</code>对象中，并将其作为方法的返回值返回。<code>R.success(list)</code>表示将查询结果<code>list</code>放入<code>R</code>对象中，并使用<code>success</code>方法表示查询成功。</p><p>总结：这段代码是一个根据条件查询分类数据的控制器方法。它接受一个<code>Category</code>对象作为参数，使用查询条件构造器<code>LambdaQueryWrapper</code>构建查询条件，然后执行查询操作，并将结果封装在一个<code>R</code>对象中返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //添加条件</span><br><span class="line">queryWrapper.eq(category.getType() != null,Category::getType,category.getType());</span><br><span class="line">//添加排序条件</span><br><span class="line">queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上二句话代码的详细解释：</p><p>当你执行查询时，你通常希望根据特定的条件来过滤结果，并按照某个字段进行排序。以下是对这两行代码的详细解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryWrapper.eq(category.getType() != <span class="literal">null</span>, Category::getType, category.getType());</span><br></pre></td></tr></table></figure><p>这行代码用于添加查询条件到查询条件构造器<code>queryWrapper</code>中。<code>eq</code>方法表示添加等于条件。参数解释如下：</p><ul><li><code>category.getType() != null</code>：这是一个条件判断表达式，检查<code>category</code>对象的<code>type</code>属性是否不为<code>null</code>。如果条件为<code>true</code>，则添加等于条件；如果条件为<code>false</code>，则不添加这个条件。</li><li><code>Category::getType</code>：这是一个方法引用，指定了要进行比较的字段。它表示比较的字段是<code>Category</code>对象的<code>type</code>属性。</li><li><code>category.getType()</code>：这是要进行比较的值，它是通过调用<code>category</code>对象的<code>getType()</code>方法获取的。</li></ul><p>因此，这行代码的意思是，如果<code>category</code>对象的<code>type</code>属性不为<code>null</code>，则添加一个等于条件，比较的字段是<code>Category</code>对象的<code>type</code>属性，比较的值是<code>category.getType()</code>的返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br></pre></td></tr></table></figure><p>这行代码用于添加排序条件到查询条件构造器<code>queryWrapper</code>中。<code>orderByAsc</code>和<code>orderByDesc</code>方法分别表示按照升序和降序进行排序。参数解释如下：</p><ul><li><code>Category::getSort</code>：这是一个方法引用，指定了要进行排序的字段。它表示按照<code>Category</code>对象的<code>sort</code>属性进行排序。</li><li><code>Category::getUpdateTime</code>：这是另一个方法引用，指定了第二个排序条件。它表示按照<code>Category</code>对象的<code>updateTime</code>属性进行排序。</li></ul><p>因此，这行代码的意思是，首先按照<code>Category</code>对象的<code>sort</code>属性进行升序排序，然后按照<code>Category</code>对象的<code>updateTime</code>属性进行降序排序。</p><p>综上所述，这两行代码用于添加查询条件和排序条件到查询条件构造器中，以便在执行查询操作时进行过滤和排序。</p><p>代码解释2</p><p>以上代码是一个简单的 RESTful API，用于根据传入的类别参数查询分类数据。</p><p>具体解释如下:</p><ol><li><code>@GetMapping(&quot;/list&quot;)</code>:定义一个 GET 请求映射，用于返回分类数据。</li><li><code>public R&lt;List&lt;Category&gt;&gt; list(Category category)</code>:定义一个方法<code>list</code>,接收一个参数<code>category</code>,并返回一个结果类型<code>R&lt;List&lt;Category&gt;&gt;&gt;</code>,其中<code>R</code>表示结果类型为抽象类型，<code>List&lt;Category&gt;</code>表示返回的结果为分类数据列表。</li><li><code>LambdaQueryWrapper&lt;Category&gt;</code>:创建一个<code>LambdaQueryWrapper&lt;Category&gt;</code>对象，用于构建查询条件。</li><li><code>eq(boolean expression, Function&lt;Category, T&gt; getter, T value)</code>:表示添加一个条件，其中<code>expression</code>表示条件表达式，<code>getter</code>表示用于获取值的函数，<code>value</code>表示条件值为指定的值。在本例中，<code>expression</code>为<code>category.getType() != null</code>,表示查询类型不为空的类别。<code>getter</code>为<code>Category::getType</code>,表示以类别对象自身的<code>getType</code>方法作为获取类型信息的函数。<code>value</code>为<code>category.getType()</code>,表示将类别对象的<code>getType</code>方法返回的值作为条件值。</li><li><code>orderByAsc(Function&lt;Category, T&gt; getter)</code>和<code>OrderByDesc(Function&lt;Category, T&gt; getter)</code>:表示添加两个排序条件，其中<code>getter</code>表示用于获取值的函数。在本例中，<code>getter</code>分别为<code>Category::getSort</code>和<code>Category::getUpdateTime</code>,表示以类别对象自身的<code>getSort</code>方法和<code>getUpdateTime</code>方法作为获取排序信息的函数。排序条件分别为按类别名称升序排序和按类别更新时间降序排序。</li><li><code>categoryService.list(queryWrapper)</code>:调用<code>categoryService</code>的<code>list</code>方法，并将<code>queryWrapper</code>作为参数传入。<code>categoryService</code>是定义在包级接口<code>Service</code>中的接口，实现了类<code>CategoryService</code>的具体实现。</li><li><code>R.success(list)</code>:返回一个成功响应，将返回结果<code>list</code>作为响应内容返回。</li></ol><p>因此，以上代码实现了根据传入的类别参数查询分类数据的功能，并将查询结果返回给客户端。</p><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182346530.png" alt="image-20230618151030709"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182346810.png" alt="image-20230618151205638"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190003546.png" alt="image-20230618151240356"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182346426.png" alt="image-20230618151339725"></p><p>代码编写完毕之后，我们可以打开新增菜品页面，查看响应的数据，及页面下拉列表的渲染情况： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022143954.png" alt="image-20210804180408584" style="zoom:80%;" /> <h4 id="2-5-2-保存菜品信息"><a href="#2-5-2-保存菜品信息" class="headerlink" title="2.5.2 保存菜品信息"></a>2.5.2 保存菜品信息</h4><p>在上述的分析中，我们可以看到在保存菜品时，页面传递过来的是json格式数据，格式如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;佛跳墙&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="number">88800</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="string">&quot;da9e1c70-fc32-4781-9510-a1c4ccd2ff59.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;佛跳墙&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;categoryId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1397844357980663809&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;flavors&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;辣度&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="string">&quot;[\&quot;不辣\&quot;,\&quot;微辣\&quot;,\&quot;中辣\&quot;,\&quot;重辣\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;showOption&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;忌口&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="string">&quot;[\&quot;不要葱\&quot;,\&quot;不要蒜\&quot;,\&quot;不要香菜\&quot;,\&quot;不要辣\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;showOption&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在服务端我们应该如何来封装前端传递的数据呢，我们发现，如果使用菜品类Dish来封装，只能封装菜品的基本属性，flavors属性是无法封装的。那么这个时候，我们应该如何处理呢?</p><p>这个时候，我们需要自定义一个实体类，然后继承自 Dish，并对Dish的属性进行拓展，增加 flavors 集合属性(内部封装DishFlavor)。清楚了这一点之后,接下来就进行功能开发。</p><p><strong>1). 导入 DishDto 实体类</strong></p><p>封装页面传递的请求参数。</p><p>所属包: com.itheima.reggie.dto</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Dish;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.DishFlavor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishDto</span> <span class="keyword">extends</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DishFlavor&gt; flavors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer copies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>拓展： 我们在做项目时，经常会涉及到各种类型的实体模型。基本包含以下几种</font> </p><table><thead><tr><th>实体模型</th><th>描述</th></tr></thead><tbody><tr><td>DTO</td><td>Data Transfer Object(数据传输对象)，一般用于展示层与服务层之间的数据传输。</td></tr><tr><td>Entity</td><td>最常用实体类，基本和数据表一一对应，一个实体类对应一张表。</td></tr><tr><td>VO</td><td>Value Object(值对象), 主要用于封装前端页面展示的数据对象，用一个VO对象来封装整个页面展示所需要的对象数据</td></tr><tr><td>PO</td><td>Persistant Object(持久层对象), 是ORM(Objevt Relational Mapping)框架中Entity，PO属性和数据库中表的字段形成一一对应关系</td></tr></tbody></table><p><strong>2). DishController定义方法新增菜品</strong></p><p>在该Controller的方法中，不仅需要保存菜品的基本信息，还需要保存菜品的口味信息，需要操作两张表，所以我们需要在DishService接口中定义接口方法，在这个方法中需要保存上述的两部分数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 菜品管理</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class DishController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增菜品</span><br><span class="line">     * @param dishDto</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">   @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line">        </span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182346754.png" alt="image-20230618163146356"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182346467.png" alt="image-20230618162322453"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182346162.png" alt="image-20230618162358481"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182347970.png" alt="image-20230618163308647"></p><p>发现并没有封装上   这是因为忘记加@RequestBody</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182347746.png" alt="image-20230618163355563"></p><p>加上注解后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜品管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/dish&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishFlavorService dishFlavorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增菜品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span>  DishDto dishDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182347738.png" alt="image-20230618163745973"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182348451.png" alt="image-20230618164005958"></p><p>完整的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增菜品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> DishDto dishDto)</span>&#123;</span><br><span class="line">    log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line">    dishService.saveWithFlavor(dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;新增菜品成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182348114.png" alt="image-20230618170655027"></p><p><strong>3). DishService中增加方法saveWithFlavor</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182348051.png" alt="image-20230618164238661"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新增菜品，同时插入菜品对应的口味数据，需要操作两张表：dish、dish_flavor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithFlavor</span><span class="params">(DishDto dishDto)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182348331.png" alt="image-20230618164528065"></p><p><strong>4). DishServiceImpl中实现方法saveWithFlavor</strong></p><p>页面传递的菜品口味信息，仅仅包含name 和 value属性，缺少一个非常重要的属性dishId， 所以在保存完菜品的基本信息后，我们需要获取到菜品ID，然后为菜品口味对象属性dishId赋值。</p><p>具体逻辑如下：</p><p>①. 保存菜品基本信息 ;</p><p>②. 获取保存的菜品ID ;</p><p>③. 获取菜品口味列表，遍历列表，为菜品口味对象属性dishId赋值;</p><p>④. 批量保存菜品口味列表;</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182348851.png" alt="image-20230618170357409"></p><p>代码实现如下: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DishFlavorService dishFlavorService;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 新增菜品，同时保存对应的口味数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithFlavor</span><span class="params">(DishDto dishDto)</span> &#123;</span><br><span class="line">    <span class="comment">//保存菜品的基本信息到菜品表dish</span></span><br><span class="line">    <span class="built_in">this</span>.save(dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> dishDto.getId();<span class="comment">//菜品id</span></span><br><span class="line">    <span class="comment">//菜品口味</span></span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line">    flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">        item.setDishId(dishId);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存菜品口味数据到菜品口味表dish_flavor</span></span><br><span class="line">    dishFlavorService.saveBatch(flavors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明: </p><p>​由于在 saveWithFlavor 方法中，进行了两次数据库的保存操作，操作了两张表，那么为了保证数据的一致性，我们需要在方法上加上注解 @Transactional来控制事务。</p></blockquote><p>代码解释1</p><p>这段代码是一个Java类中的方法，主要用于保存菜品信息和相应的口味数据到数据库中。下面是对每一行代码的解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DishFlavorService dishFlavorService;</span><br></pre></td></tr></table></figure><p>这行代码使用了Spring框架的@Autowired注解，将DishFlavorService类的实例自动注入到当前类中的dishFlavorService变量中。这样就可以通过dishFlavorService变量访问DishFlavorService类的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br></pre></td></tr></table></figure><p>这行代码使用了Spring框架的@Transactional注解，表示该方法需要在一个数据库事务中执行。数据库事务用于确保一组数据库操作要么全部成功提交，要么全部回滚，以保持数据的一致性和完整性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveWithFlavor</span><span class="params">(DishDto dishDto)</span> &#123;</span><br></pre></td></tr></table></figure><p>这行代码定义了一个名为saveWithFlavor的方法，该方法接收一个类型为DishDto的参数dishDto。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.save(dishDto);</span><br></pre></td></tr></table></figure><p>这行代码调用当前类中的save方法，将dishDto作为参数进行保存。这里使用了this关键字来调用当前类的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> dishDto.getId();</span><br></pre></td></tr></table></figure><p>这行代码从dishDto对象中获取菜品的id，并将其保存在一个Long类型的变量dishId中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br></pre></td></tr></table></figure><p>这行代码从dishDto对象中获取口味数据，将其保存在一个List<DishFlavor>类型的变量flavors中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">    item.setDishId(dishId);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这行代码使用Java 8的Stream API对flavors列表进行处理。对于列表中的每个元素，将菜品id（dishId）设置为元素的dishId属性，并将处理后的元素重新收集到一个新的列表中。最终，flavors列表中的每个元素的dishId属性都被设置为dishId变量的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dishFlavorService.saveBatch(flavors);</span><br></pre></td></tr></table></figure><p>这行代码调用dishFlavorService对象的saveBatch方法，将flavors列表作为参数进行保存。这样就将菜品口味数据保存到数据库中。</p><p>总结来说，这段代码通过自动注入的dishFlavorService对象将菜品信息和相应的口味数据保存到数据库中。首先，它保存菜品的基本信息，然后将菜品id与口味数据关联起来，最后将口味数据保存到数据库中。整个过程都在一个数据库事务中执行，以确保数据的一致性。</p><p>代码解释2</p><p>以上代码是一个菜品管理类的保存菜品和口味数据的具体方法，其中涉及到两个实体类:DishDto 和 DishFlavor。</p><p>首先，该方法接收一个 DishDto 对象作为参数，其中包含了菜品的基本信息，如名称、价格、描述等。然后，该方法执行以下步骤:</p><ol><li>将 DishDto 对象保存到菜品表中，以获取菜品的 ID，即 dishId。</li><li>获取菜品口味列表，即 flavors。</li><li>将 flavors 中的每个元素都设置成当前菜品的 ID，即将每个元素关联到当前菜品上。</li><li>将 flavors 保存到菜品口味表中，以 batch 方式执行，提高效率。</li></ol><p>需要注意的是，该方法使用了 Spring 框架的事务管理，确保在多个方法之间执行的事务性操作是有效的。此外，该方法使用了 Lambda 表达式和 Stream API，使得代码更加简洁和易于理解。</p><p>此外，该方法还使用了 Spring 的 AutoWired 注解，自动注入一个 DishFlavorService 服务类，以便保存菜品口味数据。该服务类实现了 I DishFlavorService 接口，其中包含一个 saveBatch() 方法，用于批量保存菜品口味数据。</p><p>为了让 saveWithFlavor() 方法能够正确地保存菜品和口味数据，需要先注入 DishFlavorService 服务类，并在该方法中使用服务类的实例来调用 saveBatch() 方法。</p><p>总的来说，该方法的主要功能是将菜品和口味数据一起保存到数据库中，同时使用 Stream API 和 Lambda 表达式简化了代码的编写。使用了 Spring 的事务管理，提高了代码的健壮性和可靠性。</p><p>此外，该方法还需要注意处理一些特殊情况，比如当菜品没有口味时，需要自动添加一个默认的口味。</p><p>具体来说，在将口味数据保存到菜品口味表中时，如果菜品没有口味，则需要在口味列表中自动添加一个默认的口味，该默认口味通常是菜品默认的口味。</p><p>为了实现这个功能，可以在 DishDto 类中添加一个 getDefaultValueFlavor() 方法，用于获取菜品的默认口味。该方法可以根据实际情况进行实现，比如返回菜品所属的菜系中默认的口味等。</p><p>在 saveWithFlavor() 方法中，可以在将口味数据保存到菜品口味表中时，调用 getDefaultValueFlavor() 方法获取默认口味，并将其添加到口味列表中。这样，当菜品没有口味时，就可以自动添加一个默认口味，提高了代码的可读性和可维护性。</p><p>总的来说，saveWithFlavor() 方法是一个比较常用的方法，它实现了将菜品和口味数据一起保存到数据库中的功能，同时注意处理了一些特殊情况，提高了代码的健壮性和可靠性。</p><p>最后，需要注意的是，如果菜品和口味数据是通过 API 接口发送到服务器的，那么在 saveWithFlavor() 方法中，需要将接收到的菜品和口味数据转换为对应的实体类对象。</p><p>具体来说，如果传入的 DishDto 对象中包含了菜品和口味数据，则可以在 saveWithFlavor() 方法中先将该对象转换为对应的实体类对象 Dish，然后再将口味数据添加到 Dish 对象中。最后，将 Dish 对象保存到菜品表中即可。</p><p>如果需要在 saveWithFlavor() 方法中处理传入的 DishDto 对象，则可以在该方法中添加相应的代码，将 DishDto 对象转换为对应的实体类对象。这样，就可以使 saveWithFlavor() 方法更加灵活，可以根据具体的数据格式进行相应的处理。</p><p>总的来说，saveWithFlavor() 方法是一个比较常用的方法，它实现了将菜品和口味数据一起保存到数据库中的功能，同时注意处理了一些特殊情况，提高了代码的健壮性和可靠性。在实现该方法时，需要注意将接收到的数据转换为对应的实体类对象，以便更好地处理数据。</p><p><strong>5). 在引导类上加注解 @EnableTransactionManagement</strong></p><p>Service层方法上加的注解@Transactional要想生效，需要在引导类上加上注解 @EnableTransactionManagement， 开启对事务的支持。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349163.png" alt="image-20230618170437094"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启对事物管理的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReggieApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">        log.info(<span class="string">&quot;项目启动成功...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-功能测试"><a href="#2-6-功能测试" class="headerlink" title="2.6 功能测试"></a>2.6 功能测试</h3><p>代码编写完毕之后，我们重新启动服务，访问项目，然后登陆到系统中，进行菜品的新增测试，在测试时，我们可以通过debug断点跟踪的形式，查看我们传输的数据，及数据的封装。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022143154.png" alt="image-20210804174956706" style="zoom:80%;" /> <p>debug跟踪数据的封装情况: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022143378.png" alt="image-20210804175034622"> </p><p>然后在测试完毕后, 我们可以检查一下数据库中的数据保存情况:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022143898.png" alt="image-20210804175658010"> </p><p>视频解析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349667.png" alt="image-20230618171046393"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349331.png" alt="image-20230618171059770"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349427.png" alt="image-20230618171118871"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349139.png" alt="image-20230618171201069"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349787.png" alt="image-20230618171246577"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349027.png" alt="image-20230618172613139"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182349196.png" alt="image-20230618172712623"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182350171.png" alt="image-20230618172817822"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182350547.png" alt="image-20230618172916588"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182350227.png" alt="image-20230618172932776"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182350251.png" alt="image-20230618173101532"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182350874.png" alt="image-20230618173150068"></p><h2 id="3-菜品分页查询"><a href="#3-菜品分页查询" class="headerlink" title="3. 菜品分页查询"></a>3. 菜品分页查询</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022145922.png" alt="image-20210804223703893" style="zoom:80%;" /> <p>在菜品列表展示时，除了菜品的基本信息(名称、售价、售卖状态、更新时间)外，还有两个字段略微特殊，第一个是图片字段 ，我们从数据库查询出来的仅仅是图片的名字，图片要想在表格中回显展示出来，就需要下载这个图片。第二个是菜品分类，这里展示的是分类名称，而不是分类ID，此时我们就需要根据菜品的分类ID，去分类表中查询分类信息，然后在页面展示。</p><h3 id="3-2-前端页面分析"><a href="#3-2-前端页面分析" class="headerlink" title="3.2 前端页面分析"></a>3.2 前端页面分析</h3><p>在开发代码之前，需要梳理一下菜品分页查询时前端页面和服务端的交互过程：</p><p>1). 访问页面(backend&#x2F;page&#x2F;food&#x2F;list.html)时，发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据</p><p>2). 页面发送请求，请求服务端进行图片下载，用于页面图片展示</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022146857.png" alt="image-20210804224842336"> </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022146001.png" alt="image-20210804225259854" style="zoom:94%;" /> <p>开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可，而前端发起的请求中， 图片文件下载回显的代码，我们已经实现了。所以，我们只需要开发分页查询的功能即可，分页查询具体的请求信息如下：</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;dish&#x2F;page</td></tr><tr><td>请求参数</td><td>?page&#x3D;1&amp;pageSize&#x3D;10&amp;name&#x3D;xxx</td></tr></tbody></table><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182350123.png" alt="image-20230618204454122"></p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><h4 id="3-3-1-分析"><a href="#3-3-1-分析" class="headerlink" title="3.3.1 分析"></a>3.3.1 分析</h4><p>上述我们已经分析了分页查询的请求信息，那么接下来，我们就需要在 DishController中开发方法，来完成菜品的条件分页查询，在分页查询时还需要给页面返回分类的名称，而分类的名称前端在接收的时候是通过 categoryName 属性获取的，那么对应的服务端也应该封装到 categoryName 属性中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;categoryName&quot;</span> <span class="attr">label</span>=<span class="string">&quot;菜品分类&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而在我们的实体类 Dish 中，仅仅包含 categoryId， 不包含 categoryName，那么我们应该如何封装查询的数据呢？ 其实，这里我们可以返回DishDto对象，在该对象中我们可以拓展一个属性 categoryName，来封装菜品分类名称。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishDto</span> <span class="keyword">extends</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DishFlavor&gt; flavors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String categoryName; <span class="comment">//菜品分类名称</span></span><br><span class="line">    <span class="keyword">private</span> Integer copies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体逻辑为： </p><p>1). 构造分页条件对象</p><p>2). 构建查询及排序条件</p><p>3). 执行分页条件查询</p><p>4). 遍历分页查询列表数据，根据分类ID查询分类信息，从而获取该菜品的分类名称</p><p>5). 封装数据并返回</p><h4 id="3-3-2-实现"><a href="#3-3-2-实现" class="headerlink" title="3.3.2 实现"></a>3.3.2 实现</h4><p>分析了具体的实现思路之后，接下来就来完成具体的代码实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜品信息分页查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span>&#123;</span><br><span class="line">    <span class="comment">//构造分页构造器对象</span></span><br><span class="line">    Page&lt;Dish&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">    Page&lt;DishDto&gt; dishDtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加过滤条件</span></span><br><span class="line">    queryWrapper.like(name != <span class="literal">null</span>,Dish::getName,name);</span><br><span class="line">    <span class="comment">//添加排序条件</span></span><br><span class="line">    queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行分页查询</span></span><br><span class="line">    dishService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象拷贝</span></span><br><span class="line">    BeanUtils.copyProperties(pageInfo,dishDtoPage,<span class="string">&quot;records&quot;</span>);</span><br><span class="line">    List&lt;Dish&gt; records = pageInfo.getRecords();</span><br><span class="line">    List&lt;DishDto&gt; list = records.stream().map((item) -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line">        BeanUtils.copyProperties(item,dishDto);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">categoryId</span> <span class="operator">=</span> item.getCategoryId();<span class="comment">//分类id</span></span><br><span class="line">        <span class="comment">//根据id查询分类对象</span></span><br><span class="line">        <span class="type">Category</span> <span class="variable">category</span> <span class="operator">=</span> categoryService.getById(categoryId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(category != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">categoryName</span> <span class="operator">=</span> category.getName();</span><br><span class="line">            dishDto.setCategoryName(categoryName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dishDto;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    dishDtoPage.setRecords(list);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> R.success(dishDtoPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数据库查询菜品信息时，获取到的分页查询结果 Page 的泛型为 Dish，而我们最终需要给前端页面返回的类型为 DishDto，所以这个时候就要进行转换，基本属性我们可以直接通过属性拷贝的形式对Page中的属性进行复制，而对于结果列表 records属性，我们是需要进行特殊处理的(需要封装菜品分类名称);</p></blockquote><p>视频分析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜品信息分页查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> pageSize, String name)</span>&#123;</span><br><span class="line">    <span class="comment">//构造分页构造器对象</span></span><br><span class="line">    Page&lt;Dish&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">    Page&lt;DishDto&gt; dishDtoPage = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加过滤条件</span></span><br><span class="line">    queryWrapper.like(name != <span class="literal">null</span>,Dish::getName,name);</span><br><span class="line">    <span class="comment">//添加排序条件</span></span><br><span class="line">    queryWrapper.orderByDesc(Dish::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行分页查询</span></span><br><span class="line">    dishService.page(pageInfo,queryWrapper);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182351155.png" alt="image-20230618205558687"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182351020.png" alt="image-20230618205751579"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182351099.png" alt="image-20230618205832886"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182351715.png" alt="image-20230618205814307"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182351666.png" alt="image-20230618205953972"></p><p>响应回来的只是categoryId  所以没办法展示名称</p><p>菜品分类对应的prop是categoryName </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182351922.png" alt="image-20230618210256074"></p><p>而我们响应回来的没有prop&#x3D;”categoryName” 字段   所以展示不出来 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182352818.png" alt="image-20230618210424608"></p><p>而我们的菜品名称可以展示    因为我们响应回来的有name这个字段</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182352883.png" alt="image-20230618210536942"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182352507.png" alt="image-20230618210625055"></p><p>而我们dto里面有categoryName字段</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182352563.png" alt="image-20230618210902383"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DishDto extends Dish</span><br></pre></td></tr></table></figure><p>所以Dish里面的属性也都能够继承过来    也就是说DishDto有自己的属性  也可以用Dish的属性</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182352842.png" alt="image-20230618211105645"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DishDto在Dish的基础上拓展了categoryName</span><br></pre></td></tr></table></figure><p>而categoryName刚好可以在菜品分类里面用于展示菜品名称用于展示用</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182352427.png" alt="image-20230618211401575"></p><p>所以我们要有DishDto为泛型的对象，Page<DishDto> dishDtoPage &#x3D; new Page&lt;&gt;();</p><h3 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h3><p>代码编写完毕之后，我们重新启动服务，访问项目，可以通过debug端点的形式跟踪，整个分页查询过程中，数据的转换和封装。 </p><p>在测试的过程中，我们发现有一些菜品图片并没有展示出来，如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022146649.png" alt="image-20210805100944028"> </p><p>这是因为我们在导入sql脚本时，导入了一部分菜品的数据，而菜品的图片在我们的磁盘目录中并不存在，所以才会出现图片展示不出来的情况，而我们后续自己添加的菜品信息是没有问题的。</p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182352338.png" alt="image-20230618215423637"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353658.png" alt="image-20230618215407228"></p><p>6次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353634.png" alt="image-20230618215641139"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353330.png" alt="image-20230618215955487"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353826.png" alt="image-20230618220116780"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190005833.png" alt="image-20230618220151109"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353713.png" alt="image-20230618220306867"></p><p>开始对象拷贝</p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353970.png" alt="image-20230618220355900"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353890.png" alt="image-20230618220451942"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182353665.png" alt="image-20230618221257189"></p><p>放行</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182354929.png" alt="image-20230618221617702"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182354834.png" alt="image-20230618221633399"></p><p>图片是怎么展示出来的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182354002.png" alt="image-20230618221842484"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182354234.png" alt="image-20230618221924081"></p><h2 id="4-菜品修改"><a href="#4-菜品修改" class="headerlink" title="4. 菜品修改"></a>4. 菜品修改</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p>在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022146257.png" alt="image-20210804232447587" style="zoom:80%;" /> <p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182354042.png" alt="image-20230618222447606"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182354593.png" alt="image-20230618222534926"></p><h3 id="4-2-前端页面分析"><a href="#4-2-前端页面分析" class="headerlink" title="4.2 前端页面分析"></a>4.2 前端页面分析</h3><p>在开发代码之前，需要梳理一下修改菜品时前端页面（add.html）和服务端的交互过程：</p><p>1). 点击菜品列表的中的修改按钮，携带菜品id跳转至add.html</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022147208.png" alt="image-20210804233459252" style="zoom:80%;" /> <p>2). 进入add.html，页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示(<strong>已实现</strong>)</p><p>3). add.html获取id, 发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022148301.png" alt="image-20210804234104633" style="zoom:80%;" /> <p>4). 页面发送请求，请求服务端进行图片下载，用于页图片回显(<strong>已实现</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022148012.png" alt="image-20210804234226201"> </p><p>5). 点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022148765.png" alt="image-20210804234442923" style="zoom:80%;" /> <p>经过上述的分析，我们发现，菜品分类下拉框的展示、图片的下载回显功能我们都已经实现了。我们只需要在这里实现两个功能即可，分别是： </p><p><strong>1). 根据ID查询菜品及菜品口味信息</strong></p><p>具体请求信息如下： </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;dish&#x2F;{id}</td></tr></tbody></table><p><strong>2). 修改菜品及菜品口味信息</strong></p><p>具体请求信息如下：</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>PUT</td></tr><tr><td>请求路径</td><td>&#x2F;dish</td></tr><tr><td>请求参数</td><td>json格式数据</td></tr></tbody></table><p>具体的json格式数据，我们可以通过浏览器抓取： </p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1422783914845487106&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;佛跳墙&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;categoryId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1397844357980663809&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="number">88800</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="string">&quot;da9e1c70-fc32-4781-9510-a1c4ccd2ff59.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;佛跳墙&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2021-08-04 12:58:14&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;createUser&quot;</span><span class="punctuation">:</span><span class="string">&quot;1412578435737350122&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;updateUser&quot;</span><span class="punctuation">:</span><span class="string">&quot;1412578435737350122&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;flavors&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1422783914883235842&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;dishId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1422783914845487106&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;辣度&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="string">&quot;[\&quot;不辣\&quot;,\&quot;微辣\&quot;,\&quot;中辣\&quot;,\&quot;重辣\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2021-08-04 12:58:14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2021-08-04 12:58:14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;createUser&quot;</span><span class="punctuation">:</span><span class="string">&quot;1412578435737350122&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;updateUser&quot;</span><span class="punctuation">:</span><span class="string">&quot;1412578435737350122&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDeleted&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;showOption&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1422783914895818754&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;dishId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1422783914845487106&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;忌口&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span><span class="string">&quot;[\&quot;不要葱\&quot;,\&quot;不要蒜\&quot;,\&quot;不要香菜\&quot;,\&quot;不要辣\&quot;]&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2021-08-04 12:58:14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2021-08-04 12:58:14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;createUser&quot;</span><span class="punctuation">:</span><span class="string">&quot;1412578435737350122&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;updateUser&quot;</span><span class="punctuation">:</span><span class="string">&quot;1412578435737350122&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDeleted&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;showOption&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-功能实现"><a href="#4-3-功能实现" class="headerlink" title="4.3 功能实现"></a>4.3 功能实现</h3><h4 id="4-3-1-根据ID查询菜品信息"><a href="#4-3-1-根据ID查询菜品信息" class="headerlink" title="4.3.1 根据ID查询菜品信息"></a>4.3.1 根据ID查询菜品信息</h4><h5 id="4-3-1-1-代码实现"><a href="#4-3-1-1-代码实现" class="headerlink" title="4.3.1.1 代码实现"></a>4.3.1.1 代码实现</h5><p>页面发送ajax请求，请求服务端，根据id查询当前菜品信息和对应的口味信息，用于修改页面中菜品信息回显。</p><p>1). 在DishService接口中扩展getByIdWithFlavor方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查询菜品信息和对应的口味信息</span></span><br><span class="line"><span class="keyword">public</span> DishDto <span class="title function_">getByIdWithFlavor</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355498.png" alt="image-20230618225153037"></p><p>2). 在DishService实现类中实现此方法</p><p>具体逻辑为: </p><p>A. 根据ID查询菜品的基本信息 </p><p>B. 根据菜品的ID查询菜品口味列表数据</p><p>C. 组装数据并返回</p><p>代码实现: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id查询菜品信息和对应的口味信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> DishDto <span class="title function_">getByIdWithFlavor</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//查询菜品基本信息，从dish表查询</span></span><br><span class="line">    <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DishDto</span>();</span><br><span class="line">    BeanUtils.copyProperties(dish,dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前菜品对应的口味信息，从dish_flavor表查询</span></span><br><span class="line">    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(DishFlavor::getDishId,dish.getId());</span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);</span><br><span class="line">    dishDto.setFlavors(flavors);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dishDto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355810.png" alt="image-20230618225237718"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355441.png" alt="image-20230618225959762"></p><p>3). 在DishController中创建get方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id查询菜品信息和对应的口味信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;DishDto&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">DishDto</span> <span class="variable">dishDto</span> <span class="operator">=</span> dishService.getByIdWithFlavor(id);</span><br><span class="line">    <span class="keyword">return</span> R.success(dishDto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>@PathVariable : 该注解可以用来提取url路径中传递的请求参数。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355898.png" alt="image-20230618230105872"></p><p>问题</p><p>问题1</p><p>@PathVariable的理解 </p><p>当使用Spring框架处理HTTP请求时，有时候我们需要从URL路径中获取一些动态的参数值。例如，我们有一个处理特定用户请求的方法，并且URL路径的格式是<code>/users/&#123;userId&#125;</code>，其中<code>&#123;userId&#125;</code>表示用户的唯一标识符。我们希望能够在方法中获取这个<code>userId</code>的值。</p><p>为了实现这个目的，我们可以在方法参数上使用<code>@PathVariable</code>注解。这个注解告诉Spring框架将URL路径中的变量值绑定到对应的方法参数上。</p><p>让我们来看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理根据用户ID获取用户的逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们定义了一个处理HTTP GET请求的方法，它的路径是<code>/users/&#123;userId&#125;</code>。方法参数<code>userId</code>使用了<code>@PathVariable</code>注解，这告诉Spring框架将URL路径中的变量值绑定到<code>userId</code>参数上。</p><p>当有一个请求URL为<code>/users/123</code>时，Spring框架会自动将路径中的<code>123</code>这个值赋给<code>userId</code>参数。然后我们就可以在方法中使用这个参数值，比如根据用户ID从数据库中获取用户信息。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355546.png" alt="image-20230618224806435"></p><p>问题2</p><p>这里面的泛型为什么要用DishDto   而不是写Dish实体</p><p>因为 我们页面要回显的除了菜品名称和菜品价格 菜品描述之后    还要回显口味</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355329.png" alt="image-20230618223251653"></p><p>而在Dish实体里面 并没有口味相当的属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.entity;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line">import com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 菜品</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Dish implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品分类id</span><br><span class="line">    private Long categoryId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //菜品价格</span><br><span class="line">    private BigDecimal price;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //商品码</span><br><span class="line">    private String code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //图片</span><br><span class="line">    private String image;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //描述信息</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //0 停售 1 起售</span><br><span class="line">    private Integer status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //顺序</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT)</span><br><span class="line">    private Long createUser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">    private Long updateUser;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355507.png" alt="image-20230618223515139"></p><p>所以 我们要使用 DishDto   为什么使用 DishDto</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DishDto extends Dish </span><br><span class="line">DishDto继承Dish</span><br></pre></td></tr></table></figure><p>DishDto有Dish是里面的普通属性  同样DishDto自己也拓展了flavors属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182355866.png" alt="image-20230618224004885"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182356274.png" alt="image-20230618224033670"></p><h5 id="4-3-1-2-功能测试"><a href="#4-3-1-2-功能测试" class="headerlink" title="4.3.1.2 功能测试"></a>4.3.1.2 功能测试</h5><p>编写完代码后，重启服务进行测试，点击列表的修改按钮，查询数据回显情况。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202304022148701.png" alt="image-20210805101812209"> </p><p>视频分析测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182356362.png" alt="image-20230618230608360"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182356122.png" alt="image-20230618230644906"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182356802.png" alt="image-20230618230901248"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,type,name,sort,create_time,update_time,create_user,update_user FROM category WHERE (type = ?) ORDER BY sort ASC,update_time DESC</span><br><span class="line">==&gt; Parameters: 1(Integer)</span><br><span class="line">==&gt; Parameters: 1413384757047271425(Long)</span><br><span class="line">&lt;==    Columns: id, type, name, sort, create_time, update_time, create_user, update_user</span><br><span class="line">&lt;==        Row: 1670333885730369537, 1, 川菜, 1, 2023-06-18 15:33:26, 2023-06-18 15:33:26, 1, 1</span><br><span class="line">&lt;==        Row: 1669764699085991938, 1, 湘菜, 2, 2023-06-17 01:51:42, 2023-06-18 15:34:18, 1, 1</span><br><span class="line">&lt;==        Row: 1670335016523116546, 1, 鲁菜, 4, 2023-06-18 15:37:56, 2023-06-18 15:37:56, 1, 1</span><br><span class="line">&lt;==        Row: 1670335311277830145, 1, 粤菜, 7, 2023-06-18 15:39:06, 2023-06-18 15:39:06, 1, 1</span><br><span class="line">&lt;==        Row: 1670335376541200386, 1, 闽菜, 8, 2023-06-18 15:39:22, 2023-06-18 15:39:22, 1, 1</span><br><span class="line">&lt;==        Row: 1670335445776576513, 1, 苏菜, 9, 2023-06-18 15:39:38, 2023-06-18 15:39:38, 1, 1</span><br><span class="line">&lt;==        Row: 1670335522934992898, 1, 浙菜, 10, 2023-06-18 15:39:57, 2023-06-18 15:39:57, 1, 1</span><br><span class="line">&lt;==        Row: 1413341197421846529, 1, 饮品, 11, 2021-07-09 11:36:15, 2021-07-09 14:39:15, 1, 1</span><br><span class="line">&lt;==    Columns: id, name, category_id, price, code, image, description, status, sort, create_time, update_time, create_user, update_user</span><br><span class="line">&lt;==        Row: 1413384954989060097, 1, 主食, 12, 2021-07-09 14:30:07, 2021-07-09 14:39:19, 1, 1</span><br><span class="line">&lt;==      Total: 9</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3fbb30c3]</span><br><span class="line">&lt;==        Row: 1413384757047271425, 王老吉, 1413341197421846529, 500.00, , 00874a5e-0df2-446b-8f69-a30eb7d88ee8.png, , 1, 0, 2021-07-09 14:29:20, 2021-07-12 09:09:16, 1, 1</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@1933fa81]</span><br><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@72c4116c] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@79383ff6] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: SELECT id,dish_id,name,value,create_time,update_time,create_user,update_user,is_deleted FROM dish_flavor WHERE (dish_id = ?)</span><br><span class="line">==&gt; Parameters: 1413384757047271425(Long)</span><br><span class="line">&lt;==    Columns: id, dish_id, name, value, create_time, update_time, create_user, update_user, is_deleted</span><br><span class="line">&lt;==        Row: 1413389540592263169, 1413384757047271425, 温度, [&quot;常温&quot;,&quot;冷藏&quot;], 2021-07-12 09:09:16, 2021-07-12 09:09:16, 1, 1, 0</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@72c4116c]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182358698.png" alt="image-20230618230955437"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190005193.png" alt="image-20230618231108801"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182358057.png" alt="image-20230618231149338"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190005584.png" alt="image-20230618231210127"></p><h4 id="4-3-2-修改菜品信息"><a href="#4-3-2-修改菜品信息" class="headerlink" title="4.3.2 修改菜品信息"></a>4.3.2 修改菜品信息</h4><h5 id="4-3-2-1-代码实现"><a href="#4-3-2-1-代码实现" class="headerlink" title="4.3.2.1 代码实现"></a>4.3.2.1 代码实现</h5><p>点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端。在修改菜品信息时需要注意，除了要更新dish菜品表，还需要更新dish_flavor菜品口味表。</p><p>1). 在DishService接口中扩展方法updateWithFlavor</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新菜品信息，同时更新对应的口味信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithFlavor</span><span class="params">(DishDto dishDto)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182358009.png" alt="image-20230618231757330"></p><p>2). 在DishServiceImpl中实现方法updateWithFlavor</p><p>在该方法中，我们既需要更新dish菜品基本信息表，还需要更新dish_flavor菜品口味表。而页面再操作时，关于菜品的口味，有修改，有新增，也有可能删除，我们应该如何更新菜品口味信息呢，其实，无论菜品口味信息如何变化，我们只需要保持一个原则： 先删除，后添加。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWithFlavor</span><span class="params">(DishDto dishDto)</span> &#123;</span><br><span class="line">    <span class="comment">//更新dish表基本信息</span></span><br><span class="line">    <span class="built_in">this</span>.updateById(dishDto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理当前菜品对应口味数据---dish_flavor表的delete操作</span></span><br><span class="line">    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>();</span><br><span class="line">    queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());</span><br><span class="line"></span><br><span class="line">    dishFlavorService.remove(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加当前提交过来的口味数据---dish_flavor表的insert操作</span></span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();</span><br><span class="line"></span><br><span class="line">    flavors = flavors.stream().map((item) -&gt; &#123;</span><br><span class="line">        item.setDishId(dishDto.getId());</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    dishFlavorService.saveBatch(flavors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182359177.png" alt="image-20230618231950294"></p><p>3). 在DishController中创建update方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 修改菜品</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dishDto</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> DishDto dishDto)</span>&#123;</span><br><span class="line">    log.info(dishDto.toString());</span><br><span class="line">    dishService.updateWithFlavor(dishDto);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;修改菜品成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182359618.png" alt="image-20230618232045940"></p><h5 id="4-3-2-2-功能测试"><a href="#4-3-2-2-功能测试" class="headerlink" title="4.3.2.2 功能测试"></a>4.3.2.2 功能测试</h5><p>代码编写完成之后，重启服务，然后按照前面分析的操作流程进行测试，查看数据是否正常修改即可。</p><p>视频分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182359105.png" alt="image-20230618231438499"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182359402.png" alt="image-20230618231524440"></p><p>测试</p><p>原来</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182359553.png" alt="image-20230618233159812"></p><p>修改</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306182359057.png" alt="image-20230618233303287"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day04/202306190000721.png" alt="image-20230618233320565"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖-Day03</title>
      <link href="/archives/2.html"/>
      <url>/archives/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖-Day03"><a href="#瑞吉外卖-Day03" class="headerlink" title="瑞吉外卖-Day03"></a>瑞吉外卖-Day03</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>公共字段自动填充</li><li>新增分类</li><li>分类信息分页查询</li><li>删除分类</li><li>修改分类</li></ul><h2 id="1-公共字段自动填充"><a href="#1-公共字段自动填充" class="headerlink" title="1. 公共字段自动填充"></a>1. 公共字段自动填充</h2><h3 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1 问题分析"></a>1.1 问题分析</h3><p>前面我们已经完成了后台系统的员工管理功能的开发，在新增员工时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工时需要设置修改时间、修改人等字段。这些字段属于公共字段，也就是也就是在我们的系统中很多表中都会有这些字段，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021836685.png" alt="image-20210801085103062"> </p><p>而针对于这些字段，我们的赋值方式为： </p><p>A. 在新增数据时, 将createTime、updateTime 设置为当前时间, createUser、updateUser设置为当前登录用户ID。</p><p>B. 在更新数据时, 将updateTime 设置为当前时间, updateUser设置为当前登录用户ID。</p><p>目前,在我们的项目中处理这些字段都是在每一个业务方法中进行赋值操作,如下:</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021837660.png" alt="image-20210801085615162" style="zoom:80%;" /> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021837820.png" alt="image-20210801085715419" style="zoom:80%;" /> <p>如果都按照上述的操作方式来处理这些公共字段, 需要在每一个业务方法中进行操作, 编码相对冗余、繁琐，那能不能对于这些公共字段在某个地方统一处理，来简化开发呢？</p><p><strong>答案是可以的，我们使用Mybatis Plus提供的公共字段自动填充功能。</strong></p><h3 id="1-2-基本功能实现"><a href="#1-2-基本功能实现" class="headerlink" title="1.2 基本功能实现"></a>1.2 基本功能实现</h3><h4 id="1-2-1-思路分析"><a href="#1-2-1-思路分析" class="headerlink" title="1.2.1 思路分析"></a>1.2.1 思路分析</h4><p>Mybatis Plus公共字段自动填充，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码。在上述的问题分析中，我们提到有四个公共字段，需要在新增&#x2F;更新中进行赋值操作, 具体情况如下: </p><table><thead><tr><th>字段名</th><th>赋值时机</th><th>说明</th></tr></thead><tbody><tr><td>createTime</td><td>插入(INSERT)</td><td>当前时间</td></tr><tr><td>updateTime</td><td>插入(INSERT) , 更新(UPDATE)</td><td>当前时间</td></tr><tr><td>createUser</td><td>插入(INSERT)</td><td>当前登录用户ID</td></tr><tr><td>updateUser</td><td>插入(INSERT) , 更新(UPDATE)</td><td>当前登录用户ID</td></tr></tbody></table><p>实现步骤：</p><p>1、在实体类的属性上加入@TableField注解，指定自动填充的策略。</p><p>2、按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口。</p><h4 id="1-2-2-代码实现"><a href="#1-2-2-代码实现" class="headerlink" title="1.2.2 代码实现"></a>1.2.2 代码实现</h4><p><strong>1). 实体类的属性上加入@TableField注解，指定自动填充的策略。</strong></p><p>在员工Employee实体类的公共字段属性上, 加上注解, 指定填充策略。(<font color='red'>ps.在资料中提供的实体类,已经添加了该注解,并指定了填充策略</font>)</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021837252.png" alt="image-20210801092157093" style="zoom:80%;" /> <blockquote><p>FieldFill.INSERT: 插入时填充该属性值</p><p>FieldFill.INSERT_UPDATE: 插入&#x2F;更新时填充该属性值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.ibatis.reflection.MetaObject;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义元数据对象处理器</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyMetaObjecthandler  implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入操作，自动填充</span><br><span class="line">     * @param metaObject</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;公共字段自动填充[insert]...&quot;);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新操作，自动填充</span><br><span class="line">     * @param metaObject</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(&quot;公共字段自动填充[update]...&quot;);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171458989.png" alt="image-20230614221526109"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171458623.png" alt="image-20230614221634833"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171458031.png" alt="image-20230614221705077"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306142211442.png" alt="image-20230614221133086"></p><p><strong>2). 按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口。</strong></p><p>所属包: com.itheima.reggie.common</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义元数据对象处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjecthandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作，自动填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充[insert]...&quot;</span>);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line">        </span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>,LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;createUser&quot;</span>,<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>));</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>,<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作，自动填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充[update]...&quot;</span>);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line"></span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>,LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>,<span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-功能测试"><a href="#1-2-3-功能测试" class="headerlink" title="1.2.3 功能测试"></a>1.2.3 功能测试</h4><p>编写完了元数据对象处理器之后，我们就可以将之前在新增和修改方法中手动赋值的代码删除或注释掉。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021837307.png" alt="image-20210801093623217" style="zoom: 80%;" />  <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304022119749.png" alt="image-20210801093747896" style="zoom:80%;" /> <p>然后，我们启动项目，在员工管理模块中，测试增加&#x2F;更新员工信息功能，然后通过debug 或者 直接查询数据库数据变更的形式，看看我们在新增&#x2F;修改数据时，这些公共字段数据是否能够完成自动填充。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171459880.png" alt="image-20230614224122599"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171519871.png" alt="image-20230614224201542"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171459935.png" alt="image-20230614224238582"></p><p>代码解释1</p><p>以上代码是一个自定义的元数据对象处理器（MyMetaObjecthandler），它实现了MyBatis-Plus框架中的MetaObjectHandler接口。MetaObjectHandler接口提供了插入和更新操作时自动填充字段的方法。</p><p>该处理器使用了Spring框架的@Component注解，表示它是一个由Spring容器管理的组件。同时，它还使用了Lombok的@Slf4j注解，用于自动生成日志记录相关的代码。</p><p>在该处理器中，有两个方法需要实现：insertFill和updateFill。</p><p>insertFill方法用于在插入操作时自动填充字段的值。在该方法中，首先通过日志记录打印相关信息，然后通过调用MetaObject的setValue方法为metaObject对象设置字段值。具体设置了以下字段的值：</p><ul><li>createTime：设置为当前的LocalDateTime.now()，即当前时间。  创建时间</li><li>updateTime：设置为当前的LocalDateTime.now()，即当前时间。  更新时间</li><li>createUser：设置为1L，即创建用户的ID。</li><li>updateUser：设置为1L，即更新用户的ID。</li></ul><p>updateFill方法用于在更新操作时自动填充字段的值。在该方法中，同样先通过日志记录打印相关信息，然后通过调用MetaObject的setValue方法为metaObject对象设置字段值。具体设置了以下字段的值：</p><ul><li>updateTime：设置为当前的LocalDateTime.now()，即当前时间。</li><li>updateUser：设置为1L，即更新用户的ID。</li></ul><p>这样，在进行插入和更新操作时，就会自动填充指定的字段值，无需手动设置，提高了代码的简洁性和开发效率。</p><p>代码解释2</p><p>以上代码是一个自定义的元数据对象处理器（MetaObjectHandler），用于在进行数据库操作（插入和更新）时，自动填充指定的公共字段。</p><p>代码中的注解<code>@Component</code>表示该类是一个Spring组件，会被Spring容器进行管理。</p><p><code>@Slf4j</code>是一个Lombok注解，用于生成日志相关的代码。</p><p>该类实现了MyBatis-Plus框架的<code>MetaObjectHandler</code>接口，这个接口定义了在数据库操作时填充元数据对象的方法。</p><p>在该类中，有两个方法：<code>insertFill</code>和<code>updateFill</code>。这两个方法分别在插入和更新操作时被调用。</p><p><code>insertFill</code>方法用于在插入数据时自动填充字段。方法的参数<code>metaObject</code>表示元数据对象，可以通过该对象操作对应实体类的属性。</p><p>在方法中，首先通过日志输出一条提示信息，表示当前是插入操作，并输出元数据对象的信息。</p><p>接下来，通过<code>metaObject.setValue</code>方法给元数据对象的字段赋值。具体来说，给<code>createTime</code>和<code>updateTime</code>字段赋值为当前时间（使用<code>LocalDateTime.now()</code>获取当前时间），给<code>createUser</code>和<code>updateUser</code>字段赋值为1（使用<code>new Long(1)</code>表示1的长整型值）。</p><p><code>updateFill</code>方法与<code>insertFill</code>方法类似，用于在更新数据时自动填充字段。</p><p>在方法中，同样通过日志输出一条提示信息，表示当前是更新操作，并输出元数据对象的信息。</p><p>然后，给元数据对象的<code>updateTime</code>字段赋值为当前时间，给<code>updateUser</code>字段赋值为1。</p><p>通过在插入和更新操作时调用这两个方法，就能够实现自动填充公共字段的功能，避免在每次操作时手动设置这些字段的值。</p><p>总结起来，以上代码实现了一个自定义的元数据对象处理器，用于在进行数据库插入和更新操作时，自动填充指定的公共字段（如创建时间、更新时间、创建用户、更新用户）。通过该处理器，可以简化数据库操作代码，提高开发效率。</p><p>代码解释3</p><p>这段代码的作用是为数据库操作（插入和更新）提供自动填充功能，即在执行数据库操作时，自动为指定的公共字段赋予特定的值，而无需手动设置这些字段的值。</p><p>这里使用的是MyBatis-Plus框架提供的<code>MetaObjectHandler</code>接口来实现自动填充功能。该接口定义了两个方法：<code>insertFill</code>和<code>updateFill</code>，分别用于插入和更新操作。</p><p>在<code>insertFill</code>方法中，通过传入的<code>metaObject</code>参数来操作元数据对象。首先，使用日志输出一条提示信息，表示当前执行的是插入操作，并打印元数据对象的信息。接下来，通过<code>metaObject.setValue</code>方法给元数据对象的字段赋值。在这段代码中，给<code>createTime</code>字段和<code>updateTime</code>字段设置了当前的时间（使用<code>LocalDateTime.now()</code>获取当前时间），给<code>createUser</code>字段和<code>updateUser</code>字段设置了值为1的<code>Long</code>类型数据（使用<code>new Long(1)</code>表示1的长整型值）。</p><p><code>updateFill</code>方法与<code>insertFill</code>方法类似，用于在执行更新操作时进行字段填充。同样，它也会打印日志信息表示当前执行的是更新操作，并操作元数据对象，将<code>updateTime</code>字段设置为当前时间，将<code>updateUser</code>字段设置为1。</p><p>通过在插入和更新操作前后调用这两个方法，就可以实现自动填充公共字段的功能，无需手动处理这些字段的赋值操作。</p><p>总之，这段代码的作用是在进行数据库插入和更新操作时，自动为指定的公共字段赋予特定的值，提供了方便和简化数据库操作的功能。</p><p>代码解释3</p><p>以上代码是一个自定义的元数据对象处理器 <code>MyMetaObjecthandler</code>,它实现了 <code>com.baomidou.mybatisplus.core.handlers.MetaObjectHandler</code> 接口，该接口定义了在插入和更新操作时如何自动填充元数据的方法。</p><p>在 <code>insertFill</code> 和 <code>updateFill</code> 方法中，分别实现了 <code>MetaObjectHandler</code> 接口中的 <code>insertFill</code> 和 <code>updateFill</code> 方法。</p><p><code>insertFill</code> 方法在插入操作时自动填充元数据，其中 <code>metaObject</code> 参数是待填充的元数据对象。该方法中首先打印了消息 <code>公共字段自动填充 [insert]...</code>,并输出了 <code>metaObject</code> 对象的 toString 方法输出。然后，通过 <code>metaObject.setValue</code> 方法设置了创建时间和更新时间字段的值，以及插入用户的 ID 值 (这里使用了 <code>new Long(1)</code> 创建了一个新的 Long 对象)。</p><p><code>updateFill</code> 方法在更新操作时自动填充元数据，其中 <code>metaObject</code> 参数是待填充的元数据对象。该方法中同样首先打印了消息 <code>公共字段自动填充 [update]...</code>,并输出了 <code>metaObject</code> 对象的 toString 方法输出。然后，通过 <code>metaObject.setValue</code> 方法设置了更新时间和更新用户的 ID 值，均为当前时间。</p><p>需要注意的是，以上代码中的 <code>MetaObjectHandler</code> 实例是由 Spring 框架提供的，不需要手动创建。同时，该实例是在整个应用程序生命周期内保持的，因此可以适用于不同的插入和更新操作。</p><p>代码解释</p><p>以上代码实现了一个自定义的元数据对象处理器 <code>MyMetaObjecthandler</code>,它的作用是在插入和更新操作时自动填充元数据。具体来说，该元数据对象处理器实现了 <code>com.baomidou.mybatisplus.core.handlers.MetaObjectHandler</code> 接口，该接口定义了在插入和更新操作时如何自动填充元数据的方法。</p><p>在 <code>insertFill</code> 和 <code>updateFill</code> 方法中，分别实现了 <code>MetaObjectHandler</code> 接口中的 <code>insertFill</code> 和 <code>updateFill</code> 方法。这些方法的作用是在进行插入或更新操作时，自动填充元数据中的相关字段。</p><p>具体来说，<code>insertFill</code> 方法在插入操作时自动填充元数据，其中 <code>metaObject</code> 参数是待填充的元数据对象。该方法中首先打印了消息 <code>公共字段自动填充 [insert]...</code>,并输出了 <code>metaObject</code> 对象的 toString 方法输出。然后，通过 <code>metaObject.setValue</code> 方法设置了创建时间和更新时间字段的值，以及插入用户的 ID 值 (这里使用了 <code>new Long(1)</code> 创建了了一个新的 Long 对象)。这里需要注意的是，<code>setValue</code> 方法是用来设置元数据中的字段值的，它会覆盖原有的值。</p><p><code>updateFill</code> 方法在更新操作时自动填充元数据，其中 <code>metaObject</code> 参数是待填充的元数据对象。该方法中同样打印了消息 <code>公共字段自动填充 [update]...</code>,并输出了 <code>metaObject</code> 对象的 toString 方法输出。然后，通过 <code>metaObject.setValue</code> 方法设置了更新时间和更新用户的 ID 值，均为当前时间。这里需要注意的是，<code>setValue</code> 方法是用来设置元数据中的字段值的，它会覆盖原有的值。</p><p>需要注意的是，以上代码中的 <code>MetaObjectHandler</code> 实例是由 Spring 框架提供的，不需要手动创建。同时，该实例是在整个应用程序生命周期内保持的，因此可以适用于不同的插入和更新操作。</p><p>总的来说，以上代码的作用是自动填充元数据中的相关字段，以便在插入和更新操作时能够正确地设置数据。这使得开发人员可以减少手动设置元数据的工作，从而更加轻松地编写和维护代码。</p><h3 id="1-3-功能完善"><a href="#1-3-功能完善" class="headerlink" title="1.3 功能完善"></a>1.3 功能完善</h3><h4 id="1-3-1-思路分析"><a href="#1-3-1-思路分析" class="headerlink" title="1.3.1 思路分析"></a>1.3.1 思路分析</h4><p>前面我们已经完成了公共字段自动填充功能的代码开发，但是还有一个问题没有解决，就是我们在自动填充createUser和updateUser时设置的用户id是固定值，现在我们需要完善，改造成动态获取当前登录用户的id。</p><p>大家可能想到，用户登录成功后我们将用户id存入了HttpSession中，现在我从HttpSession中获取不就行了？</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021837683.png" alt="image-20210801131449863" style="zoom:80%;" /> <p>注意，我们在MyMetaObjectHandler类中是不能直接获得HttpSession对象的，所以我们需要通过其他方式来获取登录用户id。</p><p>那么我先搞清楚一点,当我们在修改员工信息时, 我们业务的执行流程是什么样子的,如下图:</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021838876.png" alt="image-20210801133531663" style="zoom:80%;" />  <p>客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程：</p><p>1). LoginCheckFilter的doFilter方法</p><p>2). EmployeeController的update方法</p><p>3). MyMetaObjectHandler的updateFill方法</p><p>我们可以在上述类的方法中加入如下代码(获取当前线程ID,并输出):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">log.info(<span class="string">&quot;线程id为：&#123;&#125;&quot;</span>,id);</span><br></pre></td></tr></table></figure><p>1). LoginCheckFilter的doFilter方法</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171459400.png" alt="image-20230615090437854"></p><p>2). EmployeeController的update方法</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171459759.png" alt="image-20230615090602354"></p><p>3). MyMetaObjectHandler的updateFill方法</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171459919.png" alt="image-20230615090721509"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171500191.png" alt="image-20230615090934429"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171500487.png" alt="image-20230615091006747"></p><p>清理控制台</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171500711.png" alt="image-20230615091135657"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171500823.png" alt="image-20230615091223121"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171500783.png" alt="image-20230615091253528"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171501407.png" alt="image-20230615091643429"></p><p>执行编辑员工功能进行验证，通过观察控制台输出可以发现，一次请求对应的线程id是相同的：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021838740.png" alt="image-20210801133827264" style="zoom:80%;" />  <p>经过上述的分析之后,发现我们可以使用JDK提供的一个类, 来解决此问题,它是JDK中提供的 ThreadLocal。</p><h4 id="1-3-2-ThreadLocal"><a href="#1-3-2-ThreadLocal" class="headerlink" title="1.3.2 ThreadLocal"></a>1.3.2 ThreadLocal</h4><p>ThreadLocal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问当前线程对应的值。</p><p><strong>ThreadLocal常用方法：</strong></p><p>A. public void set(T value) : 设置当前线程的线程局部变量的值</p><p>B. public T get() : 返回当前线程所对应的线程局部变量的值</p><p>C. public void remove() : 删除当前线程所对应的线程局部变量的值 </p><p>我们可以在LoginCheckFilter的doFilter方法中获取当前登录用户id，并调用ThreadLocal的set方法来设置当前线程的线程局部变量的值（用户id），然后在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法来获得当前线程所对应的线程局部变量的值（用户id）。 如果在后续的操作中, 我们需要在Controller &#x2F; Service中要使用当前登录用户的ID, 可以直接从ThreadLocal直接获取。</p><h4 id="1-3-3-操作步骤"><a href="#1-3-3-操作步骤" class="headerlink" title="1.3.3 操作步骤"></a>1.3.3 操作步骤</h4><p>实现步骤：</p><p>1). 编写BaseContext工具类，基于ThreadLocal封装的工具类</p><p>2). 在LoginCheckFilter的doFilter方法中调用BaseContext来设置当前登录用户的id</p><p>3). 在MyMetaObjectHandler的方法中调用BaseContext获取登录用户的id</p><h4 id="1-3-4-代码实现"><a href="#1-3-4-代码实现" class="headerlink" title="1.3.4 代码实现"></a>1.3.4 代码实现</h4><p><strong>1). BaseContext工具类</strong></p><p>所属包: com.itheima.reggie.common</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171501136.png" alt="image-20230615092655419"></p><p>代码解释1</p><p>以上代码是一个基于ThreadLocal封装的工具类，用于保存和获取当前登录用户的ID。下面逐行解释代码的含义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BaseContext &#123;   //这是定义了一个名为BaseContext的类。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在这里，我们创建了一个私有的静态ThreadLocal变量threadLocal。ThreadLocal是Java中的一个线程本地变量，它提供了线程局部变量的功能。每个线程都有自己的副本，互不干扰。</span><br><span class="line">private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是一个公共的静态方法setCurrentId，它接受一个Long类型的参数id。该方法将传入的id值存储到当前线程的threadLocal变量中。</span><br><span class="line"> public static void setCurrentId(Long id)&#123;</span><br><span class="line">       threadLocal.set(id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这是另一个公共的静态方法getCurrentId，它返回当前线程的threadLocal变量中存储的值。</span><br><span class="line">public static Long getCurrentId()&#123;</span><br><span class="line">     return threadLocal.get();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上所述，通过使用ThreadLocal封装，我们可以在应用程序中的任何位置设置和获取当前登录用户的ID。该工具类提供了一种在多线程环境中保存和访问用户ID的便捷方式，每个线程都可以独立地存储和访问自己的ID值，避免了线程安全问题。</p><p>代码解释2</p><p>以上代码是一个基于 <code>ThreadLocal</code> 的封装工具类，用于保存和获取当前登录用户的 ID。具体来说，该工具类实现了 <code>ThreadLocal</code> 接口，并将 <code>ThreadLocal</code> 的 <code>set</code> 和 <code>get</code> 方法封装起来，以便在线程中保存和获取当前登录用户的 ID。</p><p>在 <code>BaseContext</code> 类中，创建了一个 <code>ThreadLocal</code> 对象 <code>threadLocal</code>,该对象保存了一个 <code>Long</code> 类型的值，用于存储当前登录用户的 ID。<code>setCurrentId</code> 方法用于设置当前登录用户的 ID，它将 <code>id</code> 参数传递给 <code>threadLocal.set</code> 方法，将新的 ID 值保存在 <code>threadLocal</code> 对象中。</p><p><code>getCurrentId</code> 方法用于获取当前登录用户的 ID，它调用 <code>threadLocal.get</code> 方法获取 <code>threadLocal</code> 对象中的值，即当前登录用户的 ID。由于 <code>threadLocal</code> 对象是线程安全的，因此可以在多个线程之间共享该对象，从而确保同一线程中的多个请求能够获得相同的当前登录用户 ID。</p><p>总的来说，以上代码的作用是提供一个封装工具类，以便在线程中保存和获取当前登录用户的 ID。这使得开发人员可以在多个线程之间共享当前登录用户 ID，而不需要在每次请求时手动获取 ID，从而简化了代码的编写和维护。</p><p><strong>2).LoginCheckFilter中存放当前登录用户到ThreadLocal</strong></p><p>在doFilter方法中, 判定用户是否登录, 如果用户登录, 在放行之前, 获取HttpSession中的登录用户信息, 调用BaseContext的setCurrentId方法将当前登录用户ID存入ThreadLocal。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">BaseContext.setCurrentId(empId);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021838548.png" alt="image-20210801162053581" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171501904.png" alt="image-20230615093854098"></p><p><strong>3). MyMetaObjectHandler中从ThreadLocal中获取</strong></p><p>将之前在代码中固定的当前登录用户1， 修改为动态调用BaseContext中的getCurrentId方法获取当前登录用户ID</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 插入操作，自动填充</span><br><span class="line">     * @param metaObject</span><br><span class="line">     */</span><br><span class="line">metaObject.setValue(&quot;createUser&quot;,BaseContext.getCurrentId());</span><br><span class="line">metaObject.setValue(&quot;updateUser&quot;,BaseContext.getCurrentId());</span><br><span class="line"> </span><br><span class="line">     /**</span><br><span class="line">     * 更新操作，自动填充</span><br><span class="line">     * @param metaObject</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">metaObject.setValue(&quot;updateUser&quot;,BaseContext.getCurrentId());</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021838221.png" alt="image-20210801162345846" style="zoom:80%;" /> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021838677.png" alt="image-20210801162436740" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171501376.png" alt="image-20230615094208839"></p><h4 id="1-3-5-功能测试"><a href="#1-3-5-功能测试" class="headerlink" title="1.3.5 功能测试"></a>1.3.5 功能测试</h4><p>完善了元数据对象处理器之后，我们就可以重新启动项目，完成登录操作后, 在员工管理模块中，测试增加&#x2F;更新员工信息功能, 直接查询数据库数据变更，看看我们在新增&#x2F;修改数据时，这些公共字段数据是否能够完成自动填充, 并且看看填充的create_user 及 update_user字段值是不是本地登录用户的ID。</p><p>打断点</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171501592.png" alt="image-20230615094650184"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171519735.png" alt="image-20230615094714038"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171501743.png" alt="image-20230615094855916"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502512.png" alt="image-20230615094919159"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502311.png" alt="image-20230615094942074"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502439.png" alt="image-20230615095206658"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502727.png" alt="image-20230615095231212"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502000.png" alt="image-20230615095337529"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502911.png" alt="image-20230615095438928"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502584.png" alt="image-20230615095501402"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171502400.png" alt="image-20230615095622661"></p><p>6次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503103.png" alt="image-20230615095706703"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171520575.png" alt="image-20230615095741018"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503751.png" alt="image-20230615095823916"></p><p> 在重新保存一份</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503991.png" alt="image-20230615163529138"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503598.png" alt="image-20230615163617341"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503094.png" alt="image-20230615163659305"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503463.png" alt="image-20230615163741555"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503327.png" alt="image-20230615163807191"></p><p>现在都是空的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171503046.png" alt="image-20230615163843729"></p><p>6次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504311.png" alt="image-20230615163948297"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504646.png" alt="image-20230615164125504"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504303.png" alt="image-20230615164202319"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171528758.png" alt="image-20230615164247287"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504534.png" alt="image-20230615170520307"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504062.png" alt="image-20230615170501467"></p><p>切换用户</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504415.png" alt="image-20230615170707982"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504200.png" alt="image-20230615170734216"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504343.png" alt="image-20230615171034701"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171504615.png" alt="image-20230615171113998"></p><p>6次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171505115.png" alt="image-20230615171201503"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171505462.png" alt="image-20230615171224143"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171505710.png" alt="image-20230615171306864"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171505335.png" alt="image-20230615171401214"></p><h2 id="2-新增分类"><a href="#2-新增分类" class="headerlink" title="2. 新增分类"></a>2. 新增分类</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>后台系统中可以管理分类信息，分类包括两种类型，分别是 <strong>菜品分类</strong> 和 <strong>套餐分类</strong> 。当我们在后台系统中添加菜品时需要选择一个菜品分类，当我们在后台系统中添加一个套餐时需要选择一个套餐分类，在移动端也会按照菜品分类和套餐分类来展示对应的菜品和套餐。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171505948.png" alt="image-20210801163745391" style="zoom:80%;" /> <p>在分类管理中,我们新增分类时, 可以选择新增菜品分类(川菜、湘菜、粤菜…), 也可以选择新增套餐分类(营养早餐、超值午餐…)。 在添加套餐的时候, 输入的排序字段, 控制的是移动端套餐列表的展示顺序。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021839548.png" alt="image-20210801165118745" style="zoom:80%;" /> <h3 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2 数据模型"></a>2.2 数据模型</h3><p>新增分类，其实就是将我们新增窗口录入的分类数据,插入到category表，具体表结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021839901.png" alt="image-20210801165801665"> </p><p>我们添加的套餐名称，是唯一的，不能够重复的，所以在设计表结构时，已经针对于name字段建立了唯一索引，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021839052.png" alt="image-20210801165921450"> </p><h3 id="2-3-前端页面分析"><a href="#2-3-前端页面分析" class="headerlink" title="2.3 前端页面分析"></a>2.3 前端页面分析</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程：</p><p>1). 在页面(backend&#x2F;page&#x2F;category&#x2F;list.html)的新增分类表单中填写数据，点击 “确定” 发送ajax请求，将新增分类窗口输入的数据以json形式提交到服务端</p><p>2). 服务端Controller接收页面提交的数据并调用Service将数据进行保存</p><p>3). Service调用Mapper操作数据库，保存数据</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171505031.png" alt="image-20230615205829505"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506030.png" alt="image-20230615210256323"></p><p>这个页面是以下这个页面  </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506894.png" alt="image-20230615210339733"></p><p>输入完之后   点击确定  就会发送一个发送ajax请求  将新增分类窗口输入的数据以json形式提交到服务端</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506526.png" alt="image-20230615210522228"></p><p>F12</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506623.png" alt="image-20230615210741767"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506503.png" alt="image-20230615211002764"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506240.png" alt="image-20230615211022573"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506606.png" alt="image-20230615211156185"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171506215.png" alt="image-20230615211240146"></p><p>可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的json数据结构相同，所以服务端只需要提供一个方法统一处理即可：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021840093.png" alt="image-20210801171125255" style="zoom:80%;" /> <p>具体请求信息整理如下: </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>POST</td></tr><tr><td>请求路径</td><td>&#x2F;category</td></tr><tr><td>请求参数</td><td>json格式 - {“name”:”川菜”,”type”:”1”,”sort”:2}</td></tr></tbody></table><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><p>代码实现的具体步骤如下: </p><ul><li><p>实体类Category（直接从课程资料中导入即可）</p></li><li><p>Mapper接口CategoryMapper</p></li><li><p>业务层接口CategoryService</p></li><li><p>业务层实现类CategoryServiceImpl</p></li><li><p>控制层CategoryController</p></li></ul><p><strong>1). 实体类Category</strong></p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类型 1 菜品分类 2 套餐分类</span></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顺序</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建人</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改人</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). Mapper接口CategoryMapper</strong></p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Category;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3). 业务层接口CategoryService</strong></p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Category&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4). 业务层实现类CategoryServiceImpl</strong></p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Category;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.CategoryMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.CategoryService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CategoryMapper,Category&gt; <span class="keyword">implements</span> <span class="title class_">CategoryService</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 控制层CategoryController</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.reggie.common.R;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Category;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.CategoryService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分类管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/category&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增分类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Category category)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;category:&#123;&#125;&quot;</span>,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        <span class="keyword">return</span> R.success(<span class="string">&quot;新增分类成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个Java类，表示一个分类管理的控制器（Controller）。下面是对代码的详细解释：</p><ol><li><code>@RestController</code>: 这是一个注解，用于声明这个类是一个RESTful风格的控制器。它是Spring MVC框架的一部分，用于处理HTTP请求和响应。</li><li><code>@RequestMapping(&quot;/category&quot;)</code>: 这是一个注解，指定了处理请求的URL路径。在这个例子中，所有与分类相关的请求都将以”&#x2F;category”作为根路径。</li><li><code>@Slf4j</code>: 这是一个Lombok注解，自动生成日志记录器。<code>log</code>对象可以在代码中用于输出日志信息。</li><li><code>public class CategoryController</code>: 这是一个Java类的定义，表示一个分类管理的控制器。</li><li><code>@Autowired</code>: 这是一个Spring框架的注解，用于自动装配（注入）依赖对象。在这个例子中，<code>CategoryService</code>类的一个实例将被自动注入到<code>categoryService</code>字段中。</li><li><code>@PostMapping</code>: 这是一个注解，表示这个方法处理HTTP POST请求。</li><li><code>public R&lt;String&gt; save(@RequestBody Category category)</code>: 这是一个处理POST请求的方法。它接受一个<code>Category</code>对象作为请求的主体（RequestBody），并返回一个<code>R&lt;String&gt;</code>对象作为响应。<code>R</code>是一个自定义的泛型类，用于封装响应结果。</li><li><code>log.info(&quot;category:&#123;&#125;&quot;,category)</code>: 这是一个日志输出语句，使用<code>log</code>对象输出日志信息。<code>&#123;&#125;</code>是占位符，将<code>category</code>对象的值插入到日志消息中。</li><li><code>categoryService.save(category)</code>: 这是调用<code>categoryService</code>对象的<code>save</code>方法，将传入的<code>category</code>对象保存到数据库或进行相应的业务处理。</li><li><code>return R.success(&quot;新增分类成功&quot;)</code>: 这是方法的返回语句，返回一个成功的<code>R</code>对象，并设置响应消息为”新增分类成功”。</li></ol><p>总结：以上代码定义了一个分类管理的控制器，包含了一个处理新增分类请求的方法。当收到POST请求时，它会接受一个<code>Category</code>对象作为请求主体，并将该对象保存到数据库或进行其他业务处理。最后，它返回一个包含成功消息的<code>R</code>对象作为响应。</p><p>代码解释2</p><p>当我们开发一个Web应用程序时，通常需要有一些类来处理不同的功能。在这个例子中，我们正在开发一个分类管理的功能。</p><p>首先，我们声明了一个类<code>CategoryController</code>，这个类被注解为<code>@RestController</code>，这意味着它是一个用于处理HTTP请求和响应的控制器。它扮演着接收请求、处理逻辑和返回响应的角色。</p><p>在类的顶部，我们使用了一个注解<code>@RequestMapping(&quot;/category&quot;)</code>，这是用来指定处理请求的URL路径。也就是说，当我们的应用程序接收到以<code>/category</code>开头的HTTP请求时，将由这个控制器来处理。</p><p>接下来，我们注入了一个<code>CategoryService</code>对象到<code>categoryService</code>字段中，这是通过<code>@Autowired</code>注解来实现的。这意味着我们可以直接在控制器中使用<code>categoryService</code>对象，而不需要手动创建它。</p><p>在控制器中，有一个名为<code>save</code>的方法，被注解为<code>@PostMapping</code>，表示它处理HTTP POST请求。这个方法接受一个<code>Category</code>对象作为参数，这个对象是通过请求的主体（RequestBody）传递的。主要用途是保存分类信息到数据库或进行其他相关的业务处理。</p><p>在方法的开始处，我们使用日志记录器<code>log</code>输出一条日志信息。这条日志信息包含了接收到的<code>category</code>对象的内容，它会显示在日志文件中，方便我们在开发过程中进行调试和跟踪。</p><p>接着，我们调用<code>categoryService</code>对象的<code>save</code>方法，将传入的<code>category</code>对象保存到数据库或进行相应的业务处理。这是一个根据具体业务逻辑实现的方法，我们需要根据实际需求在<code>CategoryService</code>类中进行定义。</p><p>最后，我们使用<code>R.success(&quot;新增分类成功&quot;)</code>创建一个成功的响应对象，并将其作为方法的返回值。<code>R</code>对象是一个自定义的泛型类，它封装了响应的数据和状态信息。在这里，我们将成功消息设置为”新增分类成功”，并返回给客户端。</p><p>总结起来，以上代码是一个分类管理的控制器，它接收HTTP POST请求，保存分类信息到数据库或进行相关的业务处理，并返回一个成功的响应消息给客户端。通过日志记录器，我们可以在开发过程中跟踪和调试代码。</p><p>代码解释3</p><p>以上代码是一个基于 Spring Boot 框架的 Web 应用程序中的 CategoryController 类。以下是对该代码的详细解释:</p><p>@RestController - 声明了一个 RestController 类，该类该类用于处理 Web 请求。</p><p>@RequestMapping(“&#x2F;category”) - 指定了请求的 URL 路径为 &#x2F;category，表示该路径是分类管理的响应请求。</p><p>@Slf4j - 声明了一个 slf4j 日志管理器，用于记录日志信息。</p><p>public class CategoryController { - 定义了一个公共类 CategoryController，该类包含一个内部类 CategoryService。</p><p>@Autowired - 自动注入了一个 CategoryService 服务类，该服务类是由 Spring 容器提供的。</p><p>save(@RequestBody Category category) - 定义了一个 save 方法，该方法接收一个 Category 对象作为参数。</p><p>log.info(“category:{}”,category); - 在方法内部使用了 log.info() 方法来记录一条日志信息，其中 category 是一个 Category 对象，它将作为日志信息的参数。</p><p>categoryService.save(category); - 将 Category 对象保存到数据库中。</p><p>return R.success(“新增分类成功”); - 在方法返回值中使用 R.success() 方法返回一个字符串值，表示分类新增成功。</p><p>}</p><p>前端分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507415.png" alt="image-20230615222038412"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507095.png" alt="image-20230615222212087"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171521744.png" alt="image-20230615222350703"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//数据提交</span><br><span class="line">     submitForm(st) &#123;</span><br><span class="line">         const classData = this.classData</span><br><span class="line">         const valid = (classData.name === 0 ||classData.name)  &amp;&amp; (classData.sort === 0 || classData.sort)</span><br><span class="line">         if (this.action === &#x27;add&#x27;) &#123;</span><br><span class="line">           if (valid) &#123;</span><br><span class="line">             const reg = /^\d+$/</span><br><span class="line">             if (reg.test(classData.sort)) &#123;</span><br><span class="line">               addCategory(&#123;&#x27;name&#x27;: classData.name,&#x27;type&#x27;:this.type, sort: classData.sort&#125;).then(res =&gt; &#123;</span><br><span class="line">                 console.log(res)</span><br><span class="line">                 if (res.code === 1) &#123;</span><br><span class="line">                   this.$message.success(&#x27;分类添加成功！&#x27;)</span><br><span class="line">                   if (!st) &#123;</span><br><span class="line">                     this.classData.dialogVisible = false</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                     this.classData.name = &#x27;&#x27;</span><br><span class="line">                     this.classData.sort = &#x27;&#x27;</span><br><span class="line">                   &#125;</span><br><span class="line">                   this.handleQuery()</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                   this.$message.error(res.msg || &#x27;操作失败&#x27;)</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;).catch(err =&gt; &#123;</span><br><span class="line">                 this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">               &#125;)</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">               this.$message.error(&#x27;排序只能输入数字类型&#x27;)</span><br><span class="line">             &#125;</span><br><span class="line">             </span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             this.$message.error(&#x27;请输入分类名称或排序&#x27;)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else if (valid) &#123;</span><br><span class="line">         const reg = /^\d+$/</span><br><span class="line">         if (reg.test(this.classData.sort)) &#123;</span><br><span class="line">           editCategory(&#123;&#x27;id&#x27;:this.classData.id,&#x27;name&#x27;: this.classData.name, sort: this.classData.sort&#125;).then(res =&gt; &#123;</span><br><span class="line">             if (res.code === 1) &#123;</span><br><span class="line">               this.$message.success(&#x27;分类修改成功！&#x27;)</span><br><span class="line">               this.classData.dialogVisible = false</span><br><span class="line">               this.handleQuery()</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">               this.$message.error(res.msg || &#x27;操作失败&#x27;)</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;).catch(err =&gt; &#123;</span><br><span class="line">             this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           this.$message.error(&#x27;排序只能输入数字类型&#x27;)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         this.$message.error(&#x27;请输入分类名称或排序&#x27;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507423.png" alt="image-20230615222701599"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171521016.png" alt="image-20230615222724856"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507199.png" alt="image-20230615222759185"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507151.png" alt="image-20230615223021447"></p><h3 id="2-5-功能测试"><a href="#2-5-功能测试" class="headerlink" title="2.5 功能测试"></a>2.5 功能测试</h3><p>新增分类的代码编写完毕之后, 我们需要重新启动项目，进入管理系统访问分类管理, 然后进行新增分类测试，需要将所有情况都覆盖全，例如：</p><p>1). 输入的分类名称不存在</p><p>2). 输入已存在的分类名称</p><p>3). 新增菜品分类</p><p>4). 新增套餐分类</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507575.png" alt="image-20230615231746196"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507902.png" alt="image-20230615235406712"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171507351.png" alt="image-20230615231813059"></p><p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508046.png" alt="image-20230615235457314"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508079.png" alt="image-20230615235513059"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508350.png" alt="image-20230615235544060"></p><h2 id="3-分类信息分页查询"><a href="#3-分类信息分页查询" class="headerlink" title="3. 分类信息分页查询"></a>3. 分类信息分页查询</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>系统中的分类很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508947.png" alt="image-20210801172259439" style="zoom:80%;" /> <h3 id="3-2-前端页面分析"><a href="#3-2-前端页面分析" class="headerlink" title="3.2 前端页面分析"></a>3.2 前端页面分析</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程：</p><p>1). 页面发送ajax请求，将分页查询参数(page、pageSize)提交到服务端</p><p>2). 服务端Controller接收页面提交的数据并调用Service查询数据</p><p>3). Service调用Mapper操作数据库，查询分页数据</p><p>4). Controller将查询到的分页数据响应给页面</p><p>5). 页面接收到分页数据并通过ElementUI的Table组件展示到页面上</p><p>页面加载时,就会触发Vue声明周期的钩子方法,然后执行分页查询,发送异步请求到服务端,前端代码如下: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021840405.png" alt="image-20210801172847501" style="zoom:80%;" />  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">      this.init()</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      async init () &#123;</span><br><span class="line">        await getCategoryPage(&#123;&#x27;page&#x27;: this.page, &#x27;pageSize&#x27;: this.pageSize&#125;).then(res =&gt; &#123;</span><br><span class="line">          if (String(res.code) === &#x27;1&#x27;) &#123;</span><br><span class="line">            this.tableData = res.data.records</span><br><span class="line">            this.counts = Number(res.data.total)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.$message.error(res.msg || &#x27;操作失败&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(err =&gt; &#123;</span><br><span class="line">          this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508199.png" alt="image-20230616143150003"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508863.png" alt="image-20230616143222468"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508447.png" alt="image-20230616143328940"></p><p>页面中使用的是ElementUI提供的分页组件进行分页条的展示:</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021841412.png" alt="image-20210801173229949" style="zoom:80%;" />  <p>我们通过浏览器,也可以抓取到分页查询的请求信息, 如下: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021841084.png" alt="image-20210801172951915" style="zoom:80%;" /> <p>具体的请求信息整理如下: </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;category&#x2F;page</td></tr><tr><td>请求参数</td><td>?page&#x3D;1&amp;pageSize&#x3D;10</td></tr></tbody></table><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><p>在CategoryController中增加分页查询的方法，在方法中传递分页条件进行查询，并且需要对查询到的结果，安排设置的套餐顺序字段sort进行排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize)</span>&#123;</span><br><span class="line">    <span class="comment">//分页构造器</span></span><br><span class="line">    Page&lt;Category&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">    <span class="comment">//条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加排序条件，根据sort进行排序</span></span><br><span class="line">    queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><ol><li><code>@GetMapping(&quot;/page&quot;)</code>: 这是一个使用GET方法的请求映射注解，指定了接口的路径为”&#x2F;page”。</li><li><code>public R&lt;Page&gt; page(int page, int pageSize)</code>: 这是一个公共方法，返回类型为<code>R&lt;Page&gt;</code>，其中<code>R</code>可能是一个自定义的响应对象。该方法接收两个参数<code>page</code>和<code>pageSize</code>，用于指定分页查询的页码和每页的条目数。</li><li><code>Page&lt;Category&gt; pageInfo = new Page&lt;&gt;(page, pageSize)</code>: 这里创建了一个<code>Page</code>对象，用于分页查询。构造函数的参数<code>page</code>表示要查询的页码，<code>pageSize</code>表示每页的条目数。</li><li><code>LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;()</code>: 这里创建了一个<code>LambdaQueryWrapper</code>对象，用于构造查询条件。<code>Category</code>是一个实体类，可能是指定要查询的实体对象。</li><li><code>queryWrapper.orderByAsc(Category::getSort)</code>: 这行代码添加了一个排序条件，按照<code>Category</code>实体类的<code>sort</code>属性进行升序排序。</li><li><code>categoryService.page(pageInfo, queryWrapper)</code>: 这里调用<code>categoryService</code>的<code>page</code>方法进行分页查询。<code>page</code>方法可能是一个业务层的方法，使用传入的<code>pageInfo</code>和<code>queryWrapper</code>进行查询，并将结果封装到<code>pageInfo</code>对象中。</li><li><code>return R.success(pageInfo)</code>: 返回一个响应对象，该对象可能是自定义的<code>R</code>类的静态方法<code>success</code>的调用结果，将分页查询的结果<code>pageInfo</code>作为成功的数据返回。</li></ol><p>总体来说，这段代码接收分页查询的参数，构建分页对象和查询条件对象，调用业务层的方法进行查询，最后将查询结果包装在响应对象中返回。</p><p>代码解释2</p><p>这段代码是一个用于分页查询的接口方法。它接收两个参数，即<code>page</code>和<code>pageSize</code>，用于确定要查询的页码和每页显示的数量。</p><p>首先，我们创建了一个<code>Page</code>对象，用于表示分页信息。这个对象的构造函数接受两个参数：<code>page</code>表示要查询的页码，<code>pageSize</code>表示每页显示的条目数量。</p><p>然后，我们创建了一个<code>LambdaQueryWrapper</code>对象，用于构建查询条件。在这里，我们添加了一个排序条件，根据实体类<code>Category</code>的<code>sort</code>属性进行升序排序。</p><p>接下来，我们调用<code>categoryService</code>的<code>page</code>方法进行分页查询。这个方法可能是一个在业务逻辑层实现的方法。我们将分页对象<code>pageInfo</code>和查询条件对象<code>queryWrapper</code>作为参数传递给该方法。</p><p>最后，我们将查询结果封装在响应对象中并返回。响应对象可能是一个自定义的类，使用<code>R.success(pageInfo)</code>来表示查询成功，并将查询结果<code>pageInfo</code>作为成功的数据返回。</p><p>总的来说，这段代码实现了一个分页查询的功能，根据指定的页码和每页显示的数量进行查询，并按照指定的排序方式返回查询结果。希望这样解释更容易理解！</p><p>代码解释3</p><p>以上代码实现了一个分页查询的方法，其参数为页面页码和每页大小。具体解释如下:</p><ol><li><code>@GetMapping(&quot;/page&quot;)</code>:指定请求路径为&#x2F;page，表示这是一个 GET 请求。</li><li><code>public R&lt;Page&gt;</code>:定义返回类型为<code>R</code>,表示一个通用响应类，这里使用<code>Page</code>作为响应类类型，表示查询结果集。<code>&lt;Page&gt;</code>表示<code>Page</code>是一个泛型类型。</li><li><code>page(int page, int pageSize)</code>:定义一个<code>page</code>方法，接收两个参数<code>page</code>和<code>pageSize</code>,分别表示页面页码和每页大小。</li><li><code>//分页构造器</code>:注释中提到的分页构造器，用于创建一个<code>Page</code>对象，该对象表示查询结果集的页面。<code>new Page&lt;&gt;(page,pageSize)</code>表示创建一个<code>Page</code>对象，其中<code>page</code>表示页面页码，<code>pageSize</code>表示每页大小。</li><li><code>//条件构造器</code>:注释中提到的条件构造器，用于创建一个<code>LambdaQueryWrapper</code>对象，该对象表示查询条件。<code>new LambdaQueryWrapper&lt;&gt;();</code>表示创建一个<code>LambdaQueryWrapper</code>对象。</li><li><code>//添加排序条件，根据 sort 进行排序</code>:注释中提到的添加排序条件，根据<code>sort</code>字段进行排序。<code>queryWrapper.orderByAsc(Category::getSort)</code>表示按照<code>Category</code>对象的<code>sort</code>字段进行升序排序。</li><li><code>//分页查询</code>:注释中提到的分页查询，调用<code>categoryService.page(pageInfo,queryWrapper)</code>方法进行查询。</li><li><code>return R.success(pageInfo)</code>:返回一个<code>R</code>对象，其中<code>success</code>表示成功，<code>pageInfo</code>表示查询结果集。</li></ol><p>总之，以上代码实现了一个分页查询的方法，接收页面页码和每页大小作为参数，创建了一个<code>Page</code>对象表示查询结果集，并添加了排序条件。最后，调用<code>categoryService.page(pageInfo,queryWrapper)</code>方法进行查询，并将查询结果集返回给客户端。</p><p>代码解释4</p><p>这段代码是一个Spring Boot的控制器方法，主要功能是进行分页查询。具体解释如下：</p><ol><li>@GetMapping(“&#x2F;page”) 表示这个方法是一个GET请求，访问路径为”&#x2F;page”。</li><li>int page, int pageSize 表示方法的两个参数，用于指定查询的页码和每页记录数。</li><li>Page<Category> pageInfo &#x3D; new Page&lt;&gt;(page,pageSize); 创建了一个Mybatis-Plus的分页查询对象Page，用于查询指定页码和每页记录数的数据。</li><li>LambdaQueryWrapper<Category> queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;(); 创建了一个Mybatis-Plus的条件查询构造器LambdaQueryWrapper，用于指定查询的条件。</li><li>queryWrapper.orderByAsc(Category::getSort); 指定查询结果按照Category实体类的sort字段升序排序。</li><li>categoryService.page(pageInfo,queryWrapper); 调用service层的方法，进行分页查询，查询结果保存在pageInfo对象中。</li><li>return R.success(pageInfo); 将查询结果封装成自定义的返回结果类型R，并返回查询结果。</li></ol><h3 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h3><p>分页查询的代码编写完毕之后, 我们需要重新启动项目，然后登陆系统后台，点击分类管理，查询分类列表是否可以正常展示。测试过程中可以使用浏览器的监控工具查看页面和服务端的数据交互细节。</p><p>测试完毕后，大家会发现，我们查询数据库返回的类型为 1 或者 2， 但是实际展示到页面上的却是 “菜品分类” 或 “套餐分类”，这一块是在前端页面中进行处理的，处理代码如下： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021841989.png" alt="image-20210801173758580" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171508935.png" alt="image-20230616144629334"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171509791.png" alt="image-20230616144652765"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171509135.png" alt="image-20230616144821061"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171509950.png" alt="image-20230616144902559"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171509766.png" alt="image-20230616145117354"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171509598.png" alt="image-20230616145304915"></p><h2 id="4-删除分类"><a href="#4-删除分类" class="headerlink" title="4. 删除分类"></a>4. 删除分类</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p>在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021841652.png" alt="image-20210801220637396" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171509311.png" alt="image-20230616180403144"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171509870.png" alt="image-20230616180511018"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510006.png" alt="image-20230616180755456"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510951.png" alt="image-20230616180914146"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除</span><br><span class="line">      deleteHandle(id) &#123;</span><br><span class="line">        this.$confirm(&#x27;此操作将永久删除该文件, 是否继续?&#x27;, &#x27;提示&#x27;, &#123;</span><br><span class="line">          &#x27;confirmButtonText&#x27;: &#x27;确定&#x27;,</span><br><span class="line">          &#x27;cancelButtonText&#x27;: &#x27;取消&#x27;,</span><br><span class="line">          &#x27;type&#x27;: &#x27;warning&#x27;</span><br><span class="line">        &#125;).then(() =&gt; &#123;</span><br><span class="line">          deleCategory(id).then(res =&gt; &#123;</span><br><span class="line">            if (res.code === 1) &#123;</span><br><span class="line">              this.$message.success(&#x27;删除成功！&#x27;)</span><br><span class="line">              this.handleQuery()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              this.$message.error(res.msg || &#x27;操作失败&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).catch(err =&gt; &#123;</span><br><span class="line">            this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p>如果点击确定  会执行deleCategory(id)  方法  然后把id带过来</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510302.png" alt="image-20230616181150085"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510750.png" alt="image-20230616181237016"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 删除当前列的接口</span><br><span class="line">const deleCategory = (ids) =&gt; &#123;</span><br><span class="line">  return $axios(&#123;</span><br><span class="line">    url: &#x27;/category&#x27;,</span><br><span class="line">    method: &#x27;delete&#x27;,</span><br><span class="line">    params: &#123; ids &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-前端页面分析"><a href="#4-2-前端页面分析" class="headerlink" title="4.2 前端页面分析"></a>4.2 前端页面分析</h3><p>在前端页面中，点击 “删除” 按钮，就会触发定义的方法，然后往服务端发送异步请求，并传递参数id，执行删除分类操作。</p> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021841964.png" alt="image-20210801221049176" style="zoom:80%;" />  <p>删除操作的具体执行流程如下： </p><p>1). 点击删除，页面发送ajax请求，将参数(id)提交到服务端</p><p>2). 服务端Controller接收页面提交的数据并调用Service删除数据</p><p>3). Service调用Mapper操作数据库</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021841405.png" alt="image-20210801221343539" style="zoom:80%;" /> <p>从上述的分析中，我们可以得到请求的信息如下：</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>DELETE</td></tr><tr><td>请求路径</td><td>&#x2F;category</td></tr><tr><td>请求参数</td><td>?id&#x3D;1395291114922618881</td></tr></tbody></table><h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><p>在CategoryController中增加根据ID删除的方法，在方法中接收页面传递参数id，然后执行删除操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id删除分类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;删除分类，id为：&#123;&#125;&quot;</span>,id);</span><br><span class="line">    categoryService.removeById(id);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;分类信息删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际操作时 没有删除成功  是因为传入后端的是ids 所以要把id修改成ids</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510494.png" alt="image-20230616203535352"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510078.png" alt="image-20230616203606328"></p><p>或者把前端里面deleCategory()方法里面的ids修改回id也可以</p><p>代码解释1</p><p>以上代码是一个Java Spring Boot控制器（Controller）中的一个方法，用于根据给定的id删除分类信息。让我逐步解释代码的功能和结构。</p><ol><li><p>方法签名：代码开头的注释部分是对该方法的说明，指出了该方法的功能和参数。根据注释，该方法接受一个Long类型的id参数，并返回一个泛型为R<String>的对象。</p></li><li><p>@DeleteMapping：这是一个Spring框架的注解，用于将HTTP DELETE请求映射到该方法。这意味着当客户端发送一个DELETE请求到相应的URL时，该方法将被调用。</p></li><li><p>方法实现：方法体中的代码是实际的方法实现逻辑。</p><p>a. 日志记录：第一行代码使用了一个日志记录框架（可能是log4j或其他类似的框架）来记录一条信息。该日志语句将打印出一个带有id的删除分类的信息。</p><p>b. 分类删除：接下来的一行代码调用了一个名为categoryService的服务或业务逻辑组件的removeById方法，传递了id参数。这个方法的功能是根据给定的id从数据库或其他数据存储中删除相应的分类信息。</p><p>c. 返回结果：最后一行代码使用了一个自定义的R类（可能是一个封装了响应结果的实用类）创建了一个成功的响应对象，并包含一条消息，指示分类信息删除成功。</p></li></ol><p>总结：以上代码实现了一个HTTP DELETE请求处理方法，它接收一个id参数，并在日志中记录删除操作，然后调用分类服务的removeById方法删除相应的分类信息，并返回一个带有成功消息的响应对象。请注意，这只是代码的一部分，还可能包含其他方法和类来实现完整的控制器功能。</p><p>代码解释2</p><p>以上代码实现了一个根据 ID 删除分类的方法。具体解释如下:</p><ol><li><code>@DeleteMapping</code>:指定删除请求的映射路径，这里使用<code>@DeleteMapping</code>注解标记在方法上，表示该方法处理删除请求。</li><li><code>public R&lt;String&gt;</code>:定义返回类型为<code>R</code>,表示一个通用响应类，这里使用<code>R</code>作为响应类类型，表示返回一个字符串。<code>&lt;String&gt;</code>表示<code>R</code>的泛型类型是一个字符串类型的类型。</li><li><code>delete(Long id)</code>:定义一个<code>delete</code>方法，接收一个参数<code>id</code>,表示要删除的分类的 ID。</li><li><code>log.info(&quot;删除分类，id 为:&#123;&#125;&quot;,id);</code>:在日志中记录一条信息，表示删除的分类的 ID 为<code>id</code>。</li><li><code>categoryService.removeById(id);</code>:调用<code>categoryService</code>的<code>removeById</code>方法，该方法接收一个参数<code>id</code>,表示要删除的分类的 ID。</li><li><code>return R.success(&quot;分类信息删除成功&quot;);</code>:返回一个<code>R</code>对象，其中<code>success</code>表示成功，返回字符串<code>&quot;分类信息删除成功&quot;</code>表示删除分类成功。</li></ol><p>总之，以上代码实现了一个根据 ID 删除分类的方法，通过日志记录的方式记录删除的分类的 ID，然后调用<code>categoryService</code>的<code>removeById</code>方法进行删除操作，最后返回一个成功响应字符串表示删除成功。</p><p>代码解释3</p><p>这是一个Spring Boot的控制器类，用来处理删除分类信息的请求。具体解释如下：</p><ol><li><p>@DeleteMapping：这是一个注解，表示这个方法是用来处理删除请求的，相当于HTTP的DELETE方法。</p></li><li><p>public R<String> delete(Long id)：这个方法的返回值是一个R对象，其中包含了操作结果的状态码、消息以及数据。参数id表示要删除的分类的id。</p></li><li><p>log.info(“删除分类，id为：{}”,id)：这是一个日志记录语句，用来记录删除操作的日志信息，其中{}表示占位符，会被后面的参数id所替代。</p></li><li><p>categoryService.removeById(id)：这行代码是调用分类服务的removeById方法来删除指定id的分类信息。</p></li><li><p>return R.success(“分类信息删除成功”)：这行代码返回一个成功的操作结果，其中包含了一条成功消息，表示分类信息删除成功。</p></li></ol><p>总之，这段代码实现了删除分类信息的功能，并且通过日志记录和返回操作结果的方式，让操作变得更加可控和可预测</p><h3 id="4-4-功能测试"><a href="#4-4-功能测试" class="headerlink" title="4.4 功能测试"></a>4.4 功能测试</h3><p>基本的删除操作代码实现完毕后，重启项目，进行测试。可以通过debug断点调试进行测试，同时结合浏览器监控工具查看请求和响应的具体数据。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510535.png" alt="image-20230616183045212"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171510101.png" alt="image-20230616183117557"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171511710.png" alt="image-20230616183227196"></p><h3 id="4-5-功能完善"><a href="#4-5-功能完善" class="headerlink" title="4.5 功能完善"></a>4.5 功能完善</h3><h4 id="4-5-1-思路分析"><a href="#4-5-1-思路分析" class="headerlink" title="4.5.1 思路分析"></a>4.5.1 思路分析</h4><p>在上述的测试中，我们看到分类数据是可以正常删除的。但是并没有检查删除的分类是否关联了菜品或者套餐，所以我们需要进行功能完善。完善后的逻辑为：</p><ul><li>根据当前分类的ID，查询该分类下是否存在菜品，如果存在，则提示错误信息</li><li>根据当前分类的ID，查询该分类下是否存在套餐，如果存在，则提示错误信息</li><li>执行正常的删除分类操作</li></ul><p>那么在这里又涉及到我们后面要用到的两张表结构 dish(菜品表) 和 setmeal(套餐表)。具体的表结构，我们目前先了解一下： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171511981.png" alt="image-20210802001302912" style="zoom:80%;" /> <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021842741.png" alt="image-20210802001348928" style="zoom:80%;" /> <h4 id="4-5-2-准备工作"><a href="#4-5-2-准备工作" class="headerlink" title="4.5.2 准备工作"></a>4.5.2 准备工作</h4><p><strong>1). 准备菜品(Dish)及套餐(Setmeal)实体类(课程资料中直接拷贝)</strong></p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 菜品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dish</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品分类id</span></span><br><span class="line">    <span class="keyword">private</span> Long categoryId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品码</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//描述信息</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0 停售 1 起售</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顺序</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 套餐</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Setmeal</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分类id</span></span><br><span class="line">    <span class="keyword">private</span> Long categoryId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//套餐名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//套餐价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态 0:停用 1:启用</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//描述信息</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). Mapper接口DishMapper和SetmealMapper</strong></p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Dish;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Setmeal;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetmealMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3). Service接口DishService和SetmealService</strong></p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Dish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Setmeal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetmealService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Setmeal&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4). Service实现类DishServiceImpl和SetmealServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Dish;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.DishMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.DishService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;DishMapper,Dish&gt; <span class="keyword">implements</span> <span class="title class_">DishService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Setmeal;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.mapper.SetmealMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.service.SetmealService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetmealServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;SetmealMapper,Setmeal&gt; <span class="keyword">implements</span> <span class="title class_">SetmealService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-3-代码实现"><a href="#4-5-3-代码实现" class="headerlink" title="4.5.3 代码实现"></a>4.5.3 代码实现</h4><p><strong>1). 创建自定义异常</strong></p><p>在业务逻辑操作过程中,如果遇到一些业务参数、操作异常的情况下，我们直接抛出此异常。</p><p>所在包: com.itheima.reggie.common</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义业务异常类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2). 在CategoryService中扩展remove方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CategoryService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Category&gt; &#123;</span><br><span class="line"><span class="comment">//根据ID删除分类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171511127.png" alt="image-20230616185727281"></p><p><strong>3). 在CategoryServiceImpl中实现remove方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DishService dishService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SetmealService setmealService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id删除分类，删除之前需要进行判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//添加查询条件，根据分类id进行查询菜品数据</span></span><br><span class="line">    LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> dishService.count(dishLambdaQueryWrapper);</span><br><span class="line">    <span class="comment">//如果已经关联，抛出一个业务异常</span></span><br><span class="line">    <span class="keyword">if</span>(count1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;当前分类下关联了菜品，不能删除&quot;</span>);<span class="comment">//已经关联菜品，抛出一个业务异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常</span></span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> setmealService.count(setmealLambdaQueryWrapper);</span><br><span class="line">    <span class="keyword">if</span>(count2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;当前分类下关联了套餐，不能删除&quot;</span>);<span class="comment">//已经关联套餐，抛出一个业务异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常删除分类</span></span><br><span class="line">    <span class="built_in">super</span>.removeById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在上述的业务逻辑中，当分类下关联的有菜品或者套餐时，我们在业务代码中抛出了自定义异常，并且在异常中封装了错误提示信息，那这个错误提示信息如何提示给页面呢？</p><p>异常抛出之后，会被异常处理器捕获，我们只需要在异常处理器中捕获这一类的异常，然后给页面返回对应的提示信息即可。</p><p>代码解释1</p><p>以上代码是一个Java类<code>CategoryServiceImpl</code>，它实现了<code>CategoryService</code>接口，并继承了<code>ServiceImpl&lt;CategoryMapper, Category&gt;</code>类。</p><p>该类的作用是对分类进行操作，其中包括根据ID删除分类，并在删除之前进行一些判断。</p><p>代码中使用了Spring框架的<code>@Autowired</code>注解，通过依赖注入的方式获取了<code>DishService</code>和<code>SetmealService</code>的实例，这两个服务类用于对菜品和套餐进行操作。</p><p>在<code>remove(Long id)</code>方法中，首先通过分类ID查询是否存在关联的菜品数据，使用<code>LambdaQueryWrapper</code>构建查询条件，然后调用<code>dishService.count(dishLambdaQueryWrapper)</code>方法获取关联菜品的数量。如果数量大于0，表示当前分类下存在关联的菜品，会抛出一个自定义的业务异常(<code>CustomException</code>)，提示无法删除分类。</p><p>接着，代码查询当前分类是否关联了套餐，方法与上述类似。如果存在关联的套餐，同样会抛出一个业务异常。</p><p>如果以上两个判断都通过，即分类下既没有关联的菜品也没有关联的套餐，那么会调用<code>super.removeById(id)</code>方法，利用继承自<code>ServiceImpl</code>的方法实现正常删除分类的操作。</p><p>总结：以上代码实现了对分类进行删除操作，但在删除之前会先判断分类下是否有关联的菜品和套餐，如果存在关联数据，则会抛出业务异常，否则会执行删除操作。</p><p>代码解释2</p><p>当删除一个分类时，以上代码会进行一些判断和操作。</p><p>首先，代码会检查该分类是否与菜品关联。它会查询与该分类ID相关联的菜品数量。如果数量大于0，表示该分类与一些菜品有关联，就无法删除该分类。这是为了避免删除分类时，与之相关的菜品信息丢失。</p><p>接下来，代码会检查该分类是否与套餐关联。它会查询与该分类ID相关联的套餐数量。如果数量大于0，表示该分类与一些套餐有关联，同样无法删除该分类。这是为了确保与分类相关联的套餐信息不会丢失。</p><p>如果以上两个检查都通过，即分类既没有关联的菜品也没有关联的套餐，那么该分类可以被安全地删除。代码会执行删除操作，将该分类从数据库中删除。</p><p>总结：以上代码在删除分类时，先检查是否有关联的菜品或套餐。如果有关联数据，则无法删除；如果没有关联数据，则可以安全删除。这样可以确保数据的完整性和一致性。</p><p>代码解释3</p><ol><li><p>首先，通过<code>@Autowired</code>注解，注入了<code>DishService</code>和<code>SetmealService</code>的实例，这样就可以使用这两个服务类提供的方法来对菜品和套餐进行操作。</p></li><li><p><code>remove(Long id)</code>方法是删除分类的方法。它接受一个分类ID作为参数。</p></li><li><p>在删除分类之前，代码会先进行两个判断：</p><p>a. 判断是否有关联的菜品：通过创建一个<code>LambdaQueryWrapper&lt;Dish&gt;</code>对象，指定查询条件为菜品的<code>categoryId</code>等于当前分类的ID。然后调用<code>dishService.count(dishLambdaQueryWrapper)</code>方法，统计满足条件的菜品数量。如果数量大于0，表示当前分类下有关联的菜品，就会抛出一个自定义的业务异常(<code>CustomException</code>)，并提示无法删除该分类。</p><p>b. 判断是否有关联的套餐：通过创建一个<code>LambdaQueryWrapper&lt;Setmeal&gt;</code>对象，指定查询条件为套餐的<code>categoryId</code>等于当前分类的ID。然后调用<code>setmealService.count(setmealLambdaQueryWrapper)</code>方法，统计满足条件的套餐数量。如果数量大于0，表示当前分类下有关联的套餐，同样会抛出一个业务异常，提示无法删除该分类。</p></li><li><p>如果以上两个判断都通过，即当前分类既没有关联的菜品也没有关联的套餐，那么就可以安全地删除该分类。代码调用<code>super.removeById(id)</code>方法，利用继承自<code>ServiceImpl</code>的方法来删除数据库中对应的分类记录。</p></li></ol><p>通过这样的判断和操作，代码确保了在删除分类之前，先检查是否存在关联的菜品或套餐。如果有关联数据，就阻止删除操作，以保护数据的完整性。只有当没有关联数据时，才会执行删除操作。这样可以避免意外删除关联数据，并确保系统的数据一致性。</p><p><strong>4). 在GlobalExceptionHandler中处理自定义异常</strong></p><p>在全局异常处理器中增加方法，用于捕获我们自定义的异常 CustomException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler(CustomException.class)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">exceptionHandler</span><span class="params">(CustomException ex)</span>&#123;</span><br><span class="line">    log.error(ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> R.error(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5). 改造CategoryController的delete方法</strong></p><p>注释掉原有的代码，在delete方法中直接调用categoryService中我们自定义的remove方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id删除分类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;删除分类，id为：&#123;&#125;&quot;</span>,id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//categoryService.removeById(id);</span></span><br><span class="line">    categoryService.remove(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;分类信息删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-4-功能测试"><a href="#4-5-4-功能测试" class="headerlink" title="4.5.4 功能测试"></a>4.5.4 功能测试</h4><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171511799.png" alt="image-20230616203322797"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171511191.png" alt="image-20230616191547877"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171511871.png" alt="image-20230616191603123"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171511727.png" alt="image-20230616204151858"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512623.png" alt="image-20230616204342756"></p><p>2次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512575.png" alt="image-20230616210156522"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171522239.png" alt="image-20230616210354878"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512309.png" alt="image-20230616210543082"></p><p>重新删除</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512208.png" alt="image-20230616211019447"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512493.png" alt="image-20230616211056897"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512333.png" alt="image-20230616211139728"></p><p>3次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512518.png" alt="image-20230616211230743"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171512614.png" alt="image-20230616211331113"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171513733.png" alt="image-20230616211441503"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171513838.png" alt="image-20230616211505898"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171513254.png" alt="image-20230616211559672"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171513598.png" alt="image-20230616211711486"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171513606.png" alt="image-20230616211801856"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171513991.png" alt="image-20230616211838052"></p><p>功能完善的代码编写完毕之后, 我们需要重新启动项目，进入管理系统访问分类管理, 然后进行删除分类的测试，需要将所有情况都覆盖全，例如：</p><p>1). 新增一个分类，然后再直接删除，检查是否可以正常删除成功。(新增的分类时没有关联菜品和套餐的)</p><p>2). 在数据库表(dish&#x2F;setmeal)中，找到一个与菜品或套餐关联的分类，然后在页面中执行删除操作，检查是否可以正常的提示出对应的错误信息。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021842140.png" alt="image-20210801235124007" style="zoom:80%;" /> <h2 id="5-修改分类"><a href="#5-修改分类" class="headerlink" title="5. 修改分类"></a>5. 修改分类</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><p>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021842756.png" alt="image-20210801235311435" style="zoom:80%;" /> <h3 id="5-2-前端页面分析"><a href="#5-2-前端页面分析" class="headerlink" title="5.2 前端页面分析"></a>5.2 前端页面分析</h3><p>这里面大家会发现，修改功能我们还没有实现，但是当点击 “修改” 按钮的时候，我们并没有开发根据ID查询数据，进行页面回显的功能，但是页面的分类数据确实回显回来了。这是怎么做到的呢，我们来解析一下前端的代码实现(前端代码已经实现)：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021842740.png" alt="image-20210802000227359" style="zoom:80%;" /> <p>那么回显这一步的操作前端已经实现，我们就只需要开发一个方法，修改操作的方法即可。我们可以通过浏览器来抓取一下修改操作的请求信息，如图：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202304021842996.png" alt="image-20210802000605946" style="zoom:80%;" /> <p>具体的请求信息，整理如下：</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>PUT</td></tr><tr><td>请求路径</td><td>&#x2F;category</td></tr><tr><td>请求参数</td><td>{id: “1399923597874081794”, name: “超值午餐”, sort: 0}</td></tr></tbody></table><p>视频前端分析</p><p>点击修改时 携带列表中的数据   scope.row</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171514238.png" alt="image-20230617001020047"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171523799.png" alt="image-20230617014225854"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171514174.png" alt="image-20230617014559727"></p><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><p>html页面中相关的代码都已经提供好了，我们已经分析了请求的信息，接下来就可以来创建服务端的CategoryController方法update方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id修改分类信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Category category)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;修改分类信息：&#123;&#125;&quot;</span>,category);</span><br><span class="line">    categoryService.updateById(category);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;修改分类信息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个Java后端接口的示例，用于根据id修改分类信息。下面是对代码的解释：</p><ol><li><code>@PutMapping</code>：这是一个Spring框架中的注解，用于将HTTP的PUT请求映射到该方法上。</li><li><code>public R&lt;String&gt; update(@RequestBody Category category)</code>：这是一个公共方法，返回类型为<code>R&lt;String&gt;</code>，即一个封装了响应数据的通用结果对象。它接受一个<code>Category</code>对象作为请求体参数，该对象包含了需要修改的分类信息。</li><li><code>log.info(&quot;修改分类信息：&#123;&#125;&quot;, category)</code>：这是日志输出语句，用于在日志中记录修改的分类信息。</li><li><code>categoryService.updateById(category)</code>：这是调用一个名为<code>categoryService</code>的服务（Service）类中的<code>updateById</code>方法，该方法用于根据id更新分类信息。通过传入的<code>category</code>对象，该方法将根据id找到对应的分类，并将其信息更新为<code>category</code>对象中的新信息。</li><li><code>return R.success(&quot;修改分类信息成功&quot;)</code>：这是返回一个成功的响应结果，其中包含了一个成功的消息字符串”修改分类信息成功”。</li></ol><p>请注意，这只是一个片段代码，可能还有其他相关的类和方法。以上解释仅限于提供的代码片段，并不能完全了解代码的上下文和功能实现。</p><p>代码解释2</p><p>这段代码是一个后端接口的实现，用于根据给定的id来修改分类信息。让我们逐行解释：</p><ol><li><code>@PutMapping</code>：这是一个注解，用于将HTTP的PUT请求映射到这个方法上。PUT请求通常用于更新（修改）资源。</li><li><code>public R&lt;String&gt; update(@RequestBody Category category)</code>：这是一个公共方法，返回类型为<code>R&lt;String&gt;</code>，表示响应结果对象，其中<code>&lt;String&gt;</code>是指示响应数据的类型。方法的名称是<code>update</code>，它接受一个<code>Category</code>类型的参数，被注解<code>@RequestBody</code>修饰，表示从请求体中获取数据并转换为<code>Category</code>对象。</li><li><code>log.info(&quot;修改分类信息：&#123;&#125;&quot;, category)</code>：这行代码用于打印日志信息，输出”修改分类信息：”并将<code>category</code>对象的内容作为日志的参数进行占位。</li><li><code>categoryService.updateById(category)</code>：这行代码调用了一个名为<code>categoryService</code>的服务类中的<code>updateById</code>方法。通过传入的<code>category</code>对象，该方法将根据id找到对应的分类，并将其信息更新为<code>category</code>对象中的新信息。</li><li><code>return R.success(&quot;修改分类信息成功&quot;)</code>：这行代码返回一个成功的响应结果。<code>R.success()</code>是一个静态方法，用于创建一个成功的响应对象，其中包含了一个表示成功消息的字符串，这里是”修改分类信息成功”。</li></ol><p>总结一下，这段代码是一个后端接口的实现，它通过PUT请求来修改给定id的分类信息。它从请求体中获取一个<code>Category</code>对象，将其传递给<code>categoryService</code>服务类的<code>updateById</code>方法进行分类信息的更新，并返回一个成功的响应结果。在这个例子中，日志记录了正在修改的分类信息。</p><p>代码解释3</p><p>该代码为一个Spring Boot项目中的Controller层方法，实现了根据id修改分类信息的功能。具体解释如下：</p><ol><li>@PutMapping</li></ol><p>这是一个RequestMapping注解的派生注解，表示该方法支持HTTP的PUT请求方式，即用于更新资源。</p><ol start="2"><li>public R<String> update(@RequestBody Category category)</li></ol><p>该方法的返回类型为R<String>，表示一个通用返回类型，其中的泛型String表示返回的信息类型。</p><p>该方法只有一个参数，使用了@RequestBody注解，表示该参数是一个请求体中的JSON格式数据，将其转化成一个Category对象。</p><ol start="3"><li>log.info(“修改分类信息：{}”,category);</li></ol><p>使用了slf4j日志门面，将修改的分类信息打印出来。</p><ol start="4"><li>categoryService.updateById(category);</li></ol><p>调用分类的Service层方法，通过id更新分类信息。</p><ol start="5"><li>return R.success(“修改分类信息成功”);</li></ol><p>返回一个R类型的通用返回结果，表示操作成功。</p><p>代码解释4</p><p>以上代码是一个简单的 Spring Boot 应用程序，它实现了一个 “&#x2F;category&#x2F;update” 端点，该端点用于根据 ID 修改分类信息。</p><p>以下是代码的详细解释:</p><ul><li><code>@PutMapping</code> 注解指定了端点的 PUT 请求方法。</li><li><code>public R&lt;String&gt;</code> 返回类型指定了返回值的类型为 <code>R</code>,这里使用 <code>R</code> 表示返回值的类型为 <code>Result</code>。<code>Result</code> 是 Spring Boot 中定义的一个结果类，它包含了请求的状态码、响应体等信息。</li><li><code>@RequestBody</code> 注解指定了请求体参数的类型为 <code>Category</code>,这里使用 <code>Category</code> 表示分类信息的对象类型。</li><li><code>log.info(&quot;修改分类信息:&#123;&#125;&quot;,category);</code> 代码段用于在日志中记录修改分类信息的详细信息，其中 <code>category</code> 是一个对象，它包含了分类信息的详细信息。</li><li><code>categoryService.updateById(category);</code> 代码段调用分类服务中的 <code>updateById</code> 方法，该方法根据 ID 更新分类信息。</li><li><code>return R.success(&quot;修改分类信息成功&quot;);</code> 代码段指定返回值的状态码为 200，并返回一个成功响应体，其中包含了分类信息的详细信息。<code>R.success</code> 方法返回一个 <code>Result</code> 对象，其中包含了成功的响应体信息。</li></ul><p>综上所述，以上代码实现了一个根据 ID 修改分类信息的端点，它通过调用分类服务中的 <code>updateById</code> 方法来更新分类信息，并返回成功响应体。</p><p>代码解释5</p><p>以上代码中，<code>@PutMapping</code> 注解指定了端点的 PUT 请求方法。<code>@RequestBody</code> 注解指定了请求体参数的类型为 <code>Category</code>,这里使用 <code>Category</code> 表示分类信息的对象类型。<code>@RequestBody</code> 注解的作用是在请求体中包含了一个对象，那么这个对象就需要在请求体中被解析出来，然后在服务端进行相应的处理。</p><p><code>log.info(&quot;修改分类信息:&#123;&#125;&quot;,category);</code> 代码段用于在日志中记录修改分类信息的详细信息，其中 <code>category</code> 是一个对象，它包含了分类信息的详细信息，这里使用了 <code>info</code> 日志级别，表示打印详细信息。</p><p><code>categoryService.updateById(category);</code> 代码段调用分类服务中的 <code>updateById</code> 方法，该方法根据 ID 更新分类信息。分类服务的具体实现取决于应用程序的需求，这里只是简单示例。</p><p><code>return R.success(&quot;修改分类信息成功&quot;);</code> 代码段指定返回值的状态码为 200，并返回一个成功响应体，其中包含了分类信息的详细信息。<code>R.success</code> 方法返回一个 <code>Result</code> 对象，其中包含了成功的响应体信息。<code>Result</code> 对象包含了请求的状态码、响应体等信息，可以根据请求的状态码来检查请求是否成功，并根据响应体的信息来进一步处理。</p><p>综上所述，以上代码实现了一个根据 ID 修改分类信息的端点，它通过调用分类服务中的 <code>updateById</code> 方法来更新分类信息，并返回成功响应体。</p><h3 id="5-4-功能测试"><a href="#5-4-功能测试" class="headerlink" title="5.4 功能测试"></a>5.4 功能测试</h3><p>按照前面分析的操作流程进行测试，查看数据是否正常修改即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171514086.png" alt="image-20230617015156538"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171514462.png" alt="image-20230617015216322"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171514990.png" alt="image-20230617015229302"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day03/202306171514775.png" alt="image-20230617015349893"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖-Day02</title>
      <link href="/archives/1.html"/>
      <url>/archives/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖-Day02"><a href="#瑞吉外卖-Day02" class="headerlink" title="瑞吉外卖-Day02"></a>瑞吉外卖-Day02</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li>完善登录功能</li><li>新增员工</li><li>员工信息分页查询</li><li>启用&#x2F;禁用员工账号</li><li>编辑员工信息</li></ul><p>分析前端页面效果是如何实现的</p><p>为什么点击左边 右边会根着变化</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092100003.png" alt="图1"></p><p>首先 我们先来看一下菜单是如何展示出来的 在来看一下 为啥点击菜单时 右边会跟着变</p><p>第一 ：菜单是如何展示出来的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092101695.png" alt="图2"></p><p>我们在创建一个VUE对象的时候 在我们的 data() 的位置 我们准备了 menuList: [] 的一个数据   menuList: [] 是一个数组对象 </p><p>数组对象里面放着一个个JSON数据    而每一个JSON数据里面又放着id name url icon(图标)   以上只是数据的准备 并不是定义就可以展示到菜单的一个位置</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">defAct</span>: <span class="string">&#x27;2&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">menuActived</span>: <span class="string">&#x27;2&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">userInfo</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">menuList</span>: [</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">// &#123;</span></span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//   id: &#x27;1&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//   name: &#x27;门店管理&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//   children: [</span></span></span><br><span class="line"><span class="language-javascript">                  &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">name</span>: <span class="string">&#x27;员工管理&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&#x27;page/member/list.html&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">icon</span>: <span class="string">&#x27;icon-member&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                  &#125;,</span></span><br><span class="line"><span class="language-javascript">                  &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">id</span>: <span class="string">&#x27;3&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">name</span>: <span class="string">&#x27;分类管理&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&#x27;page/category/list.html&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">icon</span>: <span class="string">&#x27;icon-category&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                  &#125;,</span></span><br><span class="line"><span class="language-javascript">                  &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">id</span>: <span class="string">&#x27;4&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">name</span>: <span class="string">&#x27;菜品管理&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&#x27;page/food/list.html&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">icon</span>: <span class="string">&#x27;icon-food&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                  &#125;,</span></span><br><span class="line"><span class="language-javascript">                  &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">id</span>: <span class="string">&#x27;5&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">name</span>: <span class="string">&#x27;套餐管理&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&#x27;page/combo/list.html&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">icon</span>: <span class="string">&#x27;icon-combo&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                  &#125;,</span></span><br><span class="line"><span class="language-javascript">                  &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">id</span>: <span class="string">&#x27;6&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">name</span>: <span class="string">&#x27;订单明细&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>: <span class="string">&#x27;page/order/list.html&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">icon</span>: <span class="string">&#x27;icon-order&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                  &#125;</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//   ],</span></span></span><br><span class="line"><span class="language-javascript">              <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="language-javascript">            ],</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">iframeUrl</span>: <span class="string">&#x27;page/member/list.html&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headTitle</span>: <span class="string">&#x27;员工管理&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">goBackFlag</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">loading</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">timer</span>: <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">computed</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> userInfo = <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;userInfo&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (userInfo) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">userInfo</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(userInfo)</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="title function_">closeLoading</span>()</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">          <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timer</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">window</span>.<span class="property">menuHandle</span> = <span class="variable language_">this</span>.<span class="property">menuHandle</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">logout</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">logoutApi</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="number">00</span></span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span>(res.<span class="property">code</span> === <span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;userInfo&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/backend/page/login/login.html&#x27;</span></span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">goBack</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// window.location.href = &#x27;javascript:history.go(-1)&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> menu = <span class="variable language_">this</span>.<span class="property">menuList</span>.<span class="title function_">find</span>(<span class="function"><span class="params">item</span>=&gt;</span>item.<span class="property">id</span>===<span class="variable language_">this</span>.<span class="property">menuActived</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// this.goBackFlag = false</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// this.headTitle = menu.name</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="title function_">menuHandle</span>(menu,<span class="literal">false</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">menuHandle</span>(<span class="params">item, goBackFlag</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">menuActived</span> = item.<span class="property">id</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">iframeUrl</span> = item.<span class="property">url</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">headTitle</span> = item.<span class="property">name</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">goBackFlag</span> = goBackFlag</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="title function_">closeLoading</span>()</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">closeLoading</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,<span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092315688.png" alt="图3"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">menuList: [    menuList: [] 是一个数组对象 数组对象       //120行</span><br><span class="line">                   </span><br><span class="line">                 &#123;                      里面放着一个个JSON数据</span><br><span class="line">                   id: &#x27;2&#x27;,           每一个JSON数据里面又放着id name url icon(图标) </span><br><span class="line">                   name: &#x27;员工管理&#x27;,</span><br><span class="line">                   url: &#x27;page/member/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-member&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;3&#x27;,</span><br><span class="line">                   name: &#x27;分类管理&#x27;,</span><br><span class="line">                   url: &#x27;page/category/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-category&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;4&#x27;,</span><br><span class="line">                   name: &#x27;菜品管理&#x27;,</span><br><span class="line">                   url: &#x27;page/food/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-food&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;5&#x27;,</span><br><span class="line">                   name: &#x27;套餐管理&#x27;,</span><br><span class="line">                   url: &#x27;page/combo/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-combo&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;6&#x27;,</span><br><span class="line">                   name: &#x27;订单明细&#x27;,</span><br><span class="line">                   url: &#x27;page/order/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-order&#x27;</span><br><span class="line">                 &#125;</span><br><span class="line">             //   ],</span><br><span class="line">             // &#125;,</span><br><span class="line">           ],</span><br></pre></td></tr></table></figure><p>name 有的是’员工管理’, ‘分类管理’,  ‘菜品管理’,  ‘套餐管理’,  ‘订单明细’,    对应的就是我们下图所示、</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092310501.png" alt="图4"></p><p>以上只是数据的准备 并不是定义就可以展示到菜单的一个位置</p><p>第二   怎么展示到菜单的位置</p><p>请到第39行 用到了el-menu组件 下面的v-for表示在遍历 遍历menuList</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-submenu :index=&quot;item.id&quot; v-if=&quot;item.children &amp;&amp; item.children.length&gt;0&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里面的 v-if是不会成立的 但是会执行第64行&lt;el-menu-item v-else :index&#x3D;”item.id” @click&#x3D;”menuHandle(item,false)”&gt;这个分支 然后就可以把<span slot="title"></span> item.name给展示出来 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu</span>             //<span class="attr">菜单组件</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:default-active</span>=<span class="string">&quot;defAct&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:unique-opened</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:collapse-transition</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">background-color</span>=<span class="string">&quot;#343744&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">text-color</span>=<span class="string">&quot;#bfcbd9&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">active-text-color</span>=<span class="string">&quot;#f4f4f5&quot;</span></span></span><br><span class="line"><span class="tag">           &gt;</span>     //item不是固定写法</span><br><span class="line">             <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in menuList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>    //v-for表示在遍历 遍历menuList</span><br><span class="line">                 //判断item里面有没有children属性和children属性的length是否大于0</span><br><span class="line">                 //我们往下看到第126那里的每一项都没有我们的children</span><br><span class="line">              // 但是会执行第64行<span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">v-else</span> <span class="attr">:index</span>=<span class="string">&quot;item.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;menuHandle(item,false)&quot;</span>&gt;</span>这个分支                  // 然后就可以把第66行的item.name给展示出来 如果我们把id修改成Id</span><br><span class="line">               <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">:index</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;item.children &amp;&amp; item.children.length&gt;0&quot;</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;item.icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">el-menu-item</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">v-for</span>=<span class="string">&quot;sub in item.children&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:index</span>=<span class="string">&quot;sub.id&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:key</span>=<span class="string">&quot;sub.id&quot;</span></span></span><br><span class="line"><span class="tag">                   @<span class="attr">click</span>=<span class="string">&quot;menuHandle(sub,false)&quot;</span></span></span><br><span class="line"><span class="tag">                   &gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;sub.icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123;sub.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                   &lt;/el-menu-item</span><br><span class="line">                 &gt;</span><br><span class="line">               <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line">     //64行          <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">v-else</span> <span class="attr">:index</span>=<span class="string">&quot;item.id&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;menuHandle(item,false)&quot;</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;item.icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  //66行               <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>     //把item.name给展示出来</span><br><span class="line">               <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092338082.png" alt="图5"></p><p> 所以我们看到的就是以下的名称</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092342199.png" alt="图6"></p><p>如果我们把name修改成id</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092342644.png" alt="图7"></p><p>重启    刷新</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092342382.png" alt="图8"></p><p>为什么是Id 因为由这个对象数组menuList:[]决定</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092343390.png" alt="图9"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">`new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data() &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            defAct: &#x27;2&#x27;,</span><br><span class="line">            menuActived: &#x27;2&#x27;,</span><br><span class="line">            userInfo: &#123;&#125;,</span><br><span class="line">            menuList: [</span><br><span class="line">              // &#123;</span><br><span class="line">              //   id: &#x27;1&#x27;,</span><br><span class="line">              //   name: &#x27;门店管理&#x27;,</span><br><span class="line">              //   children: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    id: &#x27;2&#x27;,</span><br><span class="line">                    name: &#x27;员工管理&#x27;,</span><br><span class="line">                    url: &#x27;page/member/list.html&#x27;,</span><br><span class="line">                    icon: &#x27;icon-member&#x27;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    id: &#x27;3&#x27;,</span><br><span class="line">                    name: &#x27;分类管理&#x27;,</span><br><span class="line">                    url: &#x27;page/category/list.html&#x27;,</span><br><span class="line">                    icon: &#x27;icon-category&#x27;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    id: &#x27;4&#x27;,</span><br><span class="line">                    name: &#x27;菜品管理&#x27;,</span><br><span class="line">                    url: &#x27;page/food/list.html&#x27;,</span><br><span class="line">                    icon: &#x27;icon-food&#x27;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    id: &#x27;5&#x27;,</span><br><span class="line">                    name: &#x27;套餐管理&#x27;,</span><br><span class="line">                    url: &#x27;page/combo/list.html&#x27;,</span><br><span class="line">                    icon: &#x27;icon-combo&#x27;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    id: &#x27;6&#x27;,</span><br><span class="line">                    name: &#x27;订单明细&#x27;,</span><br><span class="line">                    url: &#x27;page/order/list.html&#x27;,</span><br><span class="line">                    icon: &#x27;icon-order&#x27;</span><br><span class="line">                  &#125;</span><br><span class="line">              //   ],</span><br><span class="line">              // &#125;,</span><br><span class="line">            ],</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092344576.png" alt="图10"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304092355994.png" alt="图11"></p><p>第三 ： 点击菜单时 右边会跟着变</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/backend/index.html</span><br></pre></td></tr></table></figure><p>这些菜单实际上都加了一个@click事件 当我们点击菜单的事情 他会执行menuHandle() 方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-menu-item v-else :index=&quot;item.id&quot; @click=&quot;menuHandle(item,false)&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306042122736.png" alt="图12"></p><p>然后把item,false传过来 接下来我们找到menuHandle() 方法 在196行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuHandle(item, goBackFlag) &#123;</span><br><span class="line">            this.loading = true</span><br><span class="line">            this.menuActived = item.id</span><br><span class="line">            this.iframeUrl = item.url</span><br><span class="line">            this.headTitle = item.name</span><br><span class="line">            this.goBackFlag = goBackFlag</span><br><span class="line">            this.closeLoading()</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure><p>当我们点击菜单的时候 就会执行menuHandle() 方法 这里面最重要的是 this.iframeUrl &#x3D; item.url</p><p> 这里面的url就是以下的url(128行)      也就是点击菜单的url</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuList: [</span><br><span class="line">             // &#123;</span><br><span class="line">             //   id: &#x27;1&#x27;,</span><br><span class="line">             //   name: &#x27;门店管理&#x27;,</span><br><span class="line">             //   children: [</span><br><span class="line">                 &#123;</span><br><span class="line">                   id:&#x27;2&#x27;,</span><br><span class="line">                   name : &#x27;员工管理&#x27;,</span><br><span class="line">                   url: &#x27;page/member/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-member&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;3&#x27;,</span><br><span class="line">                   name: &#x27;分类管理&#x27;,</span><br><span class="line">                   url: &#x27;page/category/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-category&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;4&#x27;,</span><br><span class="line">                   name: &#x27;菜品管理&#x27;,</span><br><span class="line">                   url: &#x27;page/food/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-food&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;5&#x27;,</span><br><span class="line">                   name: &#x27;套餐管理&#x27;,</span><br><span class="line">                   url: &#x27;page/combo/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-combo&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;6&#x27;,</span><br><span class="line">                   name: &#x27;订单明细&#x27;,</span><br><span class="line">                   url: &#x27;page/order/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-order&#x27;</span><br><span class="line">                 &#125;</span><br><span class="line">             //   ],</span><br><span class="line">             // &#125;,</span><br><span class="line">           ],</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304100024943.png" alt="图13"></p><p>这里面是通过iframeUrl的方式来显示新的页面</p><p>iframeUrl在第158行定义的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iframeUrl: &#x27;page/member/list.html&#x27;,</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304100026960.png" alt="image-20230410002610988"></p><p>在什么地方会用到iframeUrl呢？</p><p>在第89行用到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p> 这个是用来展示一个新的页面的 而这个页面从哪里来呢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe         //用来展示一个新的页面</span><br><span class="line">  id=&quot;cIframe&quot;</span><br><span class="line">  class=&quot;c_iframe&quot;</span><br><span class="line">  name=&quot;cIframe&quot;</span><br><span class="line">  :src=&quot;iframeUrl&quot;</span><br><span class="line">  width=&quot;100%&quot;</span><br><span class="line">  height=&quot;auto&quot;</span><br><span class="line">  frameborder=&quot;0&quot;</span><br><span class="line">  v-show=&quot;!loading&quot;</span><br><span class="line">&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306042130131.png" alt="image-20230410002952927"></p><p>这个相当于说在我们的页面上挖了一个坑</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304100031207.png" alt="image-20230410003115103"></p><p>而这个页面从哪里来呢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe</span><br><span class="line">             id=&quot;cIframe&quot;</span><br><span class="line">             class=&quot;c_iframe&quot;</span><br><span class="line">             name=&quot;cIframe&quot;</span><br><span class="line">             :src=&quot;iframeUrl&quot;   这个地方传进什么数据  展示的就是什么数据</span><br><span class="line">             width=&quot;100%&quot;</span><br><span class="line">             height=&quot;auto&quot;</span><br><span class="line">             frameborder=&quot;0&quot;</span><br><span class="line">             v-show=&quot;!loading&quot;</span><br><span class="line">           &gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304100036024.png" alt="image-20230410003635226"></p><p>为什么我们登录之后 展示的是员工管理 而不是分类管理或是其他</p><p>这是因为我们给iframeUrl一个初始值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iframeUrl: &#x27;page/member/list.html&#x27;,</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131532352.png" alt="image-20230410003846840"></p><p>而我们在点击菜单的时候 其实是在切换url</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuHandle(item, goBackFlag) &#123;</span><br><span class="line">      this.loading = true</span><br><span class="line">      this.menuActived = item.id</span><br><span class="line">      this.iframeUrl = item.url</span><br><span class="line">      this.headTitle = item.name</span><br><span class="line">      this.goBackFlag = goBackFlag</span><br><span class="line">      this.closeLoading()</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131532890.png" alt="image-20230410004029272"></p><p>比如说我们现在初始页面给修改成以下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iframeUrl: &#x27;http://www.itcast.c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304100042224.png" alt="image-20230410004214015"></p><p>重启 刷新</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131532565.png" alt="image-20230410004253475"></p><p>所以当我们点击菜单的时候 其实他是在切换url地址</p><p>而这个url地址在数据准备的时候就已经写好了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuList: [</span><br><span class="line">             // &#123;</span><br><span class="line">             //   id: &#x27;1&#x27;,</span><br><span class="line">             //   name: &#x27;门店管理&#x27;,</span><br><span class="line">             //   children: [</span><br><span class="line">                 &#123;</span><br><span class="line">                   id:&#x27;2&#x27;,</span><br><span class="line">                   name : &#x27;员工管理&#x27;,</span><br><span class="line">                   url: &#x27;page/member/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-member&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;3&#x27;,</span><br><span class="line">                   name: &#x27;分类管理&#x27;,</span><br><span class="line">                   url: &#x27;page/category/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-category&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;4&#x27;,</span><br><span class="line">                   name: &#x27;菜品管理&#x27;,</span><br><span class="line">                   url: &#x27;page/food/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-food&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;5&#x27;,</span><br><span class="line">                   name: &#x27;套餐管理&#x27;,</span><br><span class="line">                   url: &#x27;page/combo/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-combo&#x27;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                   id: &#x27;6&#x27;,</span><br><span class="line">                   name: &#x27;订单明细&#x27;,</span><br><span class="line">                   url: &#x27;page/order/list.html&#x27;,</span><br><span class="line">                   icon: &#x27;icon-order&#x27;</span><br><span class="line">                 &#125;</span><br><span class="line">             //   ],</span><br><span class="line">             // &#125;,</span><br><span class="line">           ],</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304100044727.png" alt="image-20230410004454139"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131533573.png" alt="image-20230410004631599"></p><p>不同菜单对应不同的页面      所以当我们点击某一个菜单的时候   他其实是切换到了相应的页面</p><h2 id="1-完善登录功能"><a href="#1-完善登录功能" class="headerlink" title="1. 完善登录功能"></a>1. 完善登录功能</h2><h3 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1 问题分析"></a>1.1 问题分析</h3><p>前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个这个问题， 以及如何处理。</p><p><strong>1). 目前现状</strong></p><p>用户如果不登录，直接访问系统首页面，照样可以正常访问。 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021756260.png" alt="image-20210727232226862"> </p><p><strong>2). 理想效果</strong></p><p>上述这种设计并不合理，我们希望看到的效果应该 是，只有登录成功后才可以访问系统中的页面，如果没有登录, 访问系统中的任何界面都直接跳转到登录页面。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021801653.png" alt="image-20210727232747276" style="zoom:80%;" /> <p><strong>那么，具体应该怎么实现呢？</strong></p><p>可以使用我们之前讲解过的 过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面。</p><h3 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h3><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021801140.png" alt="image-20210727233554707" style="zoom:80%;" /> <p><strong>过滤器具体的处理逻辑如下：</strong></p><p>A. 获取本次请求的URI</p><p>B. 判断本次请求, 是否需要登录, 才可以访问</p><p>C. 如果不需要，则直接放行</p><p>D. 判断登录状态，如果已登录，则直接放行</p><p>E. 如果未登录, 则返回未登录结果</p><p>如果未登录,我们需要给前端返回什么样的结果呢? 这个时候, 我们可以去看看前端是如何处理的 ?</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021802780.png" alt="image-20210728001324901" style="zoom:80%;" /> <h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><p>实现步骤：<br>1、创建自定义过滤器LoginCheckFilter<br>2、在启动类上加入注解@ServletComponentScan<br>3、完善过滤器的处理逻辑</p><p><strong>1). 定义登录校验过滤器</strong></p><p>自定义一个过滤器 LoginCheckFilter 并实现 Filter 接口, 在doFilter方法中完成校验的逻辑。 那么接下来, 我们就根据上述分析的步骤, 来完成具体的功能代码实现: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131533933.png" alt="image-20230410010750497"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131533981.png" alt="image-20230410010944730"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*检查用户是否已经完成登录*/</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;,urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//强转</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求：&#123;&#125;&quot;</span>,request.getRequestURI());</span><br><span class="line">          <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131533111.png" alt="image-20230410012037639"></p><p>重启</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131533957.png" alt="image-20230410012156708"></p><p> 刷新</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131533781.png" alt="image-20230410012317239"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131533156.png" alt="image-20230410012420126"></p><p>代码解释：</p><p>解释一  </p><p>这段代码是一个 Java Web 应用程序中的过滤器(Filter)。 过滤器在请求到达目标 Servlet&#x2F;JSP 前预处理请求或响应，以便在处理真正的请求之前完成一些操作。</p><p>这个过滤器的作用是检查用户是否已经登录，通过检查URL是否以登录用户的认证信息，如session ID、token等。如果用户没有登录，过滤器会将用户重定向到登录页面，如果用户已经登录，则请求将被放行到下一个处理程序。</p><p>具体来说，这个过滤器实现了Filter过滤器接口中的doFilter方法。该方法接收ServletRequest和ServletResponse类型的参数，并通过类型转换将其转换为HttpServletRequest和HttpServletResponse类型。然后，它会打印一条日志以表明请求已经被拦截，并将请求和响应对象传递给过滤器链(FilterChain)。最后，过滤器链将请求和响应对象传递给下一个处理程序。</p><p>总之，这个过滤器是一个很有用的工具，它能够在用户请求到达目标 Servlet&#x2F;JSP 之前进行预处理，确保用户已经完成登录并且已经得到授权，从而保护Web应用程序的安全性。</p><p>解释二</p><p>当我们使用一个 Java Web 应用程序时，需要确保用户已经完成登录，并且已经得到授权，否则他们将无法访问需要特殊权限的页面。这就是这段代码的作用。</p><p>这段代码实现了一个过滤器(Filter)，它会在请求到达目标 Servlet&#x2F;JSP 之前进行预处理。它会检查用户是否已经完成登录，如果没有完成登录，它会将用户重定向到登录页面，以便用户能够完成登录，然后再次尝试访问需要特殊权限的页面。</p><p>这个过滤器检查请求的 URL，如果 URL 包含了用户的认证信息，比如 session ID 或者 token，那么它就认为用户已经完成了登录。如果用户没有完成登录，它就会重定向到登录页面，让用户完成登录。</p><p>这个过滤器的实现比较简单，它实现了 Filter 接口中的 doFilter 方法。当有请求到达时，它会将请求转换为 HttpServletRequest 对象，并检查是否已经完成登录。如果已经完成登录，它就会将请求和响应对象传递给下一个处理程序。如果没有完成登录，它就会将用户重定向到登录页面。</p><p>总之，这个过滤器是一个很有用的工具，它能够确保用户已经完成登录，并且已经得到授权，从而保护 Web 应用程序的安全性。</p><p>解释三</p><p>这段代码是一个 Java Web 应用程序中的过滤器(Filter)，它的作用是在用户访问任何网页之前检查用户是否已经完成登录操作。</p><p>在代码中，使用了 @WebFilter 注解，指定了过滤器的名称为 “loginCheckFilter”，并将其应用于所有的 URL，即 “&#x2F;*”。</p><p>在 doFilter() 方法中，将传入的 ServletRequest 和 ServletResponse 对象转换为 HttpServletRequest 和 HttpServletResponse 对象，并记录下当前请求的 URL 地址，最后将请求和响应对象交给 FilterChain 继续处理。</p><p>Filter 的作用类似于一个拦截器，当用户访问任何网页时，该过滤器会首先拦截请求，检查用户是否已经登录，如果用户已经完成了登录操作，那么该过滤器会放行请求，让用户继续访问该网页；如果用户还没有登录，那么该过滤器会重定向到登录页面，要求用户先完成登录操作，然后才能继续访问网页。</p><p>总的来说，这段代码的作用是保护 Web 应用程序中的敏感资源，确保只有已经完成登录操作的用户才能访问这些资源，提高了系统的安全性。</p><p>理解 ：在这个代码中为什么要进行强转</p><p>在这个代码中，我们将 ServletRequest 和 ServletResponse 对象转换为了 HttpServletRequest 和 HttpServletResponse 对象，这是因为 Filter 接口的 doFilter 方法接收的是 ServletRequest 和 ServletResponse 对象，而我们需要使用 HttpServletRequest 和 HttpServletResponse 对象来获取 HTTP 请求和响应的相关信息。</p><p>ServletRequest 和 ServletResponse 是 Java Servlet 规范中定义的接口，它们提供了一种通用的处理 HTTP 请求和响应的方式。但是它们缺少 HttpServletRequest 和 HttpServletResponse 对象的一些方法，例如 getParameter 和 getAttribute 等方法，这些方法是在 HttpServletRequest 和 HttpServletResponse 接口中定义的。</p><p>因此，为了能够使用这些特定的方法，我们需要将 ServletRequest 和 ServletResponse 对象强制转换为 HttpServletRequest 和 HttpServletResponse 对象，这样就可以使用这些特定的方法了。但是，在进行强制转换之前，我们需要确保请求确实是 HTTP 请求，否则强制转换可能会导致类型转换异常。</p><p>两个注解：@WebFilter 和 @Slf4j的解释</p><p>@WebFilter 注解用于标记一个类为过滤器(Filter)，它可以指定过滤器的名称(filterName)和 URL 模式(urlPatterns)。在这个例子中，我们将这个过滤器的名称设置为 “loginCheckFilter”，并指定了 URL 模式为 “&#x2F;*”，也就是拦截所有的请求。</p><p>@Slf4j 注解是 Lombok 框架中提供的注解之一，它用于简化日志记录的代码。它会在编译时自动生成一个名为 “log” 的日志记录器，我们可以使用它来记录日志。在这个例子中，我们使用 log.info 方法来记录日志信息。</p><p>这些注解都是用来帮助我们更方便地编写代码和实现功能的。@WebFilter 注解让我们更容易地定义一个过滤器，并指定需要拦截的请求。@Slf4j 注解则帮助我们更方便地实现日志记录功能。</p><p>每行代码的详细解释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)</span><br></pre></td></tr></table></figure><p>这行代码是使用 @WebFilter 注解声明一个过滤器，并指定了过滤器的名称为 “loginCheckFilter”，并将其应用于所有的 URL，即 “&#x2F;*”。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br></pre></td></tr></table></figure><p>这行代码使用了 Lombok 提供的 @Slf4j 注解，自动生成了一个名为 log 的日志对象，可以用它来输出日志信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoginCheckFilter implements Filter &#123;&#125;</span><br></pre></td></tr></table></figure><p>这行代码是 doFilter() 方法的声明，该方法是 Filter 接口中的一个方法，用于拦截用户请求，并进行处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br></pre></td></tr></table></figure><p>这行代码将传入的 ServletRequest 和 ServletResponse 对象转换为 HttpServletRequest 和 HttpServletResponse 对象，以便后续对请求和响应进行处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info(&quot;拦截到请求：&#123;&#125;&quot;, request.getRequestURI());</span><br></pre></td></tr></table></figure><p>这行代码使用之前定义的 log 对象输出一条日志信息，记录下当前请求的 URL 地址，方便后续的调试和问题定位。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filterChain.doFilter(request, response);</span><br></pre></td></tr></table></figure><p>这行代码调用 FilterChain 对象的 doFilter() 方法，将处理过的请求和响应对象传递给下一个过滤器或 Servlet 进行处理，如果没有其他过滤器，则直接交给 Servlet 处理。这样，过滤器的链条就得以形成，确保每个请求都会被多个过滤器进行处理。</p><p>复习过滤器filter</p><p>解释一</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP Request --&gt; Filter 1 --&gt; Filter 2 --&gt; ... --&gt; Filter n --&gt; Servlet --&gt; HTTP Response</span><br></pre></td></tr></table></figure><p>在Java Web应用程序中，过滤器(Filter)是一个用于处理HTTP请求和响应的组件。它们被用来拦截请求并根据需要修改请求参数、头信息或请求体，以及响应信息。过滤器可以在 Servlet 执行之前或之后进行处理，也可以在 Servlet 进行处理时同时进行处理。</p><p>当一个HTTP请求到达Servlet容器时，它会首先被任何注册的过滤器拦截。过滤器根据需要可以更改请求，或者将请求传递给下一个过滤器。一旦所有过滤器都已处理请求，最终的目标Servlet会被调用。Servlet处理请求后生成响应，该响应会通过相同的过滤器链进行处理，并且在每个过滤器处可以修改响应。</p><p>这个过滤器链的顺序是在web.xml文件中定义的，并且过滤器可以动态添加或删除。这使得开发人员可以根据需要自定义请求处理流程，从而实现更加灵活和复杂的应用程序功能。</p><p>所属包: com.itheima.reggie.filter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.common.R;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查用户是否已经完成登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;,urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="comment">//路径匹配器，支持通配符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">PATH_MATCHER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取本次请求的URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();<span class="comment">// /backend/index.html</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求：&#123;&#125;&quot;</span>,requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义不需要处理的请求路径</span></span><br><span class="line">        String[] urls = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                <span class="string">&quot;/employee/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/employee/logout&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/backend/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/front/**&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、判断本次请求是否需要处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">check</span> <span class="operator">=</span> check(urls, requestURI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、如果不需要处理，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(check)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;本次请求&#123;&#125;不需要处理&quot;</span>,requestURI);</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、判断登录状态，如果已登录，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        <span class="comment">//5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据</span></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(R.error(<span class="string">&quot;NOTLOGIN&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路径匹配，检查本次请求是否需要放行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestURI</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String[] urls,String requestURI)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> PATH_MATCHER.match(url, requestURI);</span><br><span class="line">            <span class="keyword">if</span>(match)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red'><b>AntPathMatcher 拓展:</b></font></p><p><strong>介绍:</strong> Spring中提供的路径匹配器 ;</p><p><strong>通配符规则:</strong> </p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>*</td><td>匹配0个或多个字符</td></tr><tr><td>**</td><td>匹配0个或多个目录&#x2F;字符</td></tr></tbody></table></blockquote><p><strong>2). 开启组件扫描</strong></p><p>需要在引导类上, 加上Servlet组件扫描的注解, 来扫描过滤器配置的@WebFilter注解， 扫描上之后， 过滤器在运行时就生效了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReggieApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ReggieApplication.class,args);</span><br><span class="line">        log.info(<span class="string">&quot;项目启动成功...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red'><b>@ServletComponentScan 的作用: </b></font></p><p>​在SpringBoot项目中, 在引导类&#x2F;配置类上加了该注解后, 会自动扫描项目中(当前包及其子包下)的@WebServlet , @WebFilter , @WebListener 注解, 自动注册Servlet的相关组件 ;</p></blockquote><h3 id="1-4-功能测试"><a href="#1-4-功能测试" class="headerlink" title="1.4 功能测试"></a>1.4 功能测试</h3><p>当我们直接输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/backend/login.html</span><br></pre></td></tr></table></figure><p>时 </p><p>会跳转到登录界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/backend/page/login/login.html</span><br></pre></td></tr></table></figure><p>视频的前端JS和我们实际的前端不同</p><p>代码编写完毕之后，我们需要将工程重启一下，然后在浏览器地址栏直接输入系统管理后台首页，然后看看是否可以跳转到登录页面即可。我们也可以通过debug的形式来跟踪一下代码执行的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021802532.png" alt="image-20210728000838992"> </p><p>对于前端的代码, 也可以进行debug调试。</p><p>F12打开浏览器的调试工具, 找到我们前面提到的request.js, 在request.js的响应拦截器位置打上断点。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021802020.png" alt="image-20210728001929657"> </p><h2 id="2-新增员工"><a href="#2-新增员工" class="headerlink" title="2. 新增员工"></a>2. 新增员工</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击[添加员工]按钮跳转到新增页面，如下：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021802444.png" alt="image-20210728002442334" style="zoom:80%;" /> <p>当填写完表单信息, 点击”保存”按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据, 然后将数据保存至数据库中。</p><h3 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2 数据模型"></a>2.2 数据模型</h3><p>新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。employee表中的status字段已经设置了默认值1，表示状态正常。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021802948.png" alt="image-20210728004144521" style="zoom:80%;" /> <p>需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必须是唯一的。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021802115.png" alt="image-20210728004250254" style="zoom:80%;" /> <h3 id="2-3-程序执行流程"><a href="#2-3-程序执行流程" class="headerlink" title="2.3 程序执行流程"></a>2.3 程序执行流程</h3><p>在开发代码之前，我们需要结合着前端页面发起的请求， 梳理一下整个程序的执行过程：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021802403.png" alt="image-20210728005638224" style="zoom:80%;" /> <p>A. 点击”保存”按钮, 页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务端, 请求方式POST, 请求路径 &#x2F;employee</p><p>B. 服务端Controller接收页面提交的数据并调用Service将数据进行保存</p><p>C. Service调用Mapper操作数据库，保存数据</p><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><p>在EmployeeController中增加save方法, 用于保存用户员工信息。</p><p>A. 在新增员工时， 按钮页面原型中的需求描述， 需要给员工设置初始默认密码 123456， 并对密码进行MD5加密。</p><p>B. 在组装员工信息时, 还需要封装创建时间、修改时间，创建人、修改人信息(从session中获取当前登录用户)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*新增员工*/</span><br><span class="line">     @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Employee employee)&#123;</span><br><span class="line">         log.info(&quot;新增员工，员工信息：&#123;&#125;&quot;,employee.toString());</span><br><span class="line">        return  null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>保证前端页面发送的请求  能够请求到save方法  并且提交的参数能够提交到 employee对象上  </p><p>@RequestBody：用来获取客户端（前端 ）提交上来的JSON字符串    并将ISON字符串转换成javabeen实体类</p><p>@RespomseBody：javabeen实体类转换为JSON</p><p> Employee：使用 Employee对象接收前端传递的请求参数（JSON格式）</p><p>R：返回值</p><p>总体解释1</p><p>这段代码是一个使用Spring框架的控制器方法，用于处理HTTP POST请求，并将请求主体中的数据映射为Employee对象来新增员工。</p><p>让我们逐行解释代码：</p><ul><li><code>@PostMapping</code>：这是一个注解，用于将该方法映射到HTTP的POST请求方法。它表示这个方法将处理来自客户端的POST请求。</li><li><code>public R&lt;String&gt; save(@RequestBody Employee employee)</code>：这是方法的声明。它接收一个<code>Employee</code>类型的参数，该参数将从请求主体中提取。<code>@RequestBody</code>注解告诉Spring框架从请求主体中获取JSON数据，并将其转换为<code>Employee</code>对象。</li><li><code>log.info(&quot;新增员工，员工信息：&#123;&#125;&quot;, employee.toString())</code>：这行代码使用日志记录了新增员工的操作。<code>log.info()</code>方法用于打印信息，并使用占位符<code>&#123;&#125;</code>将<code>employee.toString()</code>的返回值插入到日志信息中。这样可以在控制台或日志文件中查看新增员工的详细信息。</li><li><code>return null</code>：这个方法返回一个<code>null</code>值。你可以根据实际需求来返回适当的响应，比如返回一个成功的消息或新员工的ID。</li></ul><p>所以，当你发送一个HTTP POST请求到这个控制器的URL时，请求主体中的数据将被映射为<code>Employee</code>对象，并在日志中打印出员工的信息。然后，方法将返回一个<code>null</code>值作为响应。你可以根据需求修改方法体，执行适当的业务逻辑或返回相应的结果。</p><p>总体解释2</p><p>这段代码是一个基于SpringBoot框架搭建的员工管理系统的新增员工功能的接口。</p><p>其中，@PostMapping注解表示该接口只接受POST请求。@RequestBody注解表示将请求体中的JSON格式数据绑定到Employee对象上。Employee对象代表了一个员工信息，包括员工ID、姓名、性别、职位等属性。当接收到客户端传来的POST请求时，SpringBoot会自动将请求体中的JSON格式数据转换成对应的Employee对象，并赋值给方法参数employee。</p><p>在方法内部，使用log.info打印出新增的员工信息。最后，接口返回的类型为R<String>，代表了一个自定义的响应类，其中R表示响应结果，而String则表示响应消息内容。在这个示例中，接口返回了null。需要根据实际业务需求将null替换成相应的响应结果。</p><p>总之，这段代码的主要作用是接收客户端提交的员工信息并写入数据库，同时记录日志并返回响应结果。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131534677.png" alt="image-20230605105616707"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306051054661.png" alt="image-20230605105432572"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131534173.png" alt="image-20230605105816824"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131534469.png" alt="image-20230605105845333"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(HttpServletRequest request,<span class="meta">@RequestBody</span> Employee employee)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;新增员工，员工信息：&#123;&#125;&quot;</span>,employee.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置初始密码123456，需要进行md5加密处理</span></span><br><span class="line">    employee.setPassword(DigestUtils.md5DigestAsHex(<span class="string">&quot;123456&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">    employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">    employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前登录用户的id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long) request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line"></span><br><span class="line">    employee.setCreateUser(empId);</span><br><span class="line">    employee.setUpdateUser(empId);</span><br><span class="line"></span><br><span class="line">    employeeService.save(employee);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;新增员工成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>这段代码是一个使用Spring框架的控制器方法，用于处理HTTP POST请求并新增员工。</p><p>让我们逐行解释代码：</p><ul><li><code>@PostMapping</code>：这是一个注解，将该方法映射到HTTP的POST请求方法。</li><li><code>public R&lt;String&gt; save(HttpServletRequest request, @RequestBody Employee employee)</code>：这是方法的声明。它接收两个参数：<code>HttpServletRequest request</code>和<code>Employee employee</code>。<code>@RequestBody</code>注解告诉Spring框架从请求主体中获取数据，并将其转换为<code>Employee</code>对象。<code>HttpServletRequest</code>参数用于获取当前请求的相关信息。</li><li><code>log.info(&quot;新增员工，员工信息：&#123;&#125;&quot;, employee.toString())</code>：这行代码使用日志记录了新增员工的操作。员工信息通过<code>employee.toString()</code>转换为字符串，并插入到日志信息中。</li><li><code>employee.setPassword(DigestUtils.md5DigestAsHex(&quot;123456&quot;.getBytes()))</code>：这行代码设置员工的初始密码为”123456”，并使用MD5加密处理。<code>DigestUtils.md5DigestAsHex()</code>方法将字节数组转换为MD5散列字符串。</li><li><code>employee.setCreateTime(LocalDateTime.now())</code>：这行代码将当前时间设置为员工的创建时间。</li><li><code>employee.setUpdateTime(LocalDateTime.now())</code>：这行代码将当前时间设置为员工的更新时间。</li><li><code>Long empId = (Long) request.getSession().getAttribute(&quot;employee&quot;)</code>：这行代码从当前会话中获取名为”employee”的属性，它表示当前登录用户的ID。</li><li><code>employee.setCreateUser(empId)</code>和<code>employee.setUpdateUser(empId)</code>：这两行代码将当前登录用户的ID设置为员工的创建用户和更新用户。</li><li><code>employeeService.save(employee)</code>：这行代码调用<code>employeeService</code>服务的<code>save()</code>方法来保存新增的员工信息。</li><li><code>return R.success(&quot;新增员工成功&quot;)</code>：这行代码返回一个成功的响应，包含一条”新增员工成功”的消息。</li></ul><p>总结起来，这段代码处理了一个HTTP POST请求，将请求主体中的数据映射为<code>Employee</code>对象，并对该对象进行一系列处理，如设置初始密码、设置创建时间和更新时间、设置创建用户和更新用户等。最后，调用<code>employeeService</code>的<code>save()</code>方法来保存员工信息，并返回成功的响应消息。</p><p>代码解释2</p><p>这段代码是一个基于SpringBoot框架搭建的员工管理系统的新增员工功能的接口，相对于之前的代码增加了一些业务逻辑的处理。</p><p>其中，@PostMapping注解表示该接口只接受POST请求。@RequestBody注解表示将请求体中的JSON格式数据绑定到Employee对象上。HttpServletRequest request代表HTTP请求信息。Employee对象代表了一个员工信息，包括员工ID、姓名、性别、职位等属性。</p><p>在方法内部，使用log.info打印出新增的员工信息。接下来对员工对象进行了一些预处理操作：</p><ol><li>设置初始密码123456，并通过MD5加密后存入employee对象中；</li><li>获取当前时间，并分别设置为创建时间和更新时间；</li><li>从session中获取当前登录用户的id，并将其设置为创建用户和更新用户；</li></ol><p>最后，调用employeeService.save()方法将员工信息写入数据库中，并在接口返回时返回一个自定义的响应类R，其中success表示成功的状态，”新增员工成功”表示响应消息的内容。</p><p>总之，这段代码的主要作用是接收客户端提交的员工信息并写入数据库，并进行了一些预处理操作。同时记录日志并返回响应结果。</p><p>测试新增员工</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131535557.png" alt="image-20230605112657055"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131535317.png" alt="image-20230605112841758"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131535845.png" alt="image-20230605112910313"></p><p>如果在录入一个zhagsan   就会出现问题</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131535685.png" alt="image-20230605113633322"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131535269.png" alt="image-20230605113648946"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131535422.png" alt="image-20230605113727456"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306052104630.png" alt="image-20230605210446510"></p><h3 id="2-5-功能测试"><a href="#2-5-功能测试" class="headerlink" title="2.5 功能测试"></a>2.5 功能测试</h3><p>代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 点击 “员工管理” 页面中的 “添加员工” 按钮, 输入员工基本信息, 然后点击 “保存” 进行数据保存, 保存完毕后, 检查数据库中是否录入员工数据。</p><p>当我们在测试中，添加用户时， 输入了一个已存在的用户名时，前端界面出现错误提示信息： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021803107.png" alt="image-20210728010841569" style="zoom:80%;" /> <p>而此时，服务端已经报错了， 报错信息如下： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021803771.png" alt="image-20210728010938086"> </p><p>出现上述的错误， 主要就是因为在 employee 表结构中，我们针对于username字段，建立了唯一索引，添加重复的username数据时，违背该约束，就会报错。但是此时前端提示的信息并不具体，用户并不知道是因为什么原因造成的该异常，我们需要给用户提示详细的错误信息 。</p><h3 id="2-6-全局异常处理"><a href="#2-6-全局异常处理" class="headerlink" title="2.6 全局异常处理"></a>2.6 全局异常处理</h3><h4 id="2-6-1-思路分析"><a href="#2-6-1-思路分析" class="headerlink" title="2.6.1 思路分析"></a>2.6.1 思路分析</h4><p>要想解决上述测试中存在的问题，我们需要对程序中可能出现的异常进行捕获，通常有两种处理方式：</p><p><strong>A. 在Controller方法中加入 try…catch 进行异常捕获</strong></p><p>形式如下： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021803763.png" alt="image-20210729094125294" style="zoom:80%;" /> <p>如果采用这种方式，虽然可以解决，但是存在弊端，需要我们在保存其他业务数据时，也需要在Controller方法中加上try…catch进行处理，代码冗余，不通用。</p><p><strong>B. 使用异常处理器进行全局异常捕获</strong></p><p>采用这种方式来实现，我们只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有异常。</p><h4 id="2-6-2-全局异常处理器"><a href="#2-6-2-全局异常处理器" class="headerlink" title="2.6.2 全局异常处理器"></a>2.6.2 全局异常处理器</h4><p>在项目中自定义一个全局异常处理器，在异常处理器上加上注解 @ControllerAdvice,可以通过属性annotations指定拦截哪一类的Controller方法。 并在异常处理器的方法上加上注解 @ExceptionHandler 来指定拦截的是那一类型的异常。</p><blockquote><p>异常处理方法逻辑: </p><ul><li>指定捕获的异常类型为 SQLIntegrityConstraintViolationException</li><li>解析异常的提示信息, 获取出是那个值违背了唯一约束 </li><li>组装错误信息并返回</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021803259.png" alt="image-20210729100232642" style="zoom:80%;" /> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 全局异常处理</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span><br><span class="line">@ResponseBody</span><br><span class="line">@Slf4j</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异常处理方法</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><br><span class="line">    public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line">         return R.error(&quot;失败了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1：</p><p>以上代码是一个用于全局异常处理的类。该类使用了Spring的@ControllerAdvice注解来标识它是一个全局异常处理器。通过该注解，它会拦截被@RestController和@Controller注解标注的类中发生的异常。</p><p>具体解释如下：</p><ol><li><code>@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</code>：这是一个类级别的注解，用于指定该全局异常处理类要拦截的Controller类的注解类型。在这里，它指定要拦截的类必须是标注了@RestController或@Controller注解的类。</li><li><code>@ResponseBody</code>：这是一个方法级别的注解，表示该方法的返回值将直接作为响应的内容返回给客户端，而不是被视图解析器解析为视图。在这里，它确保异常处理方法的返回值将被转换为响应的JSON格式。</li><li><code>@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</code>：这是一个方法级别的注解，用于指定该方法要处理的特定异常类型。在这里，它指定该方法要处理的异常是SQLIntegrityConstraintViolationException。</li><li><code>public R&lt;String&gt; exceptionHandler(SQLIntegrityConstraintViolationException ex)</code>：这是异常处理方法，它接收一个SQLIntegrityConstraintViolationException类型的参数，表示捕获到的异常对象。方法的返回类型为R<String>，R是一个自定义的通用响应对象，用于包装响应数据。</li><li><code>log.error(ex.getMessage())</code>：这行代码使用Slf4j提供的日志记录功能，将异常的错误消息记录到日志中。</li><li><code>return R.error(&quot;失败了&quot;)</code>：这行代码返回一个R对象，表示处理异常后的响应结果。使用R.error静态方法创建一个错误类型的R对象，并设置错误消息为”失败了”。</li></ol><p>综上所述，以上代码定义了一个全局异常处理类，用于捕获和处理Controller层中发生的SQLIntegrityConstraintViolationException异常，并将错误信息记录到日志中，最后返回一个错误类型的响应结果。</p><p>代码解释2</p><p>这段代码是一个基于SpringBoot框架的全局异常处理类，用于捕获并处理SQL异常。</p><p>@ControllerAdvice注解表示该类用于全局异常处理。通过annotations参数指定了需要拦截的控制器注解类型为@RestController和@Controller。@ResponseBody注解表示返回的是JSON格式的数据。@Slf4j注解表示使用log记录日志。</p><p>@ExceptionHandler注解表示该方法用于捕获SQLIntegrityConstraintViolationException类型的异常。当系统出现SQLIntegrityConstraintViolationException类型的异常时，会调用该方法进行异常处理。在方法内部，使用log.error打印异常信息，并返回一个自定义的响应类R，其中error表示失败的状态，”失败了”表示响应消息的内容。</p><p>总之，这段代码的主要作用是实现对SQLIntegrityConstraintViolationException类型异常的统一捕获和处理。当系统出现该类型的异常时，会执行该方法进行异常处理，并记录日志并返回响应结果。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131536381.png" alt="image-20230605205207722"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131536773.png" alt="image-20230605213011631"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131536460.png" alt="image-20230605213021868"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131536813.png" alt="image-20230605213228144"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131536013.png" alt="image-20230605213259694"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131536837.png" alt="image-20230605213319536"></p><p>所属包: com.itheima.reggie.common</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLIntegrityConstraintViolationException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">exceptionHandler</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line">        <span class="keyword">if</span>(ex.getMessage().contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">            String[] split = ex.getMessage().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> split[<span class="number">2</span>] + <span class="string">&quot;已存在&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> R.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="string">&quot;未知错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red'><b>注解说明:</b></font></p><p>​上述的全局异常处理器上使用了的两个注解 @ControllerAdvice , @ResponseBody , 他们的作用分别为: </p><p>​@ControllerAdvice : 指定拦截那些类型的控制器;</p><p>​@ResponseBody: 将方法的返回值 R 对象转换为json格式的数据, 响应给页面;</p><p>​</p><p>​上述使用的两个注解, 也可以合并成为一个注解 @RestControllerAdvice </p><p>​<img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021803411.png" alt="image-20210729100052940" style="zoom:80%;" /> </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131537148.png" alt="image-20230605214040718"></p><p>代码解释1</p><p>以上代码是一个 Java 类，它包含了一个名为<code>GlobalExceptionHandler</code>的异常处理类。该类包含了一个名为<code>exceptionHandler</code>的方法，该方法接收一个<code>SQLIntegrityConstraintViolationException</code>类型的异常作为参数。</p><p>在<code>exceptionHandler</code>方法中，首先使用<code>log.error(ex.getMessage())</code>方法将异常消息保存到日志中。然后，使用<code>ex.getMessage()</code>方法获取异常消息，并将其分成多个字符串，以便进一步处理。</p><p>如果异常消息中包含字符串<code>&quot;Duplicate entry&quot;</code>,则方法将使用<code>split()</code>方法将字符串分成多个字符串，然后从中获取第 3 个字符串，该字符串通常是描述存在重复项的详细信息。最后，方法将使用<code>error()</code>方法将详细信息转换为<code>R&lt;String&gt;</code>类型的响应，并返回该响应。如果异常消息中包含其他字符串，则方法将返回<code>R.error(&quot;未知错误&quot;)</code>类型的响应。</p><p>需要注意的是，该代码中的<code>@ExceptionHandler</code>注解用于指定处理的异常类型，并返回<code>R&lt;String&gt;</code>类型的数据。该注解需要与<code>@RestController</code>注解一起使用，以便将异常处理与 RESTful API 集成。</p><p>在详细解释</p><p>以上代码中的<code>@ExceptionHandler</code>注解是一个异常处理注解，它用于指定处理哪种类型的异常。在此示例中，<code>@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</code>指定了该方法处理<code>SQLIntegrityConstraintViolationException</code>类型的异常。</p><p><code>@ExceptionHandler</code>注解有一个参数，即要处理的异常类型。在此示例中，<code>SQLIntegrityConstraintViolationException</code>是我们要处理的异常类型。当程序遇到这种异常时，它将被传递给<code>exceptionHandler</code>方法进行处理。</p><p><code>exceptionHandler</code>方法是一个返回值方法，它接收一个<code>SQLIntegrityConstraintViolationException</code>类型的异常作为参数。在方法内部，我们首先使用<code>log.error(ex.getMessage())</code>方法将异常消息保存到日志中。然后，我们使用<code>ex.getMessage()</code>方法获取异常消息，并将其分成多个字符串。</p><p>如果异常消息中包含字符串<code>&quot;Duplicate entry&quot;</code>,则方法将使用<code>split()</code>方法将字符串分成多个字符串，然后从中获取第 3 个字符串，该字符串通常是描述存在重复项的详细信息。在此示例中，我们将第 3 个字符串作为参数传递给<code>error()</code>方法，以将详细信息转换为<code>R&lt;String&gt;</code>类型的响应。如果异常消息中包含其他字符串，则方法将返回<code>R.error(&quot;未知错误&quot;)</code>类型的响应。</p><p>最后，我们需要将异常处理与 RESTful API 集成。在此示例中，<code>@RestController</code>注解指定了该控制器处理 RESTful API 请求。因此，当程序遇到异常时，它将被传递给 RESTful API 控制器中的异常处理函数。在这种情况下，该函数使用<code>@ExceptionHandler</code>注解指定要处理的异常类型，并返回一个错误响应。</p><p>代码解释2</p><p>以上代码是一个全局异常处理器，用于捕获在@RestController 或 @Controller标注的控制器中抛出的异常，并返回统一格式的错误信息。</p><p>其中，@ControllerAdvice 注解表示该类是一个全局异常处理器，@ResponseBody 注解表示返回结果是一个 JSON 格式的数据，@Slf4j 则是一个Slf4j日志工具，常用于输出日志信息。</p><p>在代码实现方面，@ExceptionHandler 注解用于指定处理的异常类型，并返回 R<String> 类型的数据。</p><p>这段代码的处理流程是：当捕获到 SQLIntegrityConstraintViolationException 异常时，如果异常信息中包含”Duplicate entry”字样，则认为是数据重复的异常，从异常信息中提取出具体的数据，然后返回一个包含该信息的 R 类型的数据；否则，返回一个”未知错误”的 R 类型的数据。 </p><p>代码解释3</p><p>以上代码是一个全局异常处理类，使用了Spring框架提供的@ControllerAdvice注解。该类用于捕获和处理控制器中抛出的异常。</p><p>代码中的注解<code>@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</code>表示该类只会处理带有<code>@RestController</code>或<code>@Controller</code>注解的控制器中发生的异常。</p><p>注解<code>@ResponseBody</code>表示该类的方法返回的结果将直接作为响应体返回，而不是被视图解析器解析为视图。就是将javabeen转换成JSON返回</p><p><code>@Slf4j</code>是一个Lombok注解，用于自动生成日志记录器。</p><p><code>@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</code>表示该方法将处理<code>SQLIntegrityConstraintViolationException</code>类型的异常。在方法中，它首先记录了异常的错误消息，然后检查错误消息中是否包含”Duplicate entry”，如果包含，则根据错误消息中的内容生成相应的错误信息并返回一个<code>R</code>对象（可能是自定义的响应对象）。</p><p>如果错误消息不包含”Duplicate entry”，则返回一个包含默认错误信息的<code>R</code>对象。</p><p>值得注意的是，代码中的<code>返回 R.error(msg);</code>这行代码是伪代码，实际上应该返回一个<code>R</code>对象。在这个例子中，<code>R.error(msg)</code>是一个伪代码，意思是返回一个带有错误信息<code>msg</code>的<code>R</code>对象。具体的<code>R</code>对象实现和使用方式需要根据实际情况进行定义和处理。</p><p>总结：以上代码是一个全局异常处理类，用于捕获和处理控制器中抛出的<code>SQLIntegrityConstraintViolationException</code>异常。根据异常的错误消息，它生成相应的错误信息并返回一个<code>R</code>对象（伪代码），用于表示异常处理结果。</p><p>在详细一点解释</p><p>当在使用Spring框架进行开发时，我们经常需要处理控制器中可能抛出的异常，以提供更好的错误处理和友好的错误响应。全局异常处理类就是用于这个目的。</p><p>首先，我们可以使用<code>@ControllerAdvice</code>注解来标识一个类作为全局异常处理类。在本例中，该注解使用了<code>annotations</code>属性，指定了需要处理的控制器注解类型为<code>@RestController</code>和<code>@Controller</code>。</p><p>接下来，使用<code>@ExceptionHandler</code>注解来标识一个方法作为异常处理方法。在本例中，该方法处理的是<code>SQLIntegrityConstraintViolationException</code>类型的异常。</p><p>在异常处理方法中，我们首先使用<code>@Slf4j</code>注解生成一个日志记录器，以便记录异常的错误消息。</p><p>接下来，我们检查异常的错误消息是否包含”Duplicate entry”，即是否是因为违反了唯一性约束（Duplicate entry）而抛出的异常。如果是，我们从错误消息中提取出相应的信息，并根据该信息生成一个新的错误消息。</p><p>在这个例子中，我们使用了<code>ex.getMessage().contains(&quot;Duplicate entry&quot;)</code>来检查错误消息是否包含”Duplicate entry”，然后使用<code>ex.getMessage().split(&quot; &quot;)</code>来将错误消息按空格分割，获取了相关信息。</p><p>生成新的错误消息后，我们使用<code>R.error(msg)</code>来创建一个响应对象，其中<code>msg</code>是错误消息。这里的<code>R.error()</code>是一个伪代码，表示返回一个带有错误信息的响应对象。</p><p>如果错误消息不包含”Duplicate entry”，则说明是其他未知错误，我们返回一个默认的错误响应对象，其中包含一个表示未知错误的默认错误信息。</p><p>需要注意的是，代码中的<code>返回 R.error(msg);</code>这行代码是伪代码，实际上应该返回一个<code>R</code>对象，具体的返回方式需要根据实际情况进行定义和处理。</p><p>通过使用这个全局异常处理类，我们可以集中处理控制器中抛出的指定类型的异常，并提供自定义的错误响应。这样可以简化代码逻辑，并提供统一的异常处理机制，提升系统的健壮性和用户体验。</p><p>当我们新增一个已经存在的值的时候</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131537709.png" alt="image-20230605220243398"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131537244.png" alt="image-20230605220305991"></p><p>当我们新增不存在的值的时候</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131537429.png" alt="image-20230605220456101"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131537941.png" alt="image-20230605220507912"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131537973.png" alt="image-20230605220526780"></p><h4 id="2-6-3-测试"><a href="#2-6-3-测试" class="headerlink" title="2.6.3 测试"></a>2.6.3 测试</h4><p>全局异常处理器编写完毕之后，我们需要将项目重启, 完毕之后直接访问管理系统首页, 点击 “员工管理” 页面中的 “添加员工” 按钮。当我们在测试中，添加用户时， 输入了一个已存在的用户名时，前端界面出现如下错误提示信息：</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131537615.png" alt="image-20210729102220135" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131538397.png" alt="image-20230605220945408"></p><h2 id="3-员工分页查询"><a href="#3-员工分页查询" class="headerlink" title="3. 员工分页查询"></a>3. 员工分页查询</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。而在我们的分页查询页面中, 除了分页条件以外，还有一个查询条件     比如查询”员工姓名”。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021803131.png" alt="image-20210729134904625"> </p><ul><li><p>请求参数</p><ul><li><p>搜索条件： 员工姓名(模糊查询)</p></li><li><p>分页条件： 每页展示条数 ， 页码</p></li></ul></li><li><p>响应数据</p><ul><li>总记录数</li></ul></li><li><p>结果列表</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131538518.png" alt="image-20230605221457990"></p><p>1). 页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端</p><p>F12   刷新页面</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131538525.png" alt="image-20230605221857857"></p><p><img src="C:\Users\zyz\AppData\Roaming\Typora\typora-user-images\image-20230605221909418.png" alt="image-20230605221909418"></p><p>page&#x3D;1&amp;pageSize&#x3D;10   查第一页  一共查10条数据</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131538788.png" alt="image-20230605222104747"></p><p>看前端代码</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131538718.png" alt="image-20230605222232623"></p><p>为什么一加载 就会把请求发出去</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     new Vue(&#123;</span><br><span class="line">       el: &#x27;#member-app&#x27;,</span><br><span class="line">       data() &#123;</span><br><span class="line">         return &#123;</span><br><span class="line">            input: &#x27;&#x27;,</span><br><span class="line">            counts: 0,</span><br><span class="line">            page: 1,</span><br><span class="line">            pageSize: 2,</span><br><span class="line">            tableData : [],</span><br><span class="line">            id : &#x27;&#x27;,</span><br><span class="line">            status : &#x27;&#x27;,</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       computed: &#123;&#125;,</span><br><span class="line">       created() &#123;</span><br><span class="line">         this.init()</span><br><span class="line">           if(localStorage.getItem(&#x27;userInfo&#x27;) != null)&#123;</span><br><span class="line">               //获取当前登录员工的账号，并赋值给模型数据user</span><br><span class="line">               this.user = JSON.parse(localStorage.getItem(&#x27;userInfo&#x27;)).username</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       mounted() &#123;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line">         async init () &#123;</span><br><span class="line">           const params = &#123;</span><br><span class="line">             page: this.page,</span><br><span class="line">             pageSize: this.pageSize,</span><br><span class="line">             name: this.input ? this.input : undefined</span><br><span class="line">           &#125;</span><br><span class="line">           await getMemberList(params).then(res =&gt; &#123;</span><br><span class="line">             if (String(res.code) === &#x27;1&#x27;) &#123;</span><br><span class="line">               this.tableData = res.data.records || []</span><br><span class="line">               this.counts = res.data.total</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;).catch(err =&gt; &#123;</span><br><span class="line">             this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;,</span><br><span class="line">         handleQuery() &#123;</span><br><span class="line">           this.page = 1;</span><br><span class="line">           this.init();</span><br><span class="line">         &#125;,</span><br><span class="line">          // 添加</span><br><span class="line">         addMemberHandle (st) &#123;</span><br><span class="line">           if (st === &#x27;add&#x27;)&#123;</span><br><span class="line">             window.parent.menuHandle(&#123;</span><br><span class="line">               id: &#x27;2&#x27;,</span><br><span class="line">               url: &#x27;/backend/page/member/add.html&#x27;,</span><br><span class="line">               name: &#x27;添加员工&#x27;</span><br><span class="line">             &#125;,true)</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             window.parent.menuHandle(&#123;</span><br><span class="line">               id: &#x27;2&#x27;,</span><br><span class="line">               url: &#x27;/backend/page/member/add.html?id=&#x27;+st,</span><br><span class="line">               name: &#x27;修改员工&#x27;</span><br><span class="line">             &#125;,true)</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         //状态修改</span><br><span class="line">         statusHandle (row) &#123;</span><br><span class="line">           this.id = row.id</span><br><span class="line">           this.status = row.status</span><br><span class="line">           this.$confirm(&#x27;确认调整该账号的状态?&#x27;, &#x27;提示&#x27;, &#123;</span><br><span class="line">             &#x27;confirmButtonText&#x27;: &#x27;确定&#x27;,</span><br><span class="line">             &#x27;cancelButtonText&#x27;: &#x27;取消&#x27;,</span><br><span class="line">             &#x27;type&#x27;: &#x27;warning&#x27;</span><br><span class="line">             &#125;).then(() =&gt; &#123;</span><br><span class="line">             enableOrDisableEmployee(&#123; &#x27;id&#x27;: this.id, &#x27;status&#x27;: !this.status ? 1 : 0 &#125;).then(res =&gt; &#123;</span><br><span class="line">               console.log(&#x27;enableOrDisableEmployee&#x27;,res)</span><br><span class="line">               if (String(res.code) === &#x27;1&#x27;) &#123;</span><br><span class="line">                 this.$message.success(&#x27;账号状态更改成功！&#x27;)</span><br><span class="line">                 this.handleQuery()</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;).catch(err =&gt; &#123;</span><br><span class="line">               this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">             &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;,</span><br><span class="line">         handleSizeChange (val) &#123;</span><br><span class="line">           this.pageSize = val</span><br><span class="line">           this.init()</span><br><span class="line">         &#125;,</span><br><span class="line">         handleCurrentChange (val) &#123;</span><br><span class="line">           this.page = val</span><br><span class="line">           this.init()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上代码是一个使用Vue框架编写的前端页面脚本。它创建了一个Vue实例，其中包含了一些数据和方法。</p><p>首先，在Vue实例的<code>data</code>属性中定义了一些数据，包括<code>input</code>（输入框的值），<code>counts</code>（数据总数），<code>page</code>（当前页码），<code>pageSize</code>（每页显示的数据量），<code>tableData</code>（表格数据），<code>id</code>（员工ID），<code>status</code>（员工状态）等。</p><p>在<code>created</code>生命周期钩子函数中，通过读取浏览器本地存储（localStorage）中的<code>userInfo</code>，将当前登录员工的账号赋值给<code>user</code>数据。</p><p>在<code>mounted</code>生命周期钩子函数中，可以执行一些页面加载后需要进行的操作，但在这个代码片段中没有具体的逻辑。</p><p>接下来是一些方法的定义：</p><ol><li><code>init</code>方法：该方法用于初始化页面数据，它通过调用<code>getMemberList</code>函数获取员工列表数据，并将返回的数据赋值给<code>tableData</code>和<code>counts</code>。</li><li><code>handleQuery</code>方法：当用户点击查询按钮时，将页码（<code>page</code>）重置为1，然后调用<code>init</code>方法重新加载数据。</li><li><code>addMemberHandle</code>方法：用于处理添加员工或修改员工的操作。根据传入的参数<code>st</code>（可以是’add’或员工ID），通过调用<code>window.parent.menuHandle</code>方法打开相应的页面进行添加或修改员工操作。</li><li><code>statusHandle</code>方法：用于处理账号状态的更改。首先将员工的ID和状态赋值给<code>id</code>和<code>status</code>，然后弹出确认对话框，确认调整账号状态后，调用<code>enableOrDisableEmployee</code>函数发送请求，将员工的状态进行更改。如果请求成功，则显示成功提示信息，并调用<code>handleQuery</code>方法重新加载数据。</li><li><code>handleSizeChange</code>方法：当用户改变每页显示数据量时，将新的数据量赋值给<code>pageSize</code>，然后调用<code>init</code>方法重新加载数据。</li><li><code>handleCurrentChange</code>方法：当用户改变当前页码时，将新的页码赋值给<code>page</code>，然后调用<code>init</code>方法重新加载数据。</li></ol><p>综上所述，以上代码主要实现了一个员工管理的前端页面，包括员工列表的展示、查询、添加、修改和账号状态的更改等功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getMemberList (params) &#123;</span><br><span class="line">  return $axios(&#123;</span><br><span class="line">    url: &#x27;/employee/page&#x27;,</span><br><span class="line">    method: &#x27;get&#x27;,</span><br><span class="line">    params</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码定义了一个名为<code>getMemberList</code>的函数，它接受一个名为<code>params</code>的参数。</p><p>该函数使用<code>$axios</code>对象（可能是一个封装了Ajax请求的库）发送一个GET请求，请求的URL是<code>/employee/page</code>。请求的参数使用<code>params</code>对象传递，并设置请求的方法为GET。</p><p>函数执行后，会返回一个Promise对象，可以通过<code>.then()</code>和<code>.catch()</code>方法处理请求的结果或错误。</p><p>简而言之，该函数用于发送一个GET请求到指定URL，参数为<code>params</code>对象中的参数，以获取员工列表的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131538116.png" alt="image-20230605223028153"></p><h3 id="3-2-程序执行流程"><a href="#3-2-程序执行流程" class="headerlink" title="3.2 程序执行流程"></a>3.2 程序执行流程</h3><h4 id="3-2-1-页面流程分析"><a href="#3-2-1-页面流程分析" class="headerlink" title="3.2.1 页面流程分析"></a>3.2.1 页面流程分析</h4><p>在开发代码之前，需要梳理一下整个程序的执行过程。</p><p>A. 点击菜单，打开员工管理页面时，执行查询： </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021804883.png" alt="image-20210729163400772" style="zoom:80%;" /> <p>B. 搜索栏输入员工姓名,回车,执行查询:</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021804030.png" alt="image-20210729164259997"> </p><p>1). 页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端</p><p>2). 服务端Controller接收页面提交的数据, 并组装条件调用Service查询数据</p><p>3). Service调用Mapper操作数据库，查询分页数据</p><p>4). Controller将查询到的分页数据, 响应给前端页面</p><p>5). 页面接收到分页数据, 并通过ElementUI的Table组件展示到页面上</p><h4 id="3-2-2-前端代码介绍"><a href="#3-2-2-前端代码介绍" class="headerlink" title="3.2.2 前端代码介绍"></a>3.2.2 前端代码介绍</h4><p>1). 访问员工列表页面&#x2F;member&#x2F;list.html时, 会触发Vuejs中的钩子方法, 在页面初始化时调用created方法</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021804771.png" alt="image-20210729231639034" style="zoom:80%;" /> <p>从上述的前端代码中我们可以看到, 执行完分页查询, 我们需要给前端返回的信息中需要包含两项 : records 中封装结果列表, total中封装总记录数 。</p><p>而在组装请求参数时 , page、pageSize 都是前端分页插件渲染时的参数；</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021804003.png" alt="image-20210729232916380" style="zoom:80%;" /> <p>2). 在getMemberList方法中, 通过axios发起异步请求</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021804595.png" alt="image-20210729231745143"> </p><p>axios发起的异步请求会被声明在 request.js 中的request拦截器拦截, 在其中对get请求进行进一步的封装处理</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021804051.png" alt="image-20210729232036767"> </p><p><strong>最终发送给服务端的请求为 :</strong> GET请求 , 请求链接 &#x2F;employee&#x2F;page?page&#x3D;1&amp;pageSize&#x3D;10&amp;name&#x3D;xxx</p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><h4 id="3-3-1-分页插件配置"><a href="#3-3-1-分页插件配置" class="headerlink" title="3.3.1 分页插件配置"></a>3.3.1 分页插件配置</h4><p>当前我们要实现的分页查询功能，而在MybatisPlus要实现分页功能，就需要用到MybatisPlus中提供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象。</p><p>所属包: com.itheima.reggie.config</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置MP的分页插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建了一个`MybatisPlusInterceptor`对象</span></span><br><span class="line">        <span class="comment">//`MybatisPlusInterceptor`是MyBatis-Plus框架提供的拦截器，可以在执行MyBatis的SQL语句过程中添加额外的功能。</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//通过调用`addInnerInterceptor`方法，将一个`PaginationInnerInterceptor`对象作为内部拦截器添加到`MybatisPlusInterceptor`中。`PaginationInnerInterceptor`是MyBatis-Plus提供的分页插件，它能够拦截SQL语句，并根据传入的分页参数自动进行分页查询。</span></span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个Java类，用于配置MyBatis-Plus（简称MP）的分页插件。</p><ol><li><code>@Configuration</code>注解表示这是一个配置类，用于配置应用程序的一些组件或功能。</li><li><code>MybatisPlusConfig</code>类中定义了一个名为<code>mybatisPlusInterceptor</code>的Bean方法，用于创建并返回一个<code>MybatisPlusInterceptor</code>对象。</li><li><code>MybatisPlusInterceptor</code>是MyBatis-Plus提供的拦截器，用于拦截MyBatis的SQL执行过程，在执行过程中添加额外的功能。通过调用<code>addInnerInterceptor</code>方法，将一个<code>PaginationInnerInterceptor</code>对象添加为<code>MybatisPlusInterceptor</code>的内部拦截器。</li><li><code>PaginationInnerInterceptor</code>是MyBatis-Plus提供的分页插件，它可以自动拦截SQL语句，根据传入的分页参数进行分页查询。将<code>PaginationInnerInterceptor</code>添加到<code>MybatisPlusInterceptor</code>中后，可以实现对查询结果进行自动分页。</li><li><code>@Bean</code>注解表示将该方法返回的对象注册为一个Spring的Bean，可以在其他组件中通过依赖注入来使用。</li></ol><p>综上所述，以上代码配置了MyBatis-Plus的分页插件，通过创建<code>MybatisPlusInterceptor</code>对象，并添加<code>PaginationInnerInterceptor</code>作为内部拦截器，实现了对MyBatis的自动分页功能。</p><p>详细一点</p><p>当使用MyBatis-Plus框架进行数据库操作时，有时需要对查询结果进行分页显示。以上代码展示了如何配置MyBatis-Plus的分页插件。</p><p>首先，创建一个Java类，并添加<code>@Configuration</code>注解，表示这是一个配置类。该类的主要目的是配置MyBatis-Plus的分页插件。</p><p>在该配置类中，定义了一个名为<code>mybatisPlusInterceptor</code>的方法，并使用<code>@Bean</code>注解进行标记。这意味着该方法返回的对象会被注册为一个Spring的Bean，可以在其他组件中通过依赖注入来使用。</p><p>在<code>mybatisPlusInterceptor</code>方法中，创建了一个<code>MybatisPlusInterceptor</code>对象，并进行了配置。<code>MybatisPlusInterceptor</code>是MyBatis-Plus框架提供的拦截器，可以在执行MyBatis的SQL语句过程中添加额外的功能。</p><p>通过调用<code>addInnerInterceptor</code>方法，将一个<code>PaginationInnerInterceptor</code>对象作为内部拦截器添加到<code>MybatisPlusInterceptor</code>中。<code>PaginationInnerInterceptor</code>是MyBatis-Plus提供的分页插件，它能够拦截SQL语句，并根据传入的分页参数自动进行分页查询。</p><p>这样，通过配置<code>MybatisPlusInterceptor</code>的内部拦截器为<code>PaginationInnerInterceptor</code>，就实现了对MyBatis的自动分页功能。</p><p>总结起来，以上代码通过配置MyBatis-Plus的分页插件，使得在使用MyBatis-Plus进行数据库查询时，可以方便地进行分页操作，以便在页面上分批显示查询结果。这样，开发人员无需手动编写分页逻辑，而是让分页插件自动拦截SQL语句，并根据传入的分页参数进行分页查询，简化了开发过程。</p><p>代码解释2</p><p>这段代码实现了MyBatis Plus分页插件的配置。MyBatis Plus是基于MyBatis的增强工具，在提升开发效率的同时也提供了一些强大的功能，其中之一就是分页插件。</p><p>在这段代码中，我们定义了一个MybatisPlusInterceptor实例，并向其中添加了一个PaginationInnerInterceptor内部拦截器，该拦截器就是用于实现分页功能的。最后将该MybatisPlusInterceptor实例作为Bean注册到Spring容器中，完成MyBatis Plus分页插件的配置。</p><p>代码解释3</p><p>以上代码是一个 MyBatis-Plus 的配置类，它定义了一个名为<code>mybatisPlusInterceptor</code>的 Bean。该 Bean 的作用是在 MyBatis-Plus 中使用 Pagination 插件进行分页处理。</p><p>在<code>mybatisPlusInterceptor</code>方法中，我们创建了一个名为<code>MybatisPlusInterceptor</code>的新对象，并将其返回。这个对象是一个拦截器对象，可以在执行 SQL 操作之前或之后进行拦截。在这里，我们添加了一个内部拦截器<code>PaginationInnerInterceptor</code>,以便在执行查询操作时进行分页处理。</p><p><code>PaginationInnerInterceptor</code>是一个自定义的内部拦截器，它的作用是在执行查询操作时，将查询语句分成多个部分，并根据需要对每个部分进行分页处理。在这个例子中，我们将每个部分的大小设置为 10，这意味着每个部分的大小为 10 条记录。</p><p>在返回<code>MybatisPlusInterceptor</code>对象之后，我们可以在配置文件中定义<code>@Bean</code>方法来创建该对象。在这种情况下，<code>MybatisPlusConfig</code>类是一个配置类，它定义了一个<code>@Bean</code>方法<code>mybatisPlusInterceptor</code>来创建<code>MybatisPlusInterceptor</code>对象。</p><p>通过在配置文件中定义<code>@Bean</code>方法来创建<code>MybatisPlusInterceptor</code>对象，我们可以在应用程序启动时自动配置 MyBatis-Plus，以便在执行查询操作时进行分页处理。</p><p>详细一点</p><p>MyBatis-Plus 是一个开源的持久层框架，它提供了许多功能，例如自动建表、动态 SQL、事务管理等等。其中，分页插件是 MyBatis-Plus 提供的一个重要功能，它可以帮助开发人员更方便地进行分页处理。</p><p>以上代码中的 <code>MybatisPlusConfig</code> 类是一个配置类，它定义了一个 <code>@Bean</code> 方法 <code>mybatisPlusInterceptor</code>,用于创建 <code>MybatisPlusInterceptor</code> 对象。这个对象是一个拦截器对象，可以在执行 SQL 操作之前或之后进行拦截。在这里，我们添加了一个内部拦截器 <code>PaginationInnerInterceptor</code>,它的作用是在执行查询操作时，将查询语句分成多个部分，并根据需要对每个部分进行分页处理。</p><p><code>PaginationInnerInterceptor</code> 是自定义的内部拦截器，它继承了 <code>MyBatisPlusInterceptor</code> 类。<code>MyBatisPlusInterceptor</code> 类是 MyBatis-Plus 提供的默认拦截器类，它提供了一些基本的拦截功能，例如 SQL 过滤、事务管理、异常处理等等。在 <code>PaginationInnerInterceptor</code> 类中，我们重写了其中的一些方法，例如 <code>beforeQuery</code>,用于在查询之前进行分页处理。</p><p>在 <code>beforeQuery</code> 方法中，我们使用 <code>String.split()</code> 方法将查询语句分成多个部分，并将每个部分作为参数传递给 <code>MyBatisPlusInterceptor</code> 的 <code>beforeQuery</code> 方法。在 <code>beforeQuery</code> 方法中，我们可以使用 <code>MapperScannerConfigurer</code> 类来扫描和配置 Mapper 接口，以便在查询时执行相应的操作。</p><p>通过以上代码，我们可以在 MyBatis-Plus 中实现分页功能，而不需要修改 MyBatis-Plus 的源代码。同时，我们还可以在配置文件中定义 <code>@Bean</code> 方法来创建 <code>MybatisPlusInterceptor</code> 对象，以便在应用程序启动时自动配置 MyBatis-Plus，从而提高系统的可维护性和可扩展性。</p><h4 id="3-3-2-分页查询实现"><a href="#3-3-2-分页查询实现" class="headerlink" title="3.3.2 分页查询实现"></a>3.3.2 分页查询实现</h4><p>在上面我们已经分析了，页面在进行分页查询时， 具体的请求信息如下:</p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;employee&#x2F;page</td></tr><tr><td>请求参数</td><td>page , pageSize , name</td></tr></tbody></table><p>那么查询完毕后我们需要给前端返回什么样的结果呢? </p><p>在上述我们也分析了, 查询返回的结果数据data中应该封装两项信息, 分别为: records 封装分页列表数据, total 中封装符合条件的总记录数。 那么这个时候, 在定义controller方法的返回值类型R时, 我们可以直接将 MybatisPlus 分页查询的结果 Page 直接封装返回, 因为Page中的属性如下: </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021804283.png" alt="image-20210729235403154" style="zoom:80%;" /> <p>那么接下来就依据于这些已知的需求和条件完成分页查询的代码实现。 具体的逻辑如下: </p><p>A. 构造分页条件</p><p>B. 构建搜索条件 - name进行模糊匹配</p><p>C. 构建排序条件 - 更新时间倒序排序</p><p>D. 执行查询</p><p>E. 组装结果并返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">records   结果列表</span><br><span class="line">total     总记录数   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131539429.png" alt="image-20230606081950026"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131539309.png" alt="image-20230606082032620"></p><p>接收服务端的响应</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await getMemberList(params).then(res =&gt; &#123;</span><br><span class="line">           if (String(res.code) === &#x27;1&#x27;) &#123;</span><br><span class="line">             this.tableData = res.data.records || []</span><br><span class="line">             this.counts = res.data.total</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>服务端响应回来的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.tableData = res.data.records || []</span><br><span class="line">this.counts = res.data.total</span><br></pre></td></tr></table></figure><p>这就说明  我们响应的JSON里面  应该有records   total字段    而我们的Employee没有这二个字段   所以我们在EmployeeController里面使用的泛型应该是Page   Page是MybatisPlus给我们封装的一个类   一会我们进行分页查询   最终也会返回这个对象    如下图</p><p>在我们的Page里面有我们的.records和total属性  .records放着是当前页  展示的列表数据      total     总记录数   总条数    所以这里面为啥要使用Page  就是因为页面上要拿数据 records和total </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131539517.png" alt="image-20230606081640494"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540157.png" alt="image-20230606083257213"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  R&lt;Page&gt; page() &#123;</span><br><span class="line"></span><br><span class="line">       return  null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540885.png" alt="image-20230606083713938"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 员工信息分页查询</span><br><span class="line">   * @param page 当前查询页码</span><br><span class="line">   * @param pageSize 每页展示记录数</span><br><span class="line">   * @param name 员工姓名 - 可选参数</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  @GetMapping(&quot;/page&quot;)</span><br><span class="line">    public  R&lt;Page&gt; page(int page ,int pageSize, String name) &#123;</span><br><span class="line">      log.info(&quot;page = &#123;&#125;,pageSize = &#123;&#125;,name = &#123;&#125;&quot; ,page,pageSize,name);</span><br><span class="line">       return  null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540813.png" alt="image-20230606084326216"></p><p>刷新 页面 并登录 </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540365.png" alt="image-20230606084418940"></p><p>F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540037.png" alt="image-20230606084530751"></p><p>放行</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540621.png" alt="image-20230606084549836"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540085.png" alt="image-20230606084650465"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131540797.png" alt="image-20230606084723825"></p><p>具体的代码实现如下: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 员工信息分页查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page 当前查询页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize 每页展示记录数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 员工姓名 - 可选参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&gt; <span class="title function_">page</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> pageSize,String name)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;page = &#123;&#125;,pageSize = &#123;&#125;,name = &#123;&#125;&quot;</span> ,page,pageSize,name);</span><br><span class="line">    <span class="comment">//构造分页构造器</span></span><br><span class="line">    <span class="type">Page</span> <span class="variable">pageInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(page,pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>();</span><br><span class="line">    <span class="comment">//添加过滤条件</span></span><br><span class="line">    queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);</span><br><span class="line">    <span class="comment">//添加排序条件</span></span><br><span class="line">    queryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    employeeService.page(pageInfo,queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释1</p><p>以上代码是一个Java Spring Boot中的员工信息分页查询的接口方法。下面是对代码的解释：</p><ol><li><code>@GetMapping(&quot;/page&quot;)</code>: 这是一个GET请求的映射路径，用于处理分页查询请求。请求路径为<code>/page</code>。</li><li><code>public R&lt;Page&gt; page(int page, int pageSize, String name)</code>: 这是一个公共方法，返回类型为<code>R&lt;Page&gt;</code>，即包装了响应结果的对象。方法名为<code>page</code>，接受三个参数：<code>page</code>表示当前查询的页码，<code>pageSize</code>表示每页展示的记录数，<code>name</code>表示员工姓名（可选参数）。</li><li><code>log.info(&quot;page = &#123;&#125;,pageSize = &#123;&#125;,name = &#123;&#125;&quot;, page, pageSize, name)</code>: 这行代码用于输出日志，记录传入的参数值。</li><li><code>Page pageInfo = new Page(page, pageSize)</code>: 这是一个分页构造器，用于创建一个分页对象，传入当前查询的页码和每页展示的记录数。</li><li><code>LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper()</code>: 这是一个条件构造器，用于构建查询条件的对象。</li><li><code>queryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name)</code>: 这行代码添加了一个模糊查询条件，根据员工姓名（<code>Employee</code>对象的<code>name</code>属性）进行模糊匹配。<code>StringUtils.isNotEmpty(name)</code>用于判断<code>name</code>参数是否非空，如果非空，则添加模糊查询条件；否则不添加该条件。</li><li><code>queryWrapper.orderByDesc(Employee::getUpdateTime)</code>: 这行代码添加了一个排序条件，根据员工的更新时间（<code>Employee</code>对象的<code>updateTime</code>属性）进行降序排序。</li><li><code>employeeService.page(pageInfo, queryWrapper)</code>: 这行代码执行查询操作，调用<code>employeeService</code>中的<code>page</code>方法，传入分页对象和查询条件对象，将查询结果封装到<code>pageInfo</code>对象中。</li><li><code>return R.success(pageInfo)</code>: 最后，将封装了查询结果的<code>pageInfo</code>对象作为响应结果，通过<code>R.success()</code>方法包装后返回。</li></ol><p>总体而言，该接口方法接受分页查询的参数，根据参数构建查询条件，并执行查询操作，返回包含查询结果的分页对象。</p><p>这里面的StringUtils是什么</p><p><code>StringUtils</code>是一个字符串处理工具类，通常是Apache Commons Lang库中的一个类。它提供了许多用于处理字符串的实用方法，例如判断字符串是否为空、去除字符串中的空格、比较字符串等。</p><p>在代码中，<code>StringUtils.isNotEmpty(name)</code>用于判断<code>name</code>参数是否为空。如果<code>name</code>不为空，则返回<code>true</code>；如果<code>name</code>为空或为null，则返回<code>false</code>。这个判断条件用于决定是否向查询条件中添加员工姓名的模糊查询条件。</p><p>需要注意的是，<code>StringUtils</code>类可以有不同的实现，而具体使用哪个实现取决于项目中引入的库和版本。</p><p>代码解释2</p><p>以上代码是一个简单的员工信息分页查询的 Spring Boot 应用程序，其功能是接收三个参数：当前查询页码 page、每页展示记录数 pageSize 和员工姓名 name，并返回一个成功响应 PageInfo 对象。</p><p>以下是对代码的详细解释:</p><ol><li><code>@GetMapping(&quot;/page&quot;)</code> 注解指定了请求路径为 &#x2F;page，并映射到 <code>page</code> 方法上。</li><li><code>log.info(&quot;page = &#123;&#125;,pageSize = &#123;&#125;,name = &#123;&#125;&quot; ,page,pageSize,name)</code> 方法中，使用了 <code>log.info</code> 方法输出了三个参数的值，分别是当前查询页码 page、每页展示记录数 pageSize 和员工姓名 name。</li><li><code>Page pageInfo = new Page(page,pageSize)</code> 创建了一个 PageInfo 对象 pageInfo，该对象用于封装分页信息和查询条件。其中，<code>page</code> 参数指定了当前查询页码，<code>pageSize</code> 参数指定了每页展示记录数。</li><li><code>LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper()</code> 创建了一个 LambdaQueryWrapper 对象 queryWrapper，该对象用于封装查询条件。其中，<code>Employee</code> 是员工信息类的泛型类型，<code>name</code> 参数指定了要查询的员工姓名。</li><li><code>queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name)</code> 添加了一个过滤条件，即对员工姓名进行模糊匹配。其中，<code>StringUtils.isNotEmpty(name)</code> 方法检查了 name 参数是否不为空，<code>Employee::getName</code> 方法引用了员工信息的类方法 getName，用于返回员工姓名。</li><li><code>queryWrapper.orderByDesc(Employee::getUpdateTime)</code> 添加了一个排序条件，即按照员工更新时间进行降序排序。</li><li><code>employeeService.page(pageInfo,queryWrapper)</code> 调用了 employeeService 的 page 方法，该方法接收两个参数:pageInfo 对象和 LambdaQueryWrapper 对象。pageInfo 对象用于封装分页信息和查询条件，LambdaQueryWrapper 对象用于封装查询条件。</li><li><code>return R.success(pageInfo)</code> 返回了一个成功响应对象 R，其中包含了分页信息和查询结果。</li></ol><p>综上所述，以上代码实现了一个简单的员工信息分页查询功能，接收三个参数：当前查询页码 page、每页展示记录数 pageSize 和员工姓名 name，并返回一个成功响应 PageInfo 对象。</p><p>代码解释3</p><p>以上代码是一个 Java SpringBoot 项目中的员工信息分页查询 API 接口，主要用于查询符合指定条件的员工列表，并分页展示。具体解释如下：</p><ol><li>@GetMapping(“&#x2F;page”) 注解表示这个接口处理 GET 请求，并注册了 &#x2F;page 的路径映射。</li><li>page、pageSize 和 name 这三个参数分别代表当前查询页码、每页展示记录数和员工姓名（可选），这些参数将作为接口的请求参数传入。</li><li>Page pageInfo &#x3D; new Page(page, pageSize) 给 pageInfo 对象赋值，page 是当前页码，pageSize 是每页展示记录数，这行代码构造了一个分页构造器对象并传入这两个参数，再将其赋值给 pageInfo。</li><li>LambdaQueryWrapper<Employee> queryWrapper &#x3D; new LambdaQueryWrapper() 构造一个条件构造器，用于构建 SQL 查询语句。</li><li>queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name) 给 queryWrapper 添加条件过滤器，如果 name 不为空，则查询名字中包含 name 的员工数据。其中 <code>Employee::getName</code> 表示使用 Employee 实体类的 getName 方法进行筛选操作。</li><li>queryWrapper.orderByDesc(Employee::getUpdateTime) 给 queryWrapper 添加排序条件，按照员工更新时间降序排列。其中 <code>Employee::getUpdateTime</code> 表示使用 Employee 实体类的 getUpdateTime 方法进行排序操作。</li><li>employeeService.page(pageInfo,queryWrapper) 执行查询，将查询结果存放在 pageInfo 对象中，最终返回 pageInfo。</li><li>最后，接口返回一个 R 类对象，使用 success 方法将 pageInfo 封装到响应体中。R 是一个通用的响应类，封装了接口响应的数据和状态等信息。</li></ol><h3 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h3><p>代码编写完毕之后，我们需要将工程重启, 完毕之后直接访问管理系统首页, 默认就会打开员工管理的列表页面, 我们可以查看列表数据是否可以正常展示, 也可以通过分页插件来测试分页功能, 及员工姓名的模糊查询功能。</p><p>在进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节。 并借助于debug的形式， 根据服务端参数接收及逻辑执行情况。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805171.png" alt="image-20210730000855072"> </p><p>测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（1或者0），但是页面上显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理。</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805940.png" alt="image-20210730010606005" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131541053.png" alt="image-20230606091026997"></p><p>F8    两次</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131541749.png" alt="image-20230606091116014"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131541021.png" alt="image-20230606091219400"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131541861.png" alt="image-20230606091238699"></p><p>3次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131541653.png" alt="image-20230606091400825"></p><p>F8</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT COUNT(*) FROM employee</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: COUNT(*)</span><br><span class="line">&lt;==        Row: 4</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">==&gt;  Preparing: SELECT id,username,name,password,phone,sex,id_number,status,create_time,update_time,create_user,update_user FROM employee ORDER BY update_time DESC LIMIT ?</span><br><span class="line">==&gt; Parameters: 10(Long)</span><br><span class="line">&lt;==    Columns: id, username, name, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user</span><br><span class="line">&lt;==        Row: 1665721390604546050, lisi, 李四, e10adc3949ba59abbe56e057f20f883e, 13528659545, 1, 358956221565220, 1, 2023-06-05 22:05:02, 2023-06-05 22:05:02, 1, 1</span><br><span class="line">&lt;==        Row: 1665562193044803586, zhangsan, zs, e10adc3949ba59abbe56e057f20f883e, 13412345678, 1, 350689566956852556, 1, 2023-06-05 11:32:26, 2023-06-05 11:32:26, 1, 1</span><br><span class="line">&lt;==        Row: 1665561007872905218, zhagsan, 张三, e10adc3949ba59abbe56e057f20f883e, 13412345678, 1, 350689566956852556, 1, 2023-06-05 11:27:44, 2023-06-05 11:27:44, 1, 1</span><br><span class="line">&lt;==        Row: 1, admin, 管理员, e10adc3949ba59abbe56e057f20f883e, 13812312312, 1, 110101199001010047, 1, 2021-05-06 17:20:07, 2021-05-10 02:24:09, 1, 1</span><br><span class="line">&lt;==      Total: 4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131541028.png" alt="image-20230606091552186"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131541445.png" alt="image-20230606091621319"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131542660.png" alt="image-20230606091640224"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131542324.png" alt="image-20230606091809618"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131542565.png" alt="image-20230606091927990"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131542620.png" alt="image-20230606092639214"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131542584.png" alt="image-20230606092756034"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131542949.png" alt="image-20230606092923413"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131542621.png" alt="image-20230606092948002"></p><h2 id="4-启用-x2F-禁用员工账号"><a href="#4-启用-x2F-禁用员工账号" class="headerlink" title="4. 启用&#x2F;禁用员工账号"></a>4. 启用&#x2F;禁用员工账号</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p>在员工管理列表页面，可以对某个员工账号进行<font color='gree'>启用</font>或者<font color='red'>禁用</font>操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。如果某个员工账号状态为正常，则按钮显示为 “禁用”，如果员工账号状态为已禁用，则按钮显示为”启用”。</p><p>&#x3D;&#x3D;需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。&#x3D;&#x3D;</p><p><strong>A. admin 管理员登录</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805875.png" alt="image-20210730010858705" style="zoom:80%;" /> <p><strong>B. 普通用户登录</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805876.png" alt="image-20210730010941399" style="zoom:80%;" /> <h3 id="4-2-程序执行流程"><a href="#4-2-程序执行流程" class="headerlink" title="4.2 程序执行流程"></a>4.2 程序执行流程</h3><h4 id="4-2-1-页面按钮动态展示"><a href="#4-2-1-页面按钮动态展示" class="headerlink" title="4.2.1 页面按钮动态展示"></a>4.2.1 页面按钮动态展示</h4><p>在上述的需求中,我们提到需要实现的效果是 : <strong>只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示</strong> , 页面中是怎么做到只有管理员admin能够看到启用、禁用按钮的？</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131543430.png" alt="image-20230606161516664"></p><p>1). 在列表页面(list.html)加载时, 触发钩子函数created, 在钩子函数中, 会从localStorage中获取到用户登录信息, 然后获取到用户名</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131543117.png" alt="image-20230606161858341"></p><p>取到之后  给模型数据 user  </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805956.png" alt="image-20210730012044171" style="zoom:80%;" /> <p>拿到模型数据 user 之后      通过Vue指令v-if进行判断,如果登录用户为admin将展示 启用&#x2F;禁用 按钮, 否则不展示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/el-button&gt;</span><br><span class="line">   &lt;el-button</span><br><span class="line">     type=&quot;text&quot;</span><br><span class="line">     size=&quot;small&quot;</span><br><span class="line">     class=&quot;delBut non&quot;</span><br><span class="line">     @click=&quot;statusHandle(scope.row)&quot;</span><br><span class="line">     v-if=&quot;user === &#x27;admin&#x27;&quot; // 通过Vue指令v-if进行判断,如果登录用户为admin将展示 启用/禁用 按钮, 否则不展示</span><br><span class="line">   &gt;</span><br><span class="line">     &#123;&#123; scope.row.status == &#x27;1&#x27; ? &#x27;禁用&#x27; : &#x27;启用&#x27; &#125;&#125;</span><br><span class="line">   &lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131543889.png" alt="image-20230606162420563"></p><p>2). 在页面中, 通过Vue指令v-if进行判断,如果登录用户为admin将展示 启用&#x2F;禁用 按钮, 否则不展示</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805195.png" alt="image-20210730012256779" style="zoom:80%;" /> <h4 id="4-2-2-执行流程分析"><a href="#4-2-2-执行流程分析" class="headerlink" title="4.2.2 执行流程分析"></a>4.2.2 执行流程分析</h4><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131543885.png" alt="image-20230606162658714"></p><p>1、页面发送ajax请求，将参数(id、status)提交到服务端</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131543443.png" alt="image-20230606162918904"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131543717.png" alt="image-20230606162934254"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131544148.png" alt="image-20230606162953705"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131544276.png" alt="image-20230606163014768"></p><p>2 、服务端Controller接收页面提交的数据并调用Service更新数据</p><p>3、Service调用Mapper操作数据库</p><p>为什么点击禁用或启用按钮  会发出请求</p><p>1). 当管理员admin点击 “启用” 或 “禁用” 按钮时, 调用方法statusHandle</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131544669.png" alt="image-20230606163342979"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805275.png" alt="image-20210730012723560" style="zoom:80%;" /> <blockquote><p>scope.row : 获取到的是这一行的数据信息 ;</p></blockquote><p>同时会传出scope.row过来   scope.row就是我们看到的数据 全封装的JSON对象</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131544852.png" alt="image-20230606163609077"></p><p>2). statusHandle方法中进行二次确认, 然后发起ajax请求, 传递id、status参数</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131544876.png" alt="image-20230606163716706"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//状态修改</span><br><span class="line">         statusHandle (row) &#123;</span><br><span class="line">           this.id = row.id    //获得id的值</span><br><span class="line">           this.status = row.status    //获得状态的值</span><br><span class="line">           this.$confirm(&#x27;确认调整该账号的状态?&#x27;, &#x27;提示&#x27;, &#123;</span><br><span class="line">             &#x27;confirmButtonText&#x27;: &#x27;确定&#x27;,</span><br><span class="line">             &#x27;cancelButtonText&#x27;: &#x27;取消&#x27;,</span><br><span class="line">             &#x27;type&#x27;: &#x27;warning&#x27;</span><br><span class="line">             &#125;).then(() =&gt; &#123;</span><br><span class="line">             enableOrDisableEmployee(&#123; &#x27;id&#x27;: this.id, &#x27;status&#x27;: !this.status ? 1 : 0 &#125;).then(res =&gt; &#123;</span><br><span class="line">               console.log(&#x27;enableOrDisableEmployee&#x27;,res)</span><br><span class="line">               if (String(res.code) === &#x27;1&#x27;) &#123;</span><br><span class="line">                 this.$message.success(&#x27;账号状态更改成功！&#x27;)</span><br><span class="line">                 this.handleQuery()</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;).catch(err =&gt; &#123;</span><br><span class="line">               this.$message.error(&#x27;请求出错了：&#x27; + err)</span><br><span class="line">             &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;,</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021805043.png" alt="image-20210730013011861" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131545498.png" alt="image-20230606164539702"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021806003.png" alt="image-20210730013210948" style="zoom:80%;" /> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改---启用禁用接口</span><br><span class="line">function enableOrDisableEmployee (params) &#123;</span><br><span class="line">  return $axios(&#123;</span><br><span class="line">    url: &#x27;/employee&#x27;,</span><br><span class="line">    method: &#x27;put&#x27;,</span><br><span class="line">    data: &#123; ...params &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终发起异步请求, 请求服务端, 请求信息如下： </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>PUT</td></tr><tr><td>请求路径</td><td>&#x2F;employee</td></tr><tr><td>请求参数</td><td>{“id”:xxx,”status”:xxx}</td></tr></tbody></table><blockquote><p><strong>{…params}</strong> : 三点是ES6中出现的扩展运算符。作用是遍历当前使用的对象能够访问到的所有属性，并将属性放入当前对象中。</p></blockquote><h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><p>在开发代码之前，需要梳理一下整个程序的执行过程：</p><p>1). 页面发送ajax请求，将参数(id、status)提交到服务端</p><p>2). 服务端Controller接收页面提交的数据并调用Service更新数据</p><p>3). Service调用Mapper操作数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据id修改员工信息</span><br><span class="line"> * @param employee</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@PutMapping</span><br><span class="line">public R&lt;String&gt; update(@RequestBody Employee employee)&#123;</span><br><span class="line">    </span><br><span class="line">    log.info(employee.toString());</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131545374.png" alt="image-20230606170213213"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131550246.png" alt="image-20230606170238827"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131550257.png" alt="image-20230606170309899"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131550686.png" alt="image-20230606170402306"></p><p>启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作。在Controller中创建update方法，此方法是一个通用的修改员工信息的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id修改员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(HttpServletRequest request,<span class="meta">@RequestBody</span> Employee employee)</span>&#123;</span><br><span class="line">    log.info(employee.toString());</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long)request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line"></span><br><span class="line">    employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    employee.setUpdateUser(empId);</span><br><span class="line">    employeeService.updateById(employee);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;员工信息修改成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131550918.png" alt="image-20230606170846979"></p><p>代码解释1</p><p>以上代码是一个Java Spring Boot框架中的控制器方法。代码使用了<code>@PutMapping</code>注解，表示该方法处理HTTP的PUT请求。</p><p>方法的目的是根据提供的员工ID（通过<code>request.getSession().getAttribute(&quot;employee&quot;)</code>获取）来修改员工信息。方法的参数包括<code>HttpServletRequest</code>对象和<code>Employee</code>对象，其中<code>HttpServletRequest</code>对象用于获取当前会话中的员工ID，<code>Employee</code>对象包含了需要更新的员工信息。</p><p>代码的执行步骤如下：</p><ol><li>首先，日志记录器<code>log</code>会打印出<code>employee</code>对象的字符串表示，以便在日志中查看传入的员工信息。</li><li>通过<code>request.getSession().getAttribute(&quot;employee&quot;)</code>获取当前会话中的员工ID，并将其赋值给<code>empId</code>变量。</li><li>使用<code>LocalDateTime.now()</code>获取当前的时间，并将其设置为员工信息的更新时间。</li><li>将<code>empId</code>设置为员工信息的更新用户。</li><li>调用<code>employeeService.updateById(employee)</code>方法来更新数据库中对应员工ID的员工信息。</li><li>最后，返回一个成功的<code>R</code>对象，包含了一个消息字符串”员工信息修改成功”。</li></ol><p>需要注意的是，代码中的<code>R&lt;String&gt;</code>表示返回一个包含泛型为<code>String</code>的<code>R</code>对象。<code>R</code>可能是自定义的响应对象，其中包含了一些用于表示请求结果的字段，例如状态码、消息等。具体实现可能需要查看项目中的相关代码。</p><p>在详细一点</p><p>以上代码是一个Java Spring Boot框架中的控制器方法。代码使用了<code>@PutMapping</code>注解，表示该方法处理HTTP的PUT请求。</p><p>方法的目的是根据提供的员工ID（通过<code>request.getSession().getAttribute(&quot;employee&quot;)</code>获取）来修改员工信息。方法的参数包括<code>HttpServletRequest</code>对象和<code>Employee</code>对象，其中<code>HttpServletRequest</code>对象用于获取当前会话中的员工ID，<code>Employee</code>对象包含了需要更新的员工信息。</p><p>代码的执行步骤如下：</p><ol><li>首先，日志记录器<code>log</code>会打印出<code>employee</code>对象的字符串表示，以便在日志中查看传入的员工信息。</li><li>通过<code>request.getSession().getAttribute(&quot;employee&quot;)</code>获取当前会话中的员工ID，并将其赋值给<code>empId</code>变量。</li><li>使用<code>LocalDateTime.now()</code>获取当前的时间，并将其设置为员工信息的更新时间。</li><li>将<code>empId</code>设置为员工信息的更新用户。</li><li>调用<code>employeeService.updateById(employee)</code>方法来更新数据库中对应员工ID的员工信息。</li><li>最后，返回一个成功的<code>R</code>对象，包含了一个消息字符串”员工信息修改成功”。</li></ol><p>需要注意的是，代码中的<code>R&lt;String&gt;</code>表示返回一个包含泛型为<code>String</code>的<code>R</code>对象。<code>R</code>可能是自定义的响应对象，其中包含了一些用于表示请求结果的字段，例如状态码、消息等。具体实现可能需要查看项目中的相关代码。</p><p>不明白的点</p><p>方法的参数有两个：HttpServletRequest对象和Employee对象。HttpServletRequest对象用于获取当前会话中的员工ID，Employee对象包含了需要更新的员工信息。</p><p>非常抱歉，我解释中的那部分可能不够清晰。我将重新解释方法的参数以及它们的作用。</p><ol><li><p>HttpServletRequest对象：HttpServletRequest是Java Servlet中的一个类，它表示客户端发出的HTTP请求。在这个方法中，我们将HttpServletRequest对象作为参数传递进来，以便获取当前会话中的员工ID。</p><p>当前会话是指与客户端（通常是Web浏览器）的交互过程中，服务器保持的关于该客户端的信息。会话可以跨多个HTTP请求，并且在整个会话期间保持活动状态。通过HttpServletRequest对象，我们可以获取与会话相关的信息，例如会话中存储的属性值。</p><p>在这段代码中，我们使用<code>request.getSession().getAttribute(&quot;employee&quot;)</code>来获取会话中名为”employee”的属性值。这个属性值应该是当前登录员工的ID。</p></li><li><p>Employee对象：Employee是一个自定义的类，它表示员工的信息。在这个方法中，我们将Employee对象作为参数传递进来，其中包含了需要更新的员工信息。</p><p>Employee对象通常具有多个属性，例如姓名、职位、薪水等。在这段代码中，我们传入的Employee对象应该包含了需要进行更新的员工信息。通过这个对象，我们可以获取和设置员工的各种属性值。</p><p>在方法的后续代码中，我们将使用Employee对象的方法来设置员工的更新时间和更新用户，然后将其传递给一个名为<code>updateById</code>的方法，以便在数据库中更新员工的信息。</p></li></ol><p>总结：HttpServletRequest对象用于获取当前会话中的员工ID，而Employee对象包含了需要更新的员工信息。通过这两个参数，我们可以获取员工ID和更新的员工信息，并进行相应的操作，例如记录更新时间和更新用户，然后进行数据库的更新操作。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131550358.png" alt="image-20230606181406229"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131550262.png" alt="image-20230606181518082"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131551383.png" alt="image-20230606181535268"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131551952.png" alt="image-20230606181604732"></p><p>5次F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131551679.png" alt="image-20230606184045746"></p><p>id不正确  更新失败</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131552765.png" alt="image-20230606184440220"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131552126.png" alt="image-20230606184537335"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131552710.png" alt="image-20230606184649800"></p><p>正确id</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131552901.png" alt="image-20230606184506867"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131553078.png" alt="image-20230606185224571"></p><h3 id="4-4-功能测试"><a href="#4-4-功能测试" class="headerlink" title="4.4 功能测试"></a>4.4 功能测试</h3><p>代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 进行 “启用” 或 “禁用” 的测试。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021806965.png" alt="image-20210730123213103"> </p><p>测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。但是从控制台输出的日志， 可以看出确实没有更新成功。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021806475.png" alt="image-20210730123307452"> </p><p>而在我们的数据库表结构中， 并不存在该ID， 数据库中 风清扬 对应的ID为 1420038345634918401</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021806756.png" alt="image-20210730123519468"> </p><h3 id="4-5-代码修复"><a href="#4-5-代码修复" class="headerlink" title="4.5 代码修复"></a>4.5 代码修复</h3><h4 id="4-5-1-原因分析"><a href="#4-5-1-原因分析" class="headerlink" title="4.5.1 原因分析"></a>4.5.1 原因分析</h4><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021806412.png" alt="image-20210730123833129"> </p><p>通过观察控制台输出的SQL发现页面传递过来的员工id的值和数据库中的id值不一致，这是怎么回事呢？</p><p>在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一个Long类型的数据，而且是一个长度为 19 位的长整型数据， 该数据返回给前端是没有问题的。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021806699.png" alt="image-20210730124036415"> </p><p><strong>那么具体的问题出现在哪儿呢？</strong></p><p>问题实际上， 就出现在前端JS中， js在对长度较长的长整型数据进行处理时， 会损失精度， 从而导致提交的id和数据库中的id不一致。 这里，我们也可以做一个简单的测试，代码如下： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        alert(1420038345634918401);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-5-2-解决方案"><a href="#4-5-2-解决方案" class="headerlink" title="4.5.2 解决方案"></a>4.5.2 解决方案</h4><p>要想解决这个问题，也很简单，我们只需要让js处理的ID数据类型为字符串类型即可, 这样就不会损失精度了。同样， 大家也可以做一个测试： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;1420038345634918401&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在我们的业务中, 我们只需要让分页查询返回的json格式数据库中, long类型的属性, 不直接转换为数字类型, 转换为字符串类型就可以解决这个问题了 , 最终返回的结果为 : </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021807347.png" alt="image-20210730125138652"> </p><h4 id="4-5-3-代码修复"><a href="#4-5-3-代码修复" class="headerlink" title="4.5.3 代码修复"></a>4.5.3 代码修复</h4><p>由于在SpringMVC中, 将Controller方法返回值转换为json对象, 是通过jackson来实现的, 涉及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter, 所以我们要解决这个问题, 就需要对该消息转换器的功能进行拓展。</p><p><strong>具体实现步骤：</strong></p><p>1). 提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资料中已经提供，直接复制到项目中使用）</p><p>2). 在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象转换器进行Java对象到json数据的转换</p><p><strong>1). 引入JacksonObjectMapper</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.<span class="keyword">module</span>.SimpleModule;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ser.std.ToStringSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span></span><br><span class="line"><span class="comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span></span><br><span class="line"><span class="comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonObjectMapper</span> <span class="keyword">extends</span> <span class="title class_">ObjectMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JacksonObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//收到未知属性时不报异常</span></span><br><span class="line">        <span class="built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//反序列化时，属性不存在的兼容处理</span></span><br><span class="line">        <span class="built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>()</span><br><span class="line">                .addDeserializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line"></span><br><span class="line">                .addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line"></span><br><span class="line">                .addSerializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addSerializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line">        <span class="comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span></span><br><span class="line">        <span class="built_in">this</span>.registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该自定义的对象转换器, 主要指定了, 在进行json数据序列化及反序列化时, LocalDateTime、LocalDate、LocalTime的处理方式, 以及BigInteger及Long类型数据，直接转换为字符串。</p><p><strong>2). 在WebMvcConfig中重写方法extendMessageConverters</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展mvc框架的消息转换器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;扩展消息转换器...&quot;</span>);</span><br><span class="line">    <span class="comment">//创建消息转换器对象</span></span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">messageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">//设置对象转换器，底层使用Jackson将Java对象转为json</span></span><br><span class="line">    messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">    <span class="comment">//将上面的消息转换器对象追加到mvc框架的转换器集合中</span></span><br><span class="line">    converters.add(<span class="number">0</span>,messageConverter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131553415.png" alt="image-20230606191322076"></p><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131553663.png" alt="image-20230606191558145"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131553038.png" alt="image-20230606191638850"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131553871.png" alt="image-20230606191653555"></p><p>4次  F8</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131554063.png" alt="image-20230606191801577"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131554799.png" alt="image-20230606191934221"></p><p>放行</p><p>重新启动</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131554310.png" alt="image-20230606192207403"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131554974.png" alt="image-20230606192317429"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131554126.png" alt="image-20230606192342809"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131554438.png" alt="image-20230606192403783"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131554302.png" alt="image-20230606192442798"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131555469.png" alt="image-20230606192613884"></p><h2 id="5-编辑员工信息"><a href="#5-编辑员工信息" class="headerlink" title="5. 编辑员工信息"></a>5. 编辑员工信息</h2><p>在开发代码之前需要梳理一下操作过程和对应的程序的执行流程：<br>1、点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]<br>2、在add.html页面获取url中的参数[员工id]<br>3、发送ajax请求，请求服务端，同时提交员工id参数<br>4、服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面<br>5、页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显<br>6、点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端<br>7、服务端接收员工信息，并进行处理，完成后给页面响应<br>8、页面接收到服务端响应信息后进行相应处理</p><p>注意：add.html页面为公共页面，新增员工和编辑员工都是在此页面操作</p><p>1、点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131555057.png" alt="image-20230613140125600"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306142117010.png" alt="image-20230613140243231"></p><p>2、在add.html页面获取url中的参数[员工id]</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131555202.png" alt="image-20230613140358547"></p><p>3、发送ajax请求，请求服务端，同时提交员工id参数<br>4、服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面</p><p>5、页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显</p><p>我们刚才看到的报的404   把这个id作为请求路径的一部分</p><p>为什么要发送请求</p><p>因为我们的服务端接收到请求之后  可以根据id去查询用户   然后回显到页面上  以JSON的形式响应给页面</p><p>页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131555540.png" alt="image-20230613140611268"></p><p>注意点：</p><p>在修改的过程中有两次与服务端进行交互</p><p>第一次    发送请求  查询相对应的数据进行回显</p><p>第二次    当我们点击保存按钮的时候  把我们修改之后的数据 提交到我们的服务端</p><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><p>在员工管理列表页面点击 “编辑” 按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最后点击 “保存” 按钮完成编辑操作。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021807123.png" alt="image-20210730181733784"> </p><p>那么从上述的分析中，我们可以看出当前实现的编辑功能,我们需要实现两个方法:</p><p>A. 根据ID查询, 用于页面数据回显</p><p>B. 保存修改</p><p>执行流程（视频版本）</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131555348.png" alt="image-20230613143736690"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131555106.png" alt="image-20230613143819149"></p><h3 id="5-2-程序执行流程"><a href="#5-2-程序执行流程" class="headerlink" title="5.2 程序执行流程"></a>5.2 程序执行流程</h3><p>在开发代码之前需要梳理一下操作过程和对应的程序的执行流程：</p><p>1). 点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021807323.png" alt="image-20210730225514330"> </p><p>2). 在add.html页面获取url中的参数[员工id]</p><p>3). 发送ajax请求，请求服务端，同时提交员工id参数</p><p>4). 服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021807595.png" alt="image-20210730230005437"> </p><p>5). 页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显</p><p>6). 点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端</p><p>7). 服务端接收员工信息，并进行处理，完成后给页面响应</p><p>8). 页面接收到服务端响应信息后进行相应处理</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202304021807419.png" alt="image-20210730230533123" style="zoom:80%;" /> <blockquote><p>注意：add.html页面为公共页面，新增员工和编辑员工都是在此页面操作</p></blockquote><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><h4 id="5-3-1-根据ID查询"><a href="#5-3-1-根据ID查询" class="headerlink" title="5.3.1 根据ID查询"></a>5.3.1 根据ID查询</h4><p>经过上述的分析,我们看到,在根据ID查询员工信息时,请求信息如下: </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>&#x2F;employee&#x2F;{id}</td></tr></tbody></table><p><strong>代码实现:</strong> </p><p>在EmployeeController中增加方法, 根据ID查询员工信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Employee&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;根据id查询员工信息...&quot;</span>);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.getById(id);</span><br><span class="line">    <span class="keyword">if</span>(employee != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> R.success(employee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R.error(<span class="string">&quot;没有查询到对应员工信息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><p>解释1 </p><p>以上代码是一个基于Spring框架的Java代码片段，用于实现一个RESTful API接口。代码中包含了一个GET请求方法，用于根据员工ID查询员工信息。</p><p>解释如下：</p><ol><li><code>@GetMapping(&quot;/&#123;id&#125;&quot;)</code>：这是一个注解，指定了HTTP GET请求的URL路径。<code>/&#123;id&#125;</code>表示该路径中需要包含一个名为id的路径参数。</li><li><code>public R&lt;Employee&gt; getById(@PathVariable Long id)</code>：这是一个公共方法，返回类型为R<Employee>。R是一个自定义的响应对象，用于封装API接口的返回结果。方法名为getById，接收一个名为id的路径参数。</li><li><code>log.info(&quot;根据id查询员工信息...&quot;)</code>：这是一个日志输出语句，用于在日志中记录一条信息，表示正在执行根据员工ID查询员工信息的操作。</li><li><code>Employee employee = employeeService.getById(id)</code>：这是调用一个名为employeeService的服务对象的getById方法，传入id参数，用于根据员工ID查询员工信息。查询结果会保存在employee对象中。</li><li><code>if(employee != null)</code>：如果查询到了员工信息（employee不为null），则执行下一行代码；否则，执行返回错误信息的逻辑。</li><li><code>return R.success(employee)</code>：如果查询到了员工信息，将员工信息作为成功响应的数据，使用R.success方法封装响应结果，然后返回。</li><li><code>return R.error(&quot;没有查询到对应员工信息&quot;)</code>：如果没有查询到员工信息，将错误信息作为错误响应的数据，使用R.error方法封装响应结果，然后返回。</li></ol><p>总体而言，这段代码实现了一个GET请求接口，通过传入员工ID来查询对应的员工信息，并将查询结果通过自定义的响应对象R进行封装后返回。</p><p>解释2</p><p>当客户端发送一个GET请求到指定的URL路径时（例如：<code>/&#123;id&#125;</code>），该方法会被执行。在这个URL路径中，我们期望包含一个名为id的路径参数，以便指定要查询的员工的ID。</p><p>在方法体内部，首先通过日志输出记录正在执行的操作，即根据员工ID查询员工信息。</p><p>然后，通过调用一个名为employeeService的服务对象的getById方法，将传入的id参数作为查询条件，来获取对应的员工信息。查询结果将保存在名为employee的对象中。</p><p>接下来，通过判断employee对象是否为null来判断是否成功查询到员工信息。如果employee不为null，表示查询成功，将员工信息作为成功响应的数据。代码使用R.success方法将响应结果封装为一个成功响应对象R，并将其返回给客户端。</p><p>如果employee为null，表示没有查询到对应的员工信息，代码使用R.error方法将错误信息封装为一个错误响应对象R，并将其返回给客户端。</p><p>简而言之，该代码片段实现了一个GET请求接口，客户端通过传递员工ID来查询对应的员工信息。如果查询成功，返回包含员工信息的成功响应；如果查询失败，返回包含错误信息的错误响应。</p><p>详细解释    Employee employee &#x3D; employeeService.getById(id);   这点不是很明白  能不能在详细解释一下</p><p>当代码执行到<code>Employee employee = employeeService.getById(id);</code>这一行时，它调用了名为<code>employeeService</code>的服务对象的<code>getById</code>方法，并传递了<code>id</code>参数。</p><p>在代码中，<code>employeeService</code>是一个封装了员工相关操作的服务对象。通过调用<code>getById</code>方法，它会根据传入的<code>id</code>参数查询对应的员工信息。</p><p>这里的<code>getById</code>方法可能会包含数据库查询操作或者其他方式的数据获取逻辑，具体实现取决于<code>employeeService</code>对象的具体实现。它会根据传入的<code>id</code>参数查询数据库或其他数据源，以获取对应<code>id</code>的员工信息。</p><p>查询结果将会被存储在名为<code>employee</code>的<code>Employee</code>对象中。这个对象将包含查询到的员工信息，例如姓名、职位、工资等。</p><p>最后，<code>employee</code>对象将用于后续的判断和处理。根据查询结果，代码会决定返回成功响应（包含<code>employee</code>对象作为响应数据）或者返回错误响应（表示没有查询到对应的员工信息）。</p><p>总而言之，<code>Employee employee = employeeService.getById(id);</code>这一行代码的作用是调用服务对象的方法来获取对应<code>id</code>的员工信息，并将查询结果存储在名为<code>employee</code>的对象中，以供后续处理和返回响应使用。</p><p><code>employeeService</code>是一个处理员工信息的服务对象。<code>getById</code>方法是该服务对象中的一个功能，它的作用是根据传入的员工ID来获取相应的员工信息。</p><p>在代码中，通过<code>employeeService.getById(id)</code>这一行，程序会调用<code>getById</code>方法，并传入<code>id</code>作为参数。这样，<code>getById</code>方法就知道要查询哪个员工的信息。</p><p><code>getById</code>方法会根据提供的<code>id</code>，在数据库或其他数据源中查找相应的员工信息。查询的结果将会被赋值给一个叫<code>employee</code>的变量，它是一个<code>Employee</code>类型的对象。</p><p>最后，根据查询结果的情况，代码会决定返回成功响应或错误响应。如果成功找到了员工信息，就会将<code>employee</code>作为成功响应的数据返回。如果没有找到对应的员工信息，就会返回一个错误提示。</p><p>简单来说，这段代码的目的是根据传入的员工ID，通过调用<code>employeeService</code>的<code>getById</code>方法来获取对应员工的信息，并根据查询结果返回相应的响应。</p><p><code>Employee employee = employeeService.getById(id);</code> 表示获取员工信息的对象实例。</p><p><code>employeeService</code> 是一个依赖注入的 Bean，它实现了 <code>EmployeeService</code> 接口，该接口定义了 <code>getById</code> 方法，方法的参数为 <code>id</code>,返回值为 <code>Employee</code> 对象。</p><p><code>getById</code> 方法的实现是通过调用数据库中存储的员工信息的 <code>id</code> 字段来获取员工信息的对象实例。如果数据库中的员工信息与传入的 <code>id</code> 值匹配，则返回员工信息的对象实例，否则返回 <code>null</code>。</p><p>由于此接口定义为 RESTful API，因此返回的员工信息对象实例应该遵循 HTTP 响应状态码和响应头规范。通常情况下，响应状态码为 200(成功) 或 404(未找到资源)。</p><p>在以上代码中，如果员工信息不为空，则返回响应对象 <code>R.success(employee)</code>,表示员工信息已成功查询到;否则，返回错误响应 <code>R.error(&quot;没有查询到对应员工信息&quot;)</code>,表示无法查询到员工信息。</p><p>测试</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131556298.png" alt="image-20230613151354875"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131557745.png" alt="image-20230613151639165"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131557489.png" alt="image-20230613151926222"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131557465.png" alt="image-20230613152129407"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day02/202306131557210.png" alt="image-20230613152222794"></p><h4 id="5-3-2-修改员工"><a href="#5-3-2-修改员工" class="headerlink" title="5.3.2 修改员工"></a>5.3.2 修改员工</h4><p>经过上述的分析,我们看到,在修改员工信息时,请求信息如下: </p><table><thead><tr><th>请求</th><th>说明</th></tr></thead><tbody><tr><td>请求方式</td><td>PUT</td></tr><tr><td>请求路径</td><td>&#x2F;employee</td></tr><tr><td>请求参数</td><td>{…….} json格式数据</td></tr></tbody></table><p><strong>代码实现:</strong> </p><p>在EmployeeController中增加方法, 根据ID更新员工信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id修改员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">update</span><span class="params">(HttpServletRequest request,<span class="meta">@RequestBody</span> Employee employee)</span>&#123;</span><br><span class="line">    log.info(employee.toString());</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> (Long)request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line"></span><br><span class="line">    employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    employee.setUpdateUser(empId);</span><br><span class="line">    employeeService.updateById(employee);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;员工信息修改成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-功能测试"><a href="#5-4-功能测试" class="headerlink" title="5.4 功能测试"></a>5.4 功能测试</h3><p>代码编写完毕之后，我们需要将工程重启。 然后访问前端页面， 按照前面分析的操作流程进行测试，查看数据是否正常修改即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖-Day01</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖-Day01"><a href="#瑞吉外卖-Day01" class="headerlink" title="瑞吉外卖-Day01"></a>瑞吉外卖-Day01</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul><li><p>软件开发整体介绍</p></li><li><p>瑞吉外卖项目介绍</p></li><li><p>开发环境搭建</p></li><li><p>后台登录功能开发</p></li><li><p>后台退出功能开发</p></li></ul><h2 id="1-软件开发整体介绍"><a href="#1-软件开发整体介绍" class="headerlink" title="1. 软件开发整体介绍"></a>1. 软件开发整体介绍</h2><p>作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程， 以及软件开发过程中涉及到的岗位角色，角色的分工、职责， 并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从 软件开发流程、角色分工、软件环境 三个方面，来整体上介绍一下软件开发。</p><h3 id="1-1-软件开发流程"><a href="#1-1-软件开发流程" class="headerlink" title="1.1 软件开发流程"></a>1.1 软件开发流程</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031359778.png" alt="image-20210725231106363"> </p><p><strong>1). 第1阶段: 需求分析</strong></p><p>完成产品原型、需求规格说明书的编写。  </p><p>产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。 </p><p>需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及业务流程是什么样的，都会在文档中描述。</p><p><strong>2). 第2阶段: 设计</strong></p><p>设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。</p><p>在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段，字段类型都会在文档中描述清楚。</p><p><strong>3). 第3阶段: 编码</strong></p><p>编写项目代码、并完成单元测试。</p><p>作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。</p><p><strong>4). 第4阶段: 测试</strong></p><p>在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。</p><p><strong>5). 第5阶段: 上线运维</strong></p><p>在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。</p><p>我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及到数据库的设计、测试等方面的工作。</p><h3 id="1-2-角色分工"><a href="#1-2-角色分工" class="headerlink" title="1.2 角色分工"></a>1.2 角色分工</h3><p>学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及各个角色的职责分工。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031359918.png" alt="image-20210725234015404"> </p><table><thead><tr><th>岗位&#x2F;角色</th><th>职责&#x2F;分工</th></tr></thead><tbody><tr><td>项目经理</td><td>对整个项目负责，任务分配、把控进度</td></tr><tr><td>产品经理</td><td>进行需求调研，输出需求调研文档、产品原型等</td></tr><tr><td>UI设计师</td><td>根据产品原型输出界面效果图</td></tr><tr><td>架构师</td><td>项目整体架构设计、技术选型等</td></tr><tr><td><font color='red'>开发工程师</font></td><td><font color='red'>功能代码实现</font></td></tr><tr><td>测试工程师</td><td>编写测试用例，输出测试报告</td></tr><tr><td>运维工程师</td><td>软件环境搭建、项目上线</td></tr></tbody></table><p>上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程序员兼任。</p><h3 id="1-3-软件环境"><a href="#1-3-软件环境" class="headerlink" title="1.3 软件环境"></a>1.3 软件环境</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031400614.png" alt="image-20210725234046008"> </p><p>在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。</p><p><strong>1). 开发环境(development)</strong></p><p>我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。</p><p>比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使用这套环境了，这个环境就是开发环境。</p><p><strong>2). 测试环境(testing)</strong></p><p>当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试环境，用于项目测试，一般外部用户无法访问。</p><p><strong>3). 生产环境(production)</strong></p><p>当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对外提供服务，这个线上环境也称之为生产环境。</p><blockquote><p><font color='gree'> <b>拓展知识:</b></font> </p><p>​<strong>准生产环境:</strong> 对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生产环境。为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 …) 的版本都一样，这种环境也称为 “仿真环境”。</p><p>​ps.由于项目的性质和类型不同，有的项目可能不需要这个环境</p></blockquote><h2 id="2-瑞吉外卖项目介绍"><a href="#2-瑞吉外卖项目介绍" class="headerlink" title="2. 瑞吉外卖项目介绍"></a>2. 瑞吉外卖项目介绍</h2><p>在开发瑞吉外卖这个项目之前，我们需要全方位的来介绍一下当前我们学习的这个项目。接下来，我们将从以下的五个方面， 来介绍瑞吉外卖这个项目。</p><h3 id="2-1-项目介绍"><a href="#2-1-项目介绍" class="headerlink" title="2.1 项目介绍"></a>2.1 项目介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031400910.png" alt="image-20210726000655646"> </p><p>本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括 系统管理后台 和 移动端应用 两部分。其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜品、套餐、订单、员工等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。</p><p>本项目共分为3期进行开发：</p><table><thead><tr><th>阶段</th><th>功能实现</th></tr></thead><tbody><tr><td>第一期</td><td>主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问</td></tr><tr><td>第二期</td><td>主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便</td></tr><tr><td>第三期</td><td>主要针对系统进行优化升级，提高系统的访问性能</td></tr></tbody></table><h3 id="2-2-产品原型"><a href="#2-2-产品原型" class="headerlink" title="2.2 产品原型"></a>2.2 产品原型</h3><p><strong>产品原型</strong>，就是一款产品成型之前，由产品经理绘制的一个简单的框架，就是将页面的排版布局展现出来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的功能。</p><blockquote><p><strong><font color='red'>注意事项：</font></strong> 产品原型主要用于展示项目的功能，并不是最终的页面效果。</p></blockquote><p>在课程资料的产品原型文件夹下,提供了两份产品原型。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031400542.png" alt="image-20210726002509573"> </p><p><strong>1). 管理端</strong></p><p>餐饮企业内部员工使用。 主要功能有: </p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>内部员工必须登录后,才可以访问系统管理后台</td></tr><tr><td>员工管理</td><td>管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能</td></tr><tr><td>分类管理</td><td>主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护， 包含查询、新增、修改、删除等功能</td></tr><tr><td>菜品管理</td><td>主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>套餐管理</td><td>主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能</td></tr><tr><td>订单明细</td><td>主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能</td></tr></tbody></table><p><strong>2). 用户端</strong></p><p>移动端应用主要提供给消费者使用。主要功能有:</p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>登录&#x2F;退出</td><td>在移动端, 用户也需要登录后使用APP进行点餐</td></tr><tr><td>点餐-菜单</td><td>在点餐界面需要展示出菜品分类&#x2F;套餐分类, 并根据当前选择的分类加载其中的菜品信息, 供用户查询选择</td></tr><tr><td>点餐-购物车</td><td>用户选中的菜品就会加入用户的购物车, 主要包含 查询购物车、加入购物车、删除购物车、清空购物车等功能</td></tr><tr><td>订单支付</td><td>用户选完菜品&#x2F;套餐后, 可以对购物车菜品进行结算支付, 这时就需要进行订单的支付</td></tr><tr><td>个人信息</td><td>在个人中心页面中会展示当前用户的基本信息, 用户可以管理收货地址, 也可以查询历史订单数据</td></tr></tbody></table><h3 id="2-3-技术选型"><a href="#2-3-技术选型" class="headerlink" title="2.3 技术选型"></a>2.3 技术选型</h3><p>关于本项目的技术选型, 我们将会从 用户层、网关层、应用层、数据层 这几个方面进行介绍，而对于我们服务端开发工程师来说，在项目开发过程中，我们主要关注应用层及数据层技术的应用。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401261.png" alt="image-20210726005437857"> </p><p><strong>1). 用户层</strong></p><p>本项目中在构建系统管理后台的前端页面，我们会用到H5、Vue.js、ElementUI等技术。而在构建移动端应用时，我们会使用到微信小程序。</p><p><strong>2). 网关层</strong></p><p>Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高。在Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现。</p><p><strong>3). 应用层</strong></p><p>SpringBoot： 快速构建Spring项目, 采用 “约定优于配置” 的思想, 简化Spring项目的配置开发。</p><p>Spring: 统一管理项目中的各种资源(bean), 在web开发的各层中都会用到。</p><p>SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成。</p><p>SpringSession: 主要解决在集群环境下的Session共享问题。</p><p>lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter&#x2F;setter，也许还要去写构造器、equals等方法。</p><p>Swagger： 可以自动的帮助开发人员生成接口文档，并对接口进行测试。</p><p><strong>4). 数据层</strong></p><p>MySQL： 关系型数据库, 本项目的核心业务数据都会采用MySQL进行存储。</p><p>MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发, 基本的单表增删改查直接调用框架提供的方法即可。</p><p>Redis： 基于key-value格式存储的内存数据库, 访问速度快, 经常使用它做缓存(降低数据库访问压力, 提供访问效率), 在后面的性能优化中会使用。</p><p><strong>5). 工具</strong></p><p>git: 版本控制工具, 在团队协作中, 使用该工具对项目中的代码进行管理。</p><p>maven: 项目构建工具。</p><p>junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试。</p><h3 id="2-4-功能架构"><a href="#2-4-功能架构" class="headerlink" title="2.4 功能架构"></a>2.4 功能架构</h3><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401677.png" alt="image-20210726122825225" style="zoom:80%;" /> <p><strong>1). 移动端前台功能</strong></p><p>手机号登录 , 微信登录 , 收件人地址管理 , 用户历史订单查询 , 菜品规格查询 , 购物车功能 , 下单 , 分类及菜品浏览。</p><p><strong>2). 系统管理后台功能</strong></p><p>员工登录&#x2F;退出 , 员工信息管理 , 分类管理 , 菜品管理 , 套餐管理 , 菜品口味管理 , 订单管理 。</p><h3 id="2-5-角色"><a href="#2-5-角色" class="headerlink" title="2.5 角色"></a>2.5 角色</h3><p>在瑞吉外卖这个项目中，存在以下三种用户，这三种用户对应三个角色： 后台系统管理员、后台系统普通员工、C端(移动端)用户。</p><table><thead><tr><th>角色</th><th>权限操作</th></tr></thead><tbody><tr><td>后台系统管理员</td><td>登录后台管理系统，拥有后台系统中的所有操作权限</td></tr><tr><td>后台系统普通员工</td><td>登录后台管理系统，对菜品、套餐、订单等进行管理 (不包含员工管理)</td></tr><tr><td>C端用户</td><td>登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等</td></tr></tbody></table><h2 id="3-开发环境搭建"><a href="#3-开发环境搭建" class="headerlink" title="3. 开发环境搭建"></a>3. 开发环境搭建</h2><h3 id="3-1-数据库环境搭建"><a href="#3-1-数据库环境搭建" class="headerlink" title="3.1 数据库环境搭建"></a>3.1 数据库环境搭建</h3><h4 id="3-1-1-创建数据库"><a href="#3-1-1-创建数据库" class="headerlink" title="3.1.1 创建数据库"></a>3.1.1 创建数据库</h4><p>可以通过以下两种方式中的任意一种, 来创建项目的数据库:</p><p><strong>1).图形界面</strong></p><p>创建连接</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032234141.png" alt="image-20230403223356653"></p><p>新建数据库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032235755.png" alt="image-20230403223507461"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401413.png" alt="image-20210726123903694" style="zoom:80%;" /> <p>注意: 本项目数据库的字符串, 选择 utf8mb4</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032237124.png" alt="image-20230403223714409"></p><p><strong>2).命令行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401021.png" alt="image-20210726123942443"> </p><h4 id="3-1-2-数据库表导入"><a href="#3-1-2-数据库表导入" class="headerlink" title="3.1.2 数据库表导入"></a>3.1.2 数据库表导入</h4><p>项目的数据库创建好了之后, 可以直接将 资料&#x2F;数据模型&#x2F;db_reggie.sql 直接导入到数据库中, 也可以通过两种方式实现:</p><p><strong>1).图形界面</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401797.png" alt="image-20210726124752975"> </p><p>刷新</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032340176.png" alt="image-20230403231215153"></p><p><strong>2).命令行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401510.png" alt="image-20210726124818880"> </p><blockquote><p><strong><font color='red'>注意:</font></strong> 通过命令导入表结构时，注意sql文件不要放在中文目录中</p></blockquote><h4 id="3-1-3-数据库表介绍"><a href="#3-1-3-数据库表介绍" class="headerlink" title="3.1.3 数据库表介绍"></a>3.1.3 数据库表介绍</h4><p>数据库表导入之后, 接下来介绍一下本项目中所涉及到的表结构: </p><table><thead><tr><th><strong>序号</strong></th><th><strong>表名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1</td><td>employee</td><td>员工表</td></tr><tr><td>2</td><td>category</td><td>菜品和套餐分类表</td></tr><tr><td>3</td><td>dish</td><td>菜品表</td></tr><tr><td>4</td><td>setmeal</td><td>套餐表</td></tr><tr><td>5</td><td>setmeal_dish</td><td>套餐菜品关系表</td></tr><tr><td>6</td><td>dish_flavor</td><td>菜品口味关系表</td></tr><tr><td>7</td><td>user</td><td>用户表（C端）</td></tr><tr><td>8</td><td>address_book</td><td>地址簿表</td></tr><tr><td>9</td><td>shopping_cart</td><td>购物车表</td></tr><tr><td>10</td><td>orders</td><td>订单表</td></tr><tr><td>11</td><td>order_detail</td><td>订单明细表</td></tr></tbody></table><p>上述的表结构, 我们目前先简单的结合页面原型了解一下, 大概有那些表, 每张表结构中存储什么样的数据, 有一个印象。对于具体的表结构, 以及表结构中的字段, 在讲解具体的功能开发时, 我们再详细介绍。</p><h3 id="3-2-Maven项目搭建"><a href="#3-2-Maven项目搭建" class="headerlink" title="3.2 Maven项目搭建"></a>3.2 Maven项目搭建</h3><h4 id="3-2-1-创建maven项目"><a href="#3-2-1-创建maven项目" class="headerlink" title="3.2.1 创建maven项目"></a>3.2.1 创建maven项目</h4><p><strong>1). 在idea中创建maven project, 项目名称 reggie_take_out</strong> </p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401782.png" alt="image-20210726172842675" style="zoom:80%;" /> <p><strong>2). 检查项目编码</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031401213.png" alt="image-20210726173036263" style="zoom:80%;" /> <p><strong>3). 检查maven配置</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031402301.png" alt="image-20210726173116359" style="zoom:80%;" /> <p><strong>4). 检查JDK版本</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031402397.png" alt="image-20210726173237154" style="zoom:80%;" /> <p>JDK的版本选择1.8;</p><p>视频笔记：</p><p>新建项目</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032341650.png" alt="image-20230403232519512"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032341570.png" alt="image-20230403232710102"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032341130.png" alt="image-20230403233350678"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032351122.png" alt="image-20230403235041366"></p><p>检查</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032351441.png" alt="image-20230403234543066"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032351336.png" alt="image-20230403234705173"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032352561.png" alt="image-20230403234750760"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304032352401.png" alt="image-20230403235002396"></p><h4 id="3-2-2-搭建基础环境"><a href="#3-2-2-搭建基础环境" class="headerlink" title="3.2.2 搭建基础环境"></a>3.2.2 搭建基础环境</h4><p>1).在pom.xml中导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reggie_take_out<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2).在工程的resources目录下创建application.yml文件,并引入配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">#应用的名称，可选</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">reggie_take_out</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># address_book(表名)  -----&gt; AddressBook(实体类名)</span></span><br><span class="line">    <span class="comment"># user_name(表名)------&gt; userName(实体类名)</span></span><br><span class="line">    <span class="comment">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">ASSIGN_ID</span>   <span class="comment">#主健生成策略</span></span><br></pre></td></tr></table></figure><p>3).创建包 com.itheima.reggie , 并编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReggieApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(ReggieApplication.class, args);</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;项目启动成功...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304040127441.png" alt="image-20230404012656884"></p><p>补充笔记：</p><p>安装快速生成yml和main启动类的插件JBL SpringbootAppGen</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304040059725.png" alt="image-20230404005927482"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304040128218.png" alt="image-20230404010000343"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304040128095.png" alt="image-20230404010130359"></p><blockquote><p>@Slf4j : </p><p>​是lombok中提供的注解, 用来通过slf4j记录日志。</p><p>这边要注意 如果当lon,info没有起到作用的时候   可以检查lombok插件有没有安装 如果没有安装 就先安装 lombok插件</p></blockquote><p>当搭建完上述的基础环境之后, 就可以通过引导类, 启动该项目。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304040128800.png" alt="image-20230404012832294"></p><h4 id="3-2-3-前端静态资源导入"><a href="#3-2-3-前端静态资源导入" class="headerlink" title="3.2.3 前端静态资源导入"></a>3.2.3 前端静态资源导入</h4><p>我们作为服务端开发工程师， 我们课程学习的重心应该放在后端的业务代码上， 前端的页面我们只需要导入课程资料中的前端资源， 前端页面的代码我们只需要能看懂即可。</p><p><strong>1). 导入静态资源</strong></p><p>前端资源存放位置为  资料&#x2F;前端资源 : <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031402621.png" alt="image-20210726225948411" style="zoom:80%;" /> </p><p>将上述两个目录中的静态资源文件, 导入到项目的resources目录下: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031402669.png" alt="image-20210726230327313"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304040152095.png" alt="image-20230404015234308"></p><p><strong>2). 创建配置类WebMvcConfig，设置静态资源映射</strong></p><p>用于在Springboot项目中, 默认静态资源的存放目录为 :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> ; </span><br></pre></td></tr></table></figure><p>而在我们的项目中静态资源存放在 backend, front 目录中, 那么这个时候要想访问到静态资源, 就需要设置静态资源映射。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042145090.png" alt="image-20230404205522050"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042145195.png" alt="image-20230404205616203"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042145042.png" alt="image-20230404205954857"></p><p>这个方法传进来一个参数叫做registry    然后我们直接使用registry来设置我们要访问的路径  对于这此访问路径映射到哪些资源路径</p><p>所以我们就可以通过registry调用addResourceHandler(); </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addResourceHandler();</span><br></pre></td></tr></table></figure><p>addResourceHandler():资源处理器</p><p>代码解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.addResourceHandler(&quot;/backend/**&quot;).addResourceLocations(&quot;classpath:/backend/&quot;);</span><br></pre></td></tr></table></figure><p>classpath:指的是在resources文件下面</p><p>解释：</p><p>这段代码是用来配置 Spring Web 应用程序中资源处理器的，它的作用是将 “&#x2F;backend&#x2F;“ 开头的所有 URL 请求映射到应用程序中的某个资源位置。</p><p>具体来说，它通过 ResourceHandlerRegistry 对象将 “&#x2F;backend&#x2F;**” 映射到 “classpath:&#x2F;backend&#x2F;“ 目录下的所有资源。这意味着，当用户访问以 “&#x2F;backend&#x2F;“ 开头的 URL 时，Spring 应用程序将查找该目录下的所有资源，并返回这些资源的 HTML 页面或其他响应。</p><p>同时，该代码还将 “classpath:&#x2F;backend&#x2F;“ 目录下的所有资源映射到 &#x2F;backend&#x2F; 目录下。这意味着，当用户访问 &#x2F;backend&#x2F; 目录下的 URL 时，Spring 应用程序将查找该目录下的所有资源，并返回这些资源的 HTML 页面或其他响应。</p><p>总之，这段代码的作用是将 Spring Web 应用程序中资源处理器的配置信息添加到应用程序上下文中，以便处理以 “&#x2F;backend&#x2F;“ 开头的所有 URL 请求。</p><p>简单来说  如果看到backend  就找resources文件文件下面的资源</p><p>代码解释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry.addResourceHandler(&quot;/front/**&quot;).addResourceLocations(&quot;classpath:/front/&quot;);</span><br></pre></td></tr></table></figure><p>解释</p><p>这段代码是用来配置 Spring Web 应用程序的资源处理器，以便处理所有以 “&#x2F;front&#x2F;“ 开头的 URL 请求。</p><p>具体来说，代码中使用了 Spring 的 ResourceHandlerRegistry 对象来配置资源处理器。registry 对象表示一个 ResourceHandlerRegistry 实例，它管理着所有资源处理器的注册。</p><p>addResourceHandler() 方法用于添加资源处理器，该方法接受一个字符串参数，表示要处理的请求路径。在这里，该方法将 &#x2F;front&#x2F;** 映射到 classpath:&#x2F;front&#x2F; 目录下的所有资源。&#x2F;** 表示匹配所有子目录和文件。</p><p>addResourceLocations() 方法用于指定资源位置，该方法也接受一个字符串参数，表示要映射的资源位置。在这里，该方法将 classpath:&#x2F;front&#x2F; 目录下的所有资源映射到 &#x2F;front&#x2F; 目录下。</p><p>因此，这段代码的作用是将一个资源处理器注册到 Spring 应用程序上下文中，以处理以 &#x2F;front&#x2F; 开头的所有 URL 请求，并将这些请求映射到 classpath:&#x2F;front&#x2F; 目录下的所有资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.config;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//表示他是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 设置静态资源映射</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始进行静态资源映射...&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/backend/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/front/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/front/&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042145850.png" alt="image-20230404212437877"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042145546.png" alt="image-20230404212908928"></p><p><strong>3). 访问测试</strong></p><p><a href="http://localhost:8080/backend/index.html">http://localhost:8080/backend/index.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031402973.png" alt="image-20210726232859596"> </p><h2 id="4-后台系统登录功能"><a href="#4-后台系统登录功能" class="headerlink" title="4. 后台系统登录功能"></a>4. 后台系统登录功能</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p><strong>1). 页面原型展示</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031402765.png" alt="image-20210726233540703" style="zoom: 67%;" />   <p><strong>2). 登录页面成品展示</strong></p><p>登录页面存放目录 &#x2F;resources&#x2F;backend&#x2F;page&#x2F;login&#x2F;login.html</p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031402878.png" alt="image-20210726233631409" style="zoom:80%;" /> <p><strong>3). 查看登录请求</strong></p><p>通过浏览器调试工具（F12） 先打开F12</p><p>可以发现点击登录按钮时，页面会发送请求（请求地址为<a href="http://localhost:8080/employee/login%EF%BC%89%E5%B9%B6%E6%8F%90%E4%BA%A4%E5%8F%82%E6%95%B0">http://localhost:8080/employee/login）并提交参数</a> username和password, 请求参数为json格式数据 {“username”:”admin”,”password”:”123456”}。</p><p>第一步：</p><p>输入地址：<a href="http://localhost:8080/backend/page/login/login.html">http://localhost:8080/backend/page/login/login.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042206628.png" alt="image-20230404215752337"></p><p>第二步   打开F12</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042206495.png" alt="image-20230404215823044"></p><p>第三步    点击登录 </p><p>账号：admin</p><p>密码：123456</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042205238.png" alt="image-20230404215932404"></p><p>第四步  </p><p>页面会发送请求 并提交参数 username和password, 请求参数为json格式数据 {“username”:”admin”,”password”:”123456”}。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042206583.png" alt="image-20230404220357426"></p><p>请求地址为<a href="http://localhost:8080/employee/login">http://localhost:8080/employee/login</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042206470.png" alt="image-20230404220427555"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031403789.png" alt="image-20210726234439684"> </p><blockquote><p>此时报404，是因为我们的后台系统还没有响应此请求的处理器，所以我们需要创建相关类来处理登录请求 ；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042205855.png" alt="image-20230404220537022"></p><p><strong>4). 数据模型(employee表)</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031403469.png" alt="image-20210726234915737" style="zoom:80%;" /> <p><strong>5). 前端页面分析</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304042210952.png" alt="image-20230404221048319"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031403285.png" alt="image-20210727000040403"> </p><p>当点击 “登录” 按钮, 会触发Vue中定义的 handleLogin 方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   new Vue(&#123;</span><br><span class="line">     el: &#x27;#login-app&#x27;,</span><br><span class="line">     data() &#123;</span><br><span class="line">       return &#123;</span><br><span class="line">         loginForm:&#123;</span><br><span class="line">           username: &#x27;admin&#x27;,</span><br><span class="line">           password: &#x27;123456&#x27;</span><br><span class="line">         &#125;,</span><br><span class="line">         loading: false</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     computed: &#123;</span><br><span class="line">       loginRules() &#123;</span><br><span class="line">         const validateUsername = (rule, value, callback) =&gt; &#123;</span><br><span class="line">           if (value.length &lt; 1 ) &#123;</span><br><span class="line">             callback(new Error(&#x27;请输入用户名&#x27;))</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             callback()</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         const validatePassword = (rule, value, callback) =&gt; &#123;</span><br><span class="line">           if (value.length &lt; 6) &#123;</span><br><span class="line">             callback(new Error(&#x27;密码必须在6位以上&#x27;))</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             callback()</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return &#123;</span><br><span class="line">           &#x27;username&#x27;: [&#123; &#x27;validator&#x27;: validateUsername, &#x27;trigger&#x27;: &#x27;blur&#x27; &#125;],</span><br><span class="line">           &#x27;password&#x27;: [&#123; &#x27;validator&#x27;: validatePassword, &#x27;trigger&#x27;: &#x27;blur&#x27; &#125;]</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     created() &#123;</span><br><span class="line">     &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">       async handleLogin() &#123;</span><br><span class="line">         this.$refs.loginForm.validate(async (valid) =&gt; &#123;</span><br><span class="line">           if (valid) &#123;</span><br><span class="line">             this.loading = true</span><br><span class="line">             let res = await loginApi(this.loginForm)</span><br><span class="line">             if (String(res.code) === &#x27;1&#x27;) &#123;</span><br><span class="line">               localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify(res.data))</span><br><span class="line">               window.location.href= &#x27;/backend/index.html&#x27;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">               this.$message.error(res.msg)</span><br><span class="line">               this.loading = false</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050046133.png" alt="image-20230404221555662"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050050022.png" alt="image-20230404221314991"></p><p>到达handleLogin（）方法之后 先找到表单 然后调用validate（）进行表单检验 主要检验我们的用户名和密码是否为空，</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050047556.png" alt="image-20230404222044648"></p><p>如果检验通过后 我们就把loading改成true </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050054811.png" alt="image-20230404222811982"></p><p>这个时候</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050047468.png" alt="image-20230404223212456"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050054868.png" alt="image-20230404222457072"></p><p>【this.loading &#x3D; true】 当把loading改成true 时    就一直属于登录中    如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050043549.png" alt="image-20230404222946571"></p><p>重点在于如果检验通过之后 就会调用<em>loginApi（） 这个方法关联在login.js里面 我们鼠标放在loginApi（）上 按住Ctrl+左健 就可以跳转到如下页面</em></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050043845.png" alt="image-20230404223324931"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050043548.png" alt="image-20230404223350751"></p><p>通过axios向我们的后端发送请求   我们的请求是’url’: ‘&#x2F;employee&#x2F;login’,    而且是一个post请求   </p><p>通过F12我们也可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050043140.png" alt="image-20230404223642806"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function loginApi(data) &#123;</span><br><span class="line">  return $axios(&#123;</span><br><span class="line">    &#x27;url&#x27;: &#x27;/employee/login&#x27;,</span><br><span class="line">    &#x27;method&#x27;: &#x27;post&#x27;,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function logoutApi()&#123;</span><br><span class="line">  return $axios(&#123;</span><br><span class="line">    &#x27;url&#x27;: &#x27;/employee/logout&#x27;,</span><br><span class="line">    &#x27;method&#x27;: &#x27;post&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        async handleLogin() &#123;</span><br><span class="line">          this.$refs.loginForm.validate(async (valid) =&gt; &#123;</span><br><span class="line">            if (valid) &#123;</span><br><span class="line">              this.loading = true</span><br><span class="line">              let res = await loginApi(this.loginForm)</span><br><span class="line">              if (String(res.code) === &#x27;1&#x27;) &#123;   //1表示登录成功</span><br><span class="line">                localStorage.setItem(&#x27;userInfo&#x27;,JSON.stringify(res.data))</span><br><span class="line">                window.location.href= &#x27;/backend/index.html&#x27;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                this.$message.error(res.msg)</span><br><span class="line">                this.loading = false</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>通过axios向我们的后端服务来发送请求 请求为’&#x2F;employee&#x2F;login’ 是一个’post’, 并且把数据 data带过来 这个数据就是我们的loginForm loginForm里面话的就是我们的用户名和密码 这个时候我们的请求就发出去了 请求发出去之后 如果我们的服务端接收到请求 就要在服务端进行相对应的处理 处理完之后 在给前端页面 一个响应的结果 而这个就是通过res来进行接收（ let res &#x3D; await loginApi(this.loginForm)） 接收好后 我们在进行判断 如果 String(res.code) &#x3D;&#x3D;&#x3D; ‘1’ 如果等于1 就表示登录成功 当登录成功之后 将数据转换成JSON 然后保存在浏览器中（存储在客户端的 localStorage 中）（通过k-v的方式转成JSDN）localStorage.setItem(‘userInfo’,JSON.stringify(res.data)) 然后在做页面跳转 跳转的页面为’&#x2F;backend&#x2F;index.html’【 window.location.href&#x3D; ‘&#x2F;backend&#x2F;index.html’】 跳转到如下页面</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050043556.png" alt="image-20230404224218623"></p><p>如果登录失败 也就是说String(res.code) ！&#x3D; ‘1’ 会提供一个错误信息 this.$message.error(res.msg)</p><p>然后把loading 改成 【falseloading &#x3D; false】 这个时候我们的前端页面又会变成登录按钮 如下图所示</p><p>这个时候 我们就可以在重新登录<br><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050043551.png" alt="image-20230404224405620"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031403310.png" alt="image-20210727000329958" style="zoom:80%;" /> <p>在上述的前端代码中, 大家可以看到, 发送登录的异步请求之后, 获取到响应结果, 在响应结果中至少包含三个属性: code、data、msg 。</p><p>从响应返回结果里面获取到的值 在响应结果中至少包含三个属性: code、data、msg 。</p><p>也就是说 要求我们服务端处理完之后 数据里面应该要有code、data、msg 并且是JSON的形式 这样前端页面才能获取到</p><p>由前端代码，我们也可以看到，在用户登录成功之后，服务端会返回用户信息，而前端是将这些用户信息，存储在客户端的 localStorage 中了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;userInfo&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res.<span class="property">data</span>))</span><br></pre></td></tr></table></figure><h3 id="4-2-代码开发"><a href="#4-2-代码开发" class="headerlink" title="4.2 代码开发"></a>4.2 代码开发</h3><h4 id="4-2-1-基础准备工作"><a href="#4-2-1-基础准备工作" class="headerlink" title="4.2.1 基础准备工作"></a>4.2.1 基础准备工作</h4><p>在进行登录功能的代码实现之前， 首先在我们的工程下创建包结构： </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031403158.png" alt="image-20210727001117783"> </p><p><strong>1). 创建实体类Employee</strong></p><p>该实体类主要用于和员工表 employee 进行映射。 该实体类， 也可以直接从资料( 资料&#x2F;实体类 )中拷贝工程中。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304050009615.png" alt="image-20230404224957190"></p><p>所属包: com.itheima.reggie.entity</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String idNumber; <span class="comment">//驼峰命名法 ---&gt; 映射的字段名为 id_number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>实体类和表的名称不同 要开启驼峰命名法</p><p>实体类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> private String idNumber;   //驼峰命名法 ---&gt; 映射的字段名为 id_number</span><br><span class="line">private LocalDateTime createTime;</span><br><span class="line">private LocalDateTime updateTime;</span><br></pre></td></tr></table></figure><p>数据库中的表</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304061338379.png" alt="image-20230406133751220"></p><p>这个时候要开启驼峰命名</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304061339564.png" alt="image-20230406133826963"></p><p><strong>2). 定义Mapper接口</strong></p><p>在MybatisPlus中, 自定义的Mapper接口, 需要继承自 BaseMapper。</p><p>所属包: com.itheima.reggie.mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Employee;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span>   <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Employee&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304061358550.png" alt="image-20230406135848982"></p><p>注解理解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java中的Mapper接口中@Mappe注解的理解</span><br></pre></td></tr></table></figure><p>在Java中，Mapper接口主要用于MyBatis框架，用来定义与数据库交互的方法。@Mapper注解在MyBatis框架中用于标识这个接口为一个Mapper接口，以便MyBatis在启动时能够自动扫描并加载这个接口。在MyBatis中，我们使用这些Mapper接口与数据库进行交互，以实现SQL查询、插入、更新和删除等操作。</p><p>@Mapper注解的作用如下：</p><ol><li>标识接口：使用@Mapper注解可以明确地表示这个接口是一个MyBatis的Mapper接口，使得其他开发者更容易理解这个接口的用途。</li><li>自动扫描与加载：当你在应用中使用MyBatis时，你需要让MyBatis知道哪些接口是Mapper接口。通过在接口上添加@Mapper注解，MyBatis在启动时会自动扫描并加载这些接口。</li><li>生成Mapper代理对象：当MyBatis加载了@Mapper注解的接口后，它会为这些接口生成代理对象。这些代理对象负责将接口方法与相应的SQL语句关联起来，从而实现数据库操作。</li><li>简化配置：在MyBatis的早期版本中，你需要在XML配置文件中显式地声明Mapper接口与对应的SQL映射文件。但是通过使用@Mapper注解，你可以省略这些显式声明，使配置更简洁。</li></ol><p>需要注意的是，使用@Mapper注解的Mapper接口通常需要与一个XML映射文件关联。这个映射文件包含了接口方法与相应的SQL语句之间的映射关系。映射文件的命名和位置要与Mapper接口保持一致，以便MyBatis能够正确地找到并加载它们。</p><p>此外，还可以使用@MapperScan注解来扫描特定包路径下的所有@Mapper注解的接口，这样就不需要在每个接口上都添加@Mapper注解。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java中的MyBatisPlus 中的Mapper接口中@Mappe注解的理解</span><br></pre></td></tr></table></figure><p>MyBatisPlus（简称MP）是一个在MyBatis基础上进行扩展的框架，提供了许多方便实用的功能，如通用Mapper、通用Service等。在MyBatisPlus中，Mapper接口依然是用于定义与数据库交互的方法，但在MyBatisPlus中通常会继承自BaseMapper接口，从而自动获得一些通用的数据库操作方法。</p><p>在MyBatisPlus中，@Mapper注解的作用与MyBatis中的@Mapper注解相似，但有一些区别：</p><ol><li>在MyBatisPlus中，使用@Mapper注解标识的接口通常继承自BaseMapper接口。BaseMapper接口为用户提供了一些通用的CRUD操作方法，如selectById、insert、update等。这些方法可以满足大部分简单的数据库操作需求，从而减少了开发者需要手动编写的SQL语句数量。</li><li>MyBatisPlus中的@Mapper注解仍然负责标识接口、自动扫描与加载、生成Mapper代理对象等功能。在某些情况下，你可能需要自定义Mapper接口中的方法，此时你可以在接口中添加自定义方法，并在对应的XML映射文件中编写相应的SQL语句。</li><li>MyBatisPlus还提供了一些额外的注解，如@Table、@TableId等，这些注解可以用于实体类的字段与数据库表中的列之间的映射关系。通过这些注解，MyBatisPlus可以更智能地处理数据库操作，从而减少了手动编写SQL语句的需求。</li><li>与MyBatis中的@MapperScan注解类似，MyBatisPlus中也提供了@MapperScan注解。你可以使用@MapperScan注解来指定需要扫描的包路径，从而自动加载该包路径下的所有@Mapper注解的接口。</li></ol><p>综上所述，MyBatisPlus中的@Mapper注解仍然用于标识Mapper接口，但与MyBatis中的@Mapper注解相比，MyBatisPlus中的@Mapper注解更侧重于与BaseMapper接口的结合，以实现更高效的数据库操作。</p><p><strong>3).Service接口</strong></p><p>本项目的Service接口, 在定义时需要继承自MybatisPlus提供的Service层接口 IService, 这样就可以直接调用 父接口的方法直接执行业务操作, 简化业务层代码实现。</p><p>所属包: com.itheima.reggie.service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeService</span>   <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Employee&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304081430659.png" alt="image-20230406140157189"></p><p><strong>4). Service实现类</strong></p><p>所属包: com.itheima.reggie.service.impl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.Service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.Mapper.EmployeeMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.Service.EmployeeService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>  <span class="comment">//交给spring管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;EmployeeMapper, Employee&gt; <span class="keyword">implements</span> <span class="title class_">EmployeeService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304062115578.png" alt="image-20230406211455903"></p><p><strong>5). Controller基础代码</strong></p><p>所属包: com.itheima.reggie.controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.Service.EmployeeService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304062120161.png" alt="image-20230406211953366"></p><p>解释注解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController注解的使用 </span><br></pre></td></tr></table></figure><p><code>@RestController</code> 注解是 Spring 框架中用于标记 RESTful API 控制器的重要注解之一。这个注解可以让我们将一个普通的 Java 类标记为 Spring MVC 的控制器，以便 Spring 能够自动注入一个 <code>RequestMappingHandlerMapping</code> 对象，将请求 URL 和控制器方法之间的映射关系弄清楚。</p><p>具体来说，使用 <code>@RestController</code> 注解标记的控制器类将会被 Spring MVC 自动注入一个 <code>RequestMappingHandlerMapping</code> 对象，这个对象可以帮助我们将请求 URL 和控制器方法映射起来，使得我们能够快速响应不同的请求方式。</p><p>举个例子，假设我们有一个 <code>PersonController</code> 类，它使用 <code>@RestController</code> 注解标记。如果我们向这个控制器类发送一个 GET 请求，Spring 将会把这个请求映射到 <code>person/&#123;id&#125;</code> 方法上，而这个方法是 <code>@GetMapping</code> 注解指定的。如果我们发送一个 POST 请求，Spring 将会把这个请求映射到 <code>person/&#123;id&#125;</code> 方法上，而这个方法是 <code>@PostMapping</code> 注解指定的。</p><p>总之，<code>@RestController</code> 注解可以帮助我们方便地构建 Spring MVC 中的 RESTful API，因为它可以自动注入一个 <code>RequestMappingHandlerMapping</code> 对象，从而简化控制器类的编写，同时也提供了一些预定义的映射关系，使得我们能够更加快速地响应不同的请求方式。</p><p>代码解释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/employee&quot;)</span><br><span class="line">public class EmployeeController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个名为 EmployeeController 的 Java 类，它具有以下注解:</p><ul><li>@Slf4j:这是一个注解，用于指示 Java 类应该使用 slf4j 作为日志实现。slf4j 是一种流行的日志库，它支持多种日志输出方式，例如日志输出到控制台、日志输出到文件、日志输出到 Splunk 等等。</li><li>@RestController:这是一个注解，用于指示这个类是一个 RestController，它代表了一种 Web 应用的基本组件，用于处理 HTTP 请求。</li><li>@RequestMapping(“&#x2F;employee”):这是一个注解，用于指示这个类处理以&#x2F;employee 开头的 HTTP 请求。@RequestMapping 注解可以用于处理 URL 映射，将请求映射到 Java 类中的具体方法上。</li></ul><p>接下来，我们来解释 EmployeeController 类中的一些成员变量和方法:</p><ul><li>@Autowired:这是一个注解，用于指示 Spring 容器应该自动注入一个依赖。在这个例子中，employeeService 是一个依赖，它由 Spring 容器注入。</li><li>private EmployeeService employeeService:这是一个私有成员变量，它表示一个 EmployeeService 对象。EmployeeService 是一个接口，它定义了处理 Employee 对象的业务逻辑。在这个例子中，我们使用 Spring 的注入功能，将一个实现了 EmployeeService 接口的实现注入到 EmployeeController 中。</li></ul><p>最后，EmployeeController 类中有一个@RequestMapping(“&#x2F;employee”) 注解修饰的方法，它代表处理以&#x2F;employee 开头的 HTTP 请求的方法。在这个例子中，这个方法应该处理以&#x2F;employee 开头的 HTTP 请求，并将请求参数传递给 EmployeeService 接口的相应方法。</p><p>这个代码片段是一个简单的 EmployeeController 类，它具有以下功能:</p><ol><li>处理 HTTP 请求：这个 EmployeeController 类被设计为处理 HTTP 请求的基本组件。我们可以看到它被注解为 @RestController，这意味着它是一个 Restful 控制器。它还被注解为 @RequestMapping(“&#x2F;employee”),这意味着它将处理以 &#x2F;employee 开头的 HTTP 请求。</li><li>自动注入依赖:EmployeeController 类中有一个私有成员变量 employeeService，它表示一个 EmployeeService 对象。这个对象由 Spring 容器自动注入。Spring 是一个流行的 Java 应用程序框架，它提供了一种简单、灵活的方式来管理应用程序中的依赖关系。</li><li>处理 HTTP 请求:EmployeeController 类中有一个处理 HTTP 请求的方法 @RequestMapping(“&#x2F;employee”)。这个方法将被 Spring 容器自动调用，以处理以 &#x2F;employee 开头的 HTTP 请求。在这个方法中，我们可以使用 @Autowired 注解来注入 EmployeeService 对象。</li><li>实现业务逻辑:EmployeeService 接口定义了处理 Employee 对象的业务逻辑。在这个例子中，我们将使用一个实现了 EmployeeService 接口的实现来处理 HTTP 请求。这个实现将通过 Spring 的注入功能被注入到 EmployeeController 类中。</li></ol><p>总之，这个代码片段是一个简单的 EmployeeController 类，它使用了 Spring 的注入功能以及 slf4j 日志库来处理 HTTP 请求。它处理以 &#x2F;employee 开头的 HTTP 请求，并将请求参数传递给 EmployeeService 接口的相应方法。</p><p><strong>6). 导入通用结果类R</strong></p><p>此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面。</p><p>后面我们要写很多的controller   controller也有很多方法 这些方法全都是响应我们客户端页面发过来的一些请求   然后controller处理完成之后 要给页面一个结果   而这个结果封装的话都统一把所有的返回结果全都封装成一个R对象  </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304062143501.png" alt="image-20230406214303168"></p><p>所属包: com.itheima.reggie.common</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通用返回结果，服务端响应的数据最终都会封装成此对象*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码：1成功，0和其它数字为失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//动态数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">success</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        R&lt;T&gt; r = <span class="keyword">new</span> <span class="title class_">R</span>&lt;T&gt;();</span><br><span class="line">        r.data = object;</span><br><span class="line">        r.code = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.msg = msg;</span><br><span class="line">        r.code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> R&lt;T&gt; <span class="title function_">add</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304072147875.png" alt="image-20230407214657911"></p><p>A. 如果业务执行结果为成功, 构建R对象时, 只需要调用 success 方法; 如果需要返回数据传递 object 参数, 如果无需返回, 可以直接传递null。</p><p>B. 如果业务执行结果为失败, 构建R对象时, 只需要调用error 方法, 传递错误提示信息即可。</p><h4 id="4-2-2-登录逻辑分析"><a href="#4-2-2-登录逻辑分析" class="headerlink" title="4.2.2 登录逻辑分析"></a>4.2.2 登录逻辑分析</h4><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031403910.png" alt="image-20210727003101031" style="zoom:80%;" /> <p>处理逻辑如下：</p><p>①. 将页面提交的密码password进行md5加密处理, 得到加密后的字符串</p><p>②. 根据页面提交的用户名username查询数据库中员工数据信息</p><p>③. 如果没有查询到, 则返回登录失败结果</p><p>④. 密码比对，如果不一致, 则返回登录失败结果</p><p>⑤. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果</p><p>⑥. 登录成功，将员工id存入Session, 并返回登录成功结果</p><h4 id="4-2-3-代码实现"><a href="#4-2-3-代码实现" class="headerlink" title="4.2.3 代码实现"></a>4.2.3 代码实现</h4><p><strong>技术点说明:</strong> </p><p>A. 由于需求分析时, 我们看到前端发起的请求为post请求, 所以服务端需要使用注解 @PostMapping</p><p>B. 由于前端传递的请求参数为json格式的数据, 这里使用Employee对象接收, 但是将json格式数据封装到实体类中, 在形参前需要加注解@RequestBody</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304072148264.png" alt="image-20230407214807409"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304072158631.png" alt="image-20230407215851106"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.Service.EmployeeService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.common.R;</span><br><span class="line"><span class="keyword">import</span> com.itheima.reggie.entity.Employee;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*员工登录*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;Employee&gt; <span class="title function_">login</span><span class="params">(HttpServletRequest request, <span class="meta">@RequestBody</span> Employee employee)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br></pre></td></tr></table></figure><p>国内镜像解释</p><p>这行代码创建了一个 LambdaQueryWrapper<Employee> 对象 queryWrapper。LambdaQueryWrapper 是一个用于执行 Lambda 表达式的查询 wrapper，它支持多个查询条件，并且可以自动执行聚合操作。</p><p>queryWrapper 的构造函数需要一个泛型参数 Employee，表示要查询的实体类型。它首先创建一个空的 LambdaQueryWrapper 对象，然后使用 new 关键字创建 LambdaQueryWrapper<Employee> 对象。这个对象将使用 Employee 类型来解析查询条件。</p><p>在 LambdaQueryWrapper 中，查询条件可以使用 Lambda 表达式来实现。在这种情况下，查询条件是一个 Employee 类型的变量，可以使用 Lambda 表达式来指定它。由于 LambdaQueryWrapper 支持多个查询条件，因此可以使用逗号分隔多个条件。例如，以下代码将返回所有名字包含 “Smith” 的 Employee 对象:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();  </span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Smith&quot;</span>);  </span><br><span class="line">List&lt;Employee&gt; employees = employeeDao.query(queryWrapper);  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，eq() 方法用于指定查询条件，这里使用了 “name” 和 “Smith” 两个查询条件，并且使用了逗号来分隔它们。employeeDao 是一个 EmployeeDao 的实现类，它实现了查询操作。在这个例子中，查询操作将使用 LambdaQueryWrapper 对象来执行。</p><p>gpt4解释</p><p>这行代码是在使用 Java 编程语言中的 MyBatis-Plus 查询构建器来创建一个查询条件封装对象。让我们一步步地分解这个代码行，以便更好地理解它：</p><ol><li>LambdaQueryWrapper：这是 MyBatis-Plus 提供的一个类，用于构建基于 Lambda 表达式的查询条件。这使得编写查询条件更加简洁和便捷。</li><li>Employee：这是一个 Java 类，通常用于表示数据库中的一个表。在这个例子中，它表示一个员工表。LambdaQueryWrapper 类使用泛型来确定它将操作哪个实体类，以便正确地映射表字段和 Java 类属性。在这个例子中，泛型参数是 Employee，表示这个查询构建器将用于构建针对 Employee 表的查询条件。</li><li>queryWrapper：这是一个变量名，表示我们创建的 LambdaQueryWrapper 实例。我们将用这个变量来操作查询条件。</li><li>new LambdaQueryWrapper&lt;&gt;()：这是使用 Java 的 new 关键字创建一个新的 LambdaQueryWrapper 实例。注意，尖括号（&lt;&gt;）内没有指定泛型类型。这是因为从 Java 7 开始，你可以使用所谓的 “钻石操作符” 来省略尖括号内的泛型类型。编译器会自动推断出正确的类型（在这个例子中，是 Employee）。</li></ol><p>总的来说，这行代码创建了一个新的 LambdaQueryWrapper 实例，用于构建针对 Employee 类（或者说，针对员工表）的查询条件。你可以通过在 queryWrapper 实例上调用各种方法来添加查询条件，例如 equalTo，like 等。最后，将 queryWrapper 实例传递给 MyBatis-Plus 提供的通用 Mapper 方法，例如 selectList，来执行查询并获取结果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queryWrapper.eq(Employee::getUsername,employee.getUsername());</span><br></pre></td></tr></table></figure><p>国内镜像</p><p>这段代码使用 QueryWrapper 类来创建查询条件，其中:</p><ul><li><code>queryWrapper</code> 是 QueryWrapper<Employee> 类的实例，它是一个用于编写 SQL 查询条件的自定义包装类。</li><li><code>eq</code> 方法用于编写等于条件，其中第一个参数是比较对象，第二个参数是要比较的值。在这个例子中，比较对象是 Employee 类的 <code>getUsername</code> 方法，它将返回 employee 对象的用户名。</li><li><code>Employee::getUsername</code> 是一个静态方法，它调用 Employee 类的 <code>getUsername</code> 方法并将返回值存储在 <code>eq</code> 方法的第二个参数中。这种方式可以使用类名和方法名来表示相等比较。</li><li><code>employee.getUsername()</code> 是获取 employee 对象的用户名的方法调用，它将存储在 <code>eq</code> 方法的第一个参数中，用于构建查询条件。</li></ul><p>因此，这段代码将创建一个查询条件，该条件将返回 employee 对象中具有相同用户名的行。这个查询条件将以 WHERE 子句的形式添加到 SQL 查询中，以便筛选 employee 表中的数据。</p><p>gpt4</p><p>这行代码是Java中的一段，它使用了一个名为queryWrapper的对象来构建一个查询条件。这段代码涉及到Lambda表达式和方法引用，可能在处理数据库查询时被用作过滤条件。</p><p>首先，让我们分解这个代码行：</p><ol><li><code>queryWrapper</code> 是一个对象，它的类型可能是一个泛型类，如 <code>QueryWrapper&lt;Employee&gt;</code>。这个类通常在MyBatis-Plus等ORM框架中用于构建查询条件。</li><li><code>.eq()</code> 是 <code>queryWrapper</code> 对象的一个方法，用于添加一个”等于”条件。这个方法需要两个参数：一个表示数据库字段的表达式，另一个表示字段值。</li><li><code>Employee::getUsername</code> 是一个方法引用，它指向 <code>Employee</code> 类中的 <code>getUsername</code> 方法。这里使用了Java的双冒号操作符（::），表示我们引用了该方法，而不是调用它。在这种情况下，它用于表示我们希望在数据库中查询的字段（即<code>username</code>）。</li><li><code>employee.getUsername()</code> 是一个方法调用，它获取了 <code>employee</code> 对象的 <code>username</code> 属性值。这个值将被用作过滤条件，即我们希望从数据库中查找具有相同 <code>username</code> 值的记录。</li></ol><p>综合起来，这行代码表示：在查询时，将 <code>Employee</code> 表中的 <code>username</code> 字段与给定 <code>employee</code> 对象的 <code>username</code> 属性值进行比较，查找具有相同 <code>username</code> 值的记录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Employee emp = employeeService.getOne(queryWrapper);</span><br></pre></td></tr></table></figure><p>这行代码 <code>Employee emp = employeeService.getOne(queryWrapper);</code> 涉及到两个对象:Employee 和 employeeService。</p><p>首先，<code>Employee</code> 是一个类，它表示一个 employee 对象。它是一个对象，因为它表示一个具体的数据实体。它可能包含用户名、密码、部门名称等等信息。</p><p><code>employeeService</code> 是一个对象，它表示一个服务层对象，它负责处理与数据库之间的通信。它可能包含一个查询方法 <code>getOne</code>,该方法接收一个 QueryWrapper 对象作为参数，该对象描述了查询条件。</p><p>查询方法是服务层对象中的常见方法之一，用于根据特定条件检索数据。在这个例子中，<code>getOne</code> 方法接收一个 QueryWrapper 对象作为参数，该对象描述了查询条件。QueryWrapper 对象是一个自定义的包装类，用于编写 SQL 查询条件。它提供了一些方法，例如 <code>eq</code> 用于编写等于条件，<code>ne</code> 用于编写不等于条件，等等。</p><p><code>getOne</code> 方法返回一个 Employee 对象，如果查询条件得到满足，就会返回该 Employee 对象。如果查询条件没有得到满足，则返回一个空对象。</p><p>因此，<code>Employee emp = employeeService.getOne(queryWrapper);</code> 表示要使用 <code>getOne</code> 方法检索一个满足查询条件的 Employee 对象，并将其存储在 <code>emp</code> 变量中。<code>queryWrapper</code> 变量是一个 QueryWrapper 对象的实例，它描述了查询条件。</p><p>git3.5</p><p>这段代码是在Java中使用了一种叫做对象导向编程（Object-Oriented Programming，简称OOP）的技术，用来创建一个名为“emp”的Employee类型的对象。</p><p>更具体地说，这段代码中：</p><ul><li>Employee是一个Java类，表示一个员工对象；</li><li>emp是一个变量名，可以被用来引用这个员工对象；</li><li>employeeService是一个服务类（Service），其中的getOne方法会根据传入的queryWrapper参数返回一个符合条件的Employee对象；</li><li>queryWrapper是一个查询包装器（QueryWrapper）对象，用来封装查询条件。</li></ul><p>简而言之，这段代码的作用是从一个服务类中获取符合某个条件的员工对象，并将其存储在一个变量中，以便于在后续的代码中使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//2、根据页面提交的用户名username查询数据库(MP的内容)</span><br><span class="line">      LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">      queryWrapper.eq(Employee::getUsername,employee.getUsername());</span><br><span class="line">      Employee emp = employeeService.getOne(queryWrapper);</span><br></pre></td></tr></table></figure><p>代码解释</p><p>这段代码使用了 Spring 框架中的 LambdaQueryWrapper 和 EmployeeService 两个类。LambdaQueryWrapper 是 Spring 提供的查询包装器类，可以将 Lambda 表达式包装在 Query 对象中，从而方便地实现查询操作。</p><p>具体解释如下:</p><ol><li>创建 LambdaQueryWrapper 对象。LambdaQueryWrapper 是一个查询包装器类，它允许在查询语句中使用 Lambda 表达式。这里使用了 new LambdaQueryWrapper&lt;&gt;(); 创建了一个 LambdaQueryWrapper 对象。</li><li>使用 LambdaQueryWrapper 对象编写查询语句。在查询语句中，使用了 eq() 方法来指定查询条件，其中 Employee::getUsername 是一个 Lambda 表达式，它表示获取 Employee 类的 getUsername() 方法返回的值。这里将 employee.getUsername() 的值作为查询条件。</li><li>使用 employeeService.getOne() 方法获取 Employee 对象。employeeService 是一个 EmployeeService 接口，它定义了获取 Employee 对象的方法 getOne()。这里使用了 getOne() 方法来获取 Employee 对象。</li></ol><p>总的来说，这段代码的作用是根据页面提交的用户名 username 查询数据库中的 Employee 对象，并将查询结果返回。其中 LambdaQueryWrapper 和 EmployeeService 是两个重要的类。</p><p>详细解释</p><p>我可以详细解释一下这段代码的含义和实现过程。</p><p>首先，这段代码涉及到三个对象:LambdaQueryWrapper、EmployeeService 和 Employee。LambdaQueryWrapper 是 Spring 框架中的查询包装器类，它允许在查询语句中使用 Lambda 表达式。EmployeeService 是一个 EmployeeService 接口，它定义了获取 Employee 对象的方法 getOne()。Employee 是数据库中的 Employee 对象。</p><p>这段代码的主要目的是根据页面提交的用户名 username 查询数据库中的 Employee 对象，并将查询结果返回。为了实现这个目的，代码中做了以下几件事情:</p><ol><li>创建 LambdaQueryWrapper 对象。LambdaQueryWrapper 是一个查询包装器类，它允许在查询语句中使用 Lambda 表达式。这里使用了 new LambdaQueryWrapper&lt;&gt;(); 创建了一个 LambdaQueryWrapper 对象。</li><li>使用 LambdaQueryWrapper 对象编写查询语句。在查询语句中，使用了 eq() 方法来指定查询条件。eq() 方法用于指定查询条件，它可以接受两个参数：一个字符串类型的参数，表示查询条件;另一个是 Lambda 表达式，表示查询条件的逻辑运算符。在这里，使用了 Employee::getUsername 表示获取 Employee 类的 getUsername() 方法返回的值，它将作为查询条件。</li><li>使用 employeeService.getOne() 方法获取 Employee 对象。employeeService 是一个 EmployeeService 接口，它定义了获取 Employee 对象的方法 getOne()。这里使用了 getOne() 方法来获取 Employee 对象。</li></ol><p>具体来说，代码的执行过程如下:</p><ol><li>用户在页面上提交了一个用户名 username。</li><li>页面跳转到登录页面，登录成功后返回主界面。</li><li>在主界面中，调用了 employeeService.getOne() 方法。</li><li>employeeService.getOne() 方法获取了一个 LambdaQueryWrapper 对象。</li><li>LambdaQueryWrapper 对象编写了查询语句，其中使用了 Employee::getUsername 表示获取 Employee 类的 getUsername() 方法返回的值，它将作为查询条件。</li><li>LambdaQueryWrapper 对象将查询条件包装在一个 Query 对象中，并返回给调用者。</li><li>调用者使用 employeeService.getOne() 方法获取 Employee 对象，并将查询结果返回给调用者。</li></ol><p>总的来说，这段代码实现了根据页面提交的用户名 username 查询数据库中的 Employee 对象，并将查询结果返回给调用者的功能。</p><p>为什么调用getOne方法 原因分析</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091351661.png" alt="image-20230409135115846"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091352400.png" alt="image-20230409135203115"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为什么调用getOne方法    加了唯一的约束</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.itheima.reggie.controller;</span><br><span class="line"></span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line">import com.itheima.reggie.Service.EmployeeService;</span><br><span class="line">import com.itheima.reggie.common.R;</span><br><span class="line">import com.itheima.reggie.entity.Employee;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.util.DigestUtils;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/employee&quot;)</span><br><span class="line">public class EmployeeController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*员工登录*/</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public R&lt;Employee&gt; login(HttpServletRequest request, @RequestBody Employee employee)&#123;</span><br><span class="line"></span><br><span class="line">        //1、将页面提交的密码password进行md5加密处理</span><br><span class="line">        //密码封装到employee对象里面去了 所以我们直接通过 employee.getPassword() 就可以获取到密码;</span><br><span class="line">        String password = employee.getPassword();</span><br><span class="line">        //用工具类进行md5加密  加密完重新赋值给 password</span><br><span class="line">        password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br><span class="line"></span><br><span class="line">        //2、根据页面提交的用户名username查询数据库(MP的内容)</span><br><span class="line">        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(Employee::getUsername,employee.getUsername());</span><br><span class="line">        Employee emp = employeeService.getOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">        //3、如果没有查询到则返回登录失败结果</span><br><span class="line">        if(emp == null)&#123;</span><br><span class="line">            return R.error(&quot;登录失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4、密码比对，如果不一致则返回登录失败结果</span><br><span class="line">        if(!emp.getPassword().equals(password))&#123;</span><br><span class="line">            return R.error(&quot;登录失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果</span><br><span class="line">        if(emp.getStatus() == 0)&#123;</span><br><span class="line">            return R.error(&quot;账号已禁用&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //6、登录成功，将员工id存入Session并返回登录成功结果</span><br><span class="line">        //setAttribute() ：保存数据</span><br><span class="line">        request.getSession().setAttribute(&quot;employee&quot;,emp.getId());</span><br><span class="line">        return R.success(emp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：LambdaQueryWrapper理解</p><p>MyBatisPlus官网：<a href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091359325.png" alt="image-20230409135941738"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091400361.png" alt="image-20230409140025059"></p><p>条件构造器：<a href="https://baomidou.com/pages/10c804/">https://baomidou.com/pages/10c804/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、根据页面提交的用户名username查询数据库(MP的内容)</span></span><br><span class="line">       LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">       queryWrapper.eq(Employee::getUsername,employee.getUsername());</span><br><span class="line">       <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> employeeService.getOne(queryWrapper);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    其中Employee::getUsername的意思就相当于：</span><br><span class="line"><span class="comment">//        1.1 实例化一个Employee对象</span></span><br><span class="line"><span class="comment">//        Employee employee = new employee;</span></span><br><span class="line"><span class="comment">//        1.2 调用对象Employee的get方法，这里调用的是getUsername:</span></span><br><span class="line"><span class="comment">//      employee.getUsername();</span></span><br><span class="line"><span class="comment">//        2.eq方法相当于赋值“=”</span></span><br></pre></td></tr></table></figure><p>根据员工用户名提交上来的名字去数据库里面去查找</p><p>QueryWrapper其他方法参考下图： 以下例子来自官网</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091404511.png" alt="image-20230409140358515"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091404895.png" alt="image-20230409140435281"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091405519.png" alt="image-20230409140510987"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091406056.png" alt="image-20230409140642598"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091407776.png" alt="image-20230409140709931"></p><p>其他的更多请查看官网</p><h3 id="4-3-功能测试"><a href="#4-3-功能测试" class="headerlink" title="4.3 功能测试"></a>4.3 功能测试</h3><p>代码实现完毕后, 启动项目, 访问url: <a href="http://localhost:8080/backend/page/login/login.html">http://localhost:8080/backend/page/login/login.html</a> , 进行登录测试。</p><p>在测试过程中， 可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各个对象的具体赋值情况。而且需要注意, 在测试过程中，需要将所有的情况都覆盖到。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091411033.png" alt="image-20230409141106699"></p><p>用Dug的方式启动</p><p>F12 刷新</p><p>我们输入一个错误的密码</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091706913.png" alt="image-20230409141152860"></p><p>然后我们来看一下数据的封装有没有问题</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091706462.png" alt="image-20230409141236268"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091706020.png" alt="image-20230409141258202"></p><p>一直F8到这里面</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091706821.png" alt="image-20230409141332946"></p><p>放行</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091706509.png" alt="image-20230409141359455"></p><p><strong>1). 问题说明</strong></p><p>当我们在进行debug端点调试时, 前端可能会出现如下问题: 前端页面的控制台报出错误-超时;</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091706325.png" alt="image-20230409141515789"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091422766.png" alt="image-20230409142209178"></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031404926.png" alt="image-20210727004455855" style="zoom:80%;" /> <p><strong>2). 解决方案</strong> </p><p>前端进行异步请求时, 默认超时10000ms , 可以将该值调大一些。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function (win) &#123;</span><br><span class="line">  axios.defaults.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=utf-8&#x27;</span><br><span class="line">  // 创建axios实例</span><br><span class="line">  const service = axios.create(&#123;</span><br><span class="line">    // axios中请求配置有baseURL选项，表示请求URL公共部分</span><br><span class="line">    baseURL: &#x27;/&#x27;,</span><br><span class="line">    // 超时</span><br><span class="line">    timeout: 10000</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031404269.png" alt="image-20210727004706639" style="zoom:80%;" /> <p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091452819.png" alt="image-20230409145213196"></p><p>现在我们把他的时间增长二个0</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091453146.png" alt="image-20230409145314288"></p><p>重新启动</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091459338.png" alt="image-20230409145918316"></p><p>重新Debug</p><p>刷新重新登录</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091742958.png" alt="image-20230409150004493"></p><p>F8调试后</p><p>放行</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091503043.png" alt="image-20230409150302982"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091741918.png" alt="image-20230409150546339"></p><p>如果跳转不过来  就清除一下浏览器的缓存</p><p>&#x3D;&#x3D;由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效。&#x3D;&#x3D;</p><p>因为我们的密码是正确 因为前端给了一个默认值 所以我们刷新后 就又重新默认密码是123456</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091741575.png" alt="image-20230409150806806"></p><p>这个时候我们就登录成功了</p><p>这时候我们可以来看一下我们的登录页面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">       async <span class="title function_">handleLogin</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.$refs.loginForm.validate(async (valid) =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">             <span class="built_in">this</span>.loading = <span class="literal">true</span></span><br><span class="line">             <span class="type">let</span> <span class="variable">res</span> <span class="operator">=</span> await <span class="title function_">loginApi</span><span class="params">(<span class="built_in">this</span>.loginForm)</span></span><br><span class="line">             <span class="keyword">if</span> (String(res.code) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">               localStorage.setItem(<span class="string">&#x27;userInfo&#x27;</span>,JSON.stringify(res.data))</span><br><span class="line">               window.location.href= <span class="string">&#x27;/backend/index.html&#x27;</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.$message.error(res.msg)</span><br><span class="line">               <span class="built_in">this</span>.loading = <span class="literal">false</span></span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>登录成功之后 调用了localStorage.setItem(‘userInfo’,JSON.stringify(res.data)) 然后把我们返回来的数据data给转换成JSON 然后写到浏览器里面 具体存放的位置如下图</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518537.png" alt="image-20230409150931197"></p><p>如果登录失败呢</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518212.png" alt="image-20230409151003997"></p><p>放行</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518827.png" alt="image-20230409151034020"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518673.png" alt="image-20230409151100487"></p><p>如果密码错误</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518442.png" alt="image-20230409151414169"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518021.png" alt="image-20230409151436692"></p><p>手动修改数据库</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518427.png" alt="image-20230409151521185"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091518316.png" alt="image-20230409151543715"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091517033.png" alt="image-20230409151606944"></p><p>注意：如果修改完成时间 还是超时时 就清除浏览器的缓存</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091517331.png" alt="image-20230409151704727"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091517131.png" alt="image-20230409151728298"></p><h2 id="5-后台系统退出功能"><a href="#5-后台系统退出功能" class="headerlink" title="5. 后台系统退出功能"></a>5. 后台系统退出功能</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><p>在后台管理系统中，管理员或者员工，登录进入系统之后，页面跳转到后台系统首页面(backend&#x2F;index.html)，此时会在系统的右上角显示当前登录用户的姓名。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091524421.png" alt="image-20230409152419870"></p><p>如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面。</p><p><strong>1). 退出页面展示</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031404829.png" alt="image-20210727005437531" style="zoom:80%;" /> <p>确认先来分析一下管理员三个字 是动态显示的还是固定写s的</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091741079.png" alt="image-20230409152537690"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091741784.png" alt="image-20230409152603245"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091741351.png" alt="image-20230409152625531"></p><p>是一个动态展示的</p><p>userInfo从哪里来呢 他其实是从我们的数据模型里面去拿</p><p>在我们VUE对象创建的时候 应该是准备了userInfo这样的一个数据 他应该从created()拿的 当VUE对象创建的时候 就会调用created()方法 userInfo是从 const userInfo &#x3D; window.localStorage.getItem(‘userInfo’)来的 把我们存的userInfo取出来 如果不等于空 就在数据模型里面添加了userInfo 所以拿出来之后 就可以在82行那里动态展示<div class="avatar-wrapper"></div></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">        const userInfo = window.localStorage.getItem(&#x27;userInfo&#x27;)</span><br><span class="line">        if (userInfo) &#123;</span><br><span class="line">          this.userInfo = JSON.parse(userInfo)</span><br><span class="line">        &#125;</span><br><span class="line">        this.closeLoading()</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p>我们也可以F12 来查看我产页面上的一些相当的信息</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091531196.png" alt="image-20230409153116060"></p><p>然后 我们在讲一下退出   84行 我们一点击退出 他会报404</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091605220.png" alt="image-20230409155830455"></p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091605699.png" alt="image-20230409155852787"></p><p>他其实是发了一个请求</p><p>那为什么 我们一点击退出按钮 会发出请求呢</p><p>接下来 我们来研究一下前端代码84行&lt;img src&#x3D;”images&#x2F;icons&#x2F;<a href="mailto:&#x62;&#x74;&#110;&#95;&#99;&#108;&#111;&#115;&#101;&#x40;&#x32;&#120;&#x2e;&#x70;&#x6e;&#103;">&#x62;&#x74;&#110;&#95;&#99;&#108;&#111;&#115;&#101;&#x40;&#x32;&#120;&#x2e;&#x70;&#x6e;&#103;</a>“ class&#x3D;”outLogin” alt&#x3D;”退出” @click&#x3D;”logout” &#x2F;&gt; 给这个图片加了一个@click事件 也就是一个单击事件 当我们点击退出的时候 他会执行 一个叫做logou的方法 而这个方法在181行定义了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logout() &#123;</span><br><span class="line">           logoutApi().then((res)=&gt;&#123;</span><br><span class="line">             if(res.code === 1)&#123;</span><br><span class="line">               localStorage.removeItem(&#x27;userInfo&#x27;)</span><br><span class="line">               window.location.href = &#x27;/backend/page/login/login.html&#x27;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091605604.png" alt="image-20230409160035955"></p><p>logout会调用 logoutApi（）方法    logoutApi（）这个方法在我们的Js文件里面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">loginApi</span><span class="params">(data)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;/employee/login&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">logoutApi</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $axios(&#123;</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;/employee/logout&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091605557.png" alt="image-20230409160341246"></p><p><strong>2).前端页面分析</strong></p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031404309.png" alt="image-20210727010054851" style="zoom:90%;" />   <p>点击 <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031405957.png" alt="image-20210727010150207"> 将会调用一个js方法logout, 在logout的方法中执行如下逻辑: </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031404669.png" alt="image-20210727010422199"> </p><p>A. 发起post请求, 调用服务端接口 &#x2F;employee&#x2F;logout 执行退出操作 ;</p><p>B. 删除客户端 localStorage 中存储的用户登录信息, 跳转至登录页面 ;</p><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><p>需要在Controller中创建对应的处理方法, 接收页面发送的POST请求 &#x2F;employee&#x2F;logout ，具体的处理逻辑：</p><p>A. 清理Session中的用户id</p><p>B. 返回结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 员工退出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">logout</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="comment">//清理Session中保存的当前登录员工的id</span></span><br><span class="line">    request.getSession().removeAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><p>gpt官网</p><p>这段代码是一个 Java Spring Boot Web 应用程序的 Controller 类中的一个方法，方法名为 <code>logout</code>，使用 <code>@PostMapping</code> 注解标记了一个 POST 请求处理方法。</p><p>该方法接收一个 <code>HttpServletRequest</code> 对象作为参数，它代表当前的 HTTP 请求对象。该方法的主要功能是清除当前登录员工的会话信息，从而实现员工退出登录的功能。具体来说，该方法通过 <code>request.getSession().removeAttribute(&quot;employee&quot;)</code> 代码行，删除了名为 <code>&quot;employee&quot;</code> 的 Session 属性，该属性存储了当前登录员工的 ID。当该 Session 属性不存在时，该方法不会有任何影响。最后，该方法返回了一个 <code>R</code> 对象，表示退出操作成功，并带有一条退出成功的消息字符串。</p><p>详细解释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 员工退出</span><br><span class="line"> * @param request</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这部分是一个注释块，它描述了该方法的作用和参数。注释以 <code>/**</code> 开头，是 JavaDoc 风格的注释，可以被 Java 编译器和开发工具解析。在这个注释块中，该方法被描述为“员工退出”，并且接收一个 <code>HttpServletRequest</code> 对象作为参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/logout&quot;)</span><br></pre></td></tr></table></figure><p>这是一个 Spring MVC 的注解 <code>@PostMapping</code>，它表示该方法将处理 HTTP POST 请求，并且请求的 URL 路径是 <code>/logout</code>。当 Web 应用程序接收到该 URL 路径的 POST 请求时，该方法将被调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public R&lt;String&gt; logout(HttpServletRequest request)&#123;</span><br></pre></td></tr></table></figure><p>这是该方法的签名。它定义了方法名、参数和返回值类型。该方法的返回类型是 <code>R&lt;String&gt;</code>，表示一个通用的响应对象，它包含一个字符串类型的数据。<code>HttpServletRequest</code> 参数表示当前的 HTTP 请求对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getSession().removeAttribute(&quot;employee&quot;);</span><br></pre></td></tr></table></figure><p>这是方法的主要逻辑。<code>request.getSession()</code> 返回当前 HTTP 请求的 Session 对象。Session 是服务器端用于跟踪用户会话状态的一种机制，可以通过它来存储和获取会话信息。在这个方法中，通过调用 <code>removeAttribute()</code> 方法，删除了 Session 中名为 <code>&quot;employee&quot;</code> 的属性，即当前登录员工的 ID。这样就实现了员工退出登录的功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return R.success(&quot;退出成功&quot;);</span><br></pre></td></tr></table></figure><p>最后，该方法返回一个 <code>R</code> 对象，表示退出操作成功，并且附带一条消息字符串。<code>R</code> 对象通常是自定义的响应对象，可以包含一些状态码、消息和数据等信息，用于表示请求的处理结果。在这个方法中，<code>R.success()</code> 方法返回一个成功状态的 <code>R</code> 对象，它包含了一条 <code>&quot;退出成功&quot;</code> 的消息。这个 <code>R</code> 对象将被 Spring MVC 自动转换为 JSON 格式的响应数据，返回给客户端。</p><p>国内镜像解释</p><p>具体解释如下:</p><ul><li>@PostMapping(“&#x2F;logout”):映射到名为”logout”的 POST 请求。</li><li>logout(HttpServletRequest request):方法名指定了请求的类型是 POST，并且参数是 HttpServletRequest request。</li><li>request.getSession().removeAttribute(“employee”);:这句代码会清理 Session 中保存的当前登录员工的 id。其中，”employee”是保存在 Session 中的属性名称，用于保存员工的 ID。removeAttribute 方法用于从 Session 中移除指定属性。</li><li>return R.success(“退出成功”);:返回一个 R 对象，其中 R 代表 result,success 代表成功状态，用于告诉客户端退出成功。在这里，使用了@ResponseBody 注解，可以将 R 对象转换为 JSON 格式返回给客户端。</li></ul><p>在详细一点解释</p><p>当客户端发送一个 POST 请求到指定的 URL 时，Spring MVC 会检查请求体中是否有一个名为”employee”的属性，如果有，则会清理 Session 中保存的当前登录员工的 id。具体实现如下:</p><ol><li>首先，通过 @PostMapping 注解映射到名为”logout”的 POST 请求。</li><li>然后，在 logout(HttpServletRequest request) 方法中，接收客户端发送的请求并检查请求体中是否有一个名为”employee”的属性。</li><li>如果请求体中存在”employee”属性，则调用 request.getSession().removeAttribute(“employee”); 来从 Session 中移除指定属性。</li><li>最后，返回一个 R 对象，其中 R 代表 result,success 代表成功状态，用于告诉客户端退出成功。在这里，使用了@ResponseBody 注解，可以将 R 对象转换为 JSON 格式返回给客户端。</li></ol><p>这样，当客户端再次访问该 URL 时，会检测到 Session 已经失效，从而自动退出登录。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091740567.png" alt="image-20230409160933676"></p><p>然后我们在结合前端分析一下</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091740009.png" alt="image-20230409164103707"></p><p>因为我们这里面调用的是success方法</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091740063.png" alt="image-20230409164208241"></p><p>就会把code 改成1;</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091740343.png" alt="image-20230409164242581"></p><p>这样子的话 我们页面上就可以判断了   如果code &#x3D;&#x3D;&#x3D; 1  就执行删除 <code>localStorage</code> 中的 <code>userInfo</code>，并将浏览器的 <code>location</code> 对象设置为跳转到后台管理系统登录页面。</p><p>前端代码解释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logout() &#123;</span><br><span class="line">            logoutApi().then((res)=&gt;&#123;</span><br><span class="line">              if(res.code === 1)&#123;</span><br><span class="line">                localStorage.removeItem(&#x27;userInfo&#x27;)</span><br><span class="line">                window.location.href = &#x27;/backend/page/login/login.html&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure><p>这段代码是一个名为 <code>logout</code> 的函数，该函数调用了一个名为 <code>logoutApi</code> 的异步函数，并且在 <code>logoutApi</code> 函数返回后执行了一个回调函数。回调函数检查了 <code>logoutApi</code> 的返回值 <code>res</code> 的 <code>code</code> 属性是否等于 <code>1</code>，如果等于，则删除 <code>localStorage</code> 中的 <code>userInfo</code>，并将浏览器的 <code>location</code> 对象设置为跳转到后台管理系统登录页面。</p><p>因此，可以猜测该代码用于实现用户登出功能，通过删除本地存储的用户信息并跳转到登录页面实现用户退出登录的操作。</p><h3 id="5-3-功能测试"><a href="#5-3-功能测试" class="headerlink" title="5.3 功能测试"></a>5.3 功能测试</h3><p>1). 代码实现完毕后, 重启服务, 访问登录界面 <a href="http://localhost:8080/backend/page/login/login.html">http://localhost:8080/backend/page/login/login.html</a> ;</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304091740601.png" alt="image-20230409165235393"></p><p>2). 登录完成之后, 进入到系统首页 backend&#x2F;index.html, 点击右上角 <img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031404205.png" alt="image-20210727011020244"> 按钮 执行退出操作, 完成后看看是否可以跳转到登录页面 , 并检查localStorage。</p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031404990.png" alt="image-20210727011215186"> </p><p><img src="https://cdn.jsdelivr.net/gh/zyziga/picodemo/takeaway/day01/202304031405565.png" alt="image-20210727011259297"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图片名字</title>
      <link href="/archives/cc2fcc6d.html"/>
      <url>/archives/cc2fcc6d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://picsum.photos/id/859/1919/1919" alt="图片名称八个字"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/archives/be82d226.html"/>
      <url>/archives/be82d226.html</url>
      
        <content type="html"><![CDATA[<p>1</p><h2 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h2><p>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷 ## 一级标题</p><p>2</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷 ## 二级标题<br>3</p><h2 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h2><p>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)  console.log(&quot;</span>hello world)   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)  console.log(&quot;</span>hello world)   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">     console.log(&quot;</span>hello world)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示222</title>
      <link href="/archives/71719260.html"/>
      <url>/archives/71719260.html</url>
      
        <content type="html"><![CDATA[<p>1</p><h2 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h2><p>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷 ## 一级标题</p><p>2</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷 ## 二级标题<br>3</p><h2 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h2><p>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷<br>阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷阿时睷</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)  console.log(&quot;</span>hello world)   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)  console.log(&quot;</span>hello world)   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>hello world)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world)</span></span><br><span class="line"><span class="string">     console.log(&quot;</span>hello world)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/archives/bdb6f36c.html"/>
      <url>/archives/bdb6f36c.html</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客文章  第一次学习博客学的文章</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/archives/4a17b156.html"/>
      <url>/archives/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
